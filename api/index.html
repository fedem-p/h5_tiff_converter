
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>API Reference &#8212; H5TIFF</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet" />
  <link href="../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebe@0.5.1/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe,.cell"
        const thebe_selector_input = "pre,.cell_input div.highlight"
        const thebe_selector_output = ".output,.cell_output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="First Tutorial" href="../001_h5_to_single_tiff.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
      
      
      <h1 class="site-logo" id="site-title">H5TIFF</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../index.html">
   File converter from h5 to tiff images
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Getting Started
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../installation.html">
   Installation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../001_h5_to_single_tiff.html">
   First Tutorial
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  API
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   API Reference
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/api/index.rst"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.rst</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#numpy">
   NumPy
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#how-to-use-the-documentation">
     How to use the documentation
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#available-subpackages">
     Available subpackages
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#utilities">
     Utilities
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#viewing-documentation-using-ipython">
     Viewing documentation using IPython
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#copies-vs-in-place-operation">
     Copies vs. in-place operation
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#func-one">
   Func one
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id73">
   Func one
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="module-numpy">
<span id="api-reference"></span><h1>API Reference<a class="headerlink" href="#module-numpy" title="Permalink to this headline">¶</a></h1>
<div class="section" id="numpy">
<h2>NumPy<a class="headerlink" href="#numpy" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt>Provides</dt><dd><ol class="arabic simple">
<li><p>An array object of arbitrary homogeneous items</p></li>
<li><p>Fast mathematical operations over arrays</p></li>
<li><p>Linear Algebra, Fourier Transforms, Random Number Generation</p></li>
</ol>
</dd>
</dl>
<div class="section" id="how-to-use-the-documentation">
<h3>How to use the documentation<a class="headerlink" href="#how-to-use-the-documentation" title="Permalink to this headline">¶</a></h3>
<p>Documentation is available in two forms: docstrings provided
with the code, and a loose standing reference guide, available from
<a class="reference external" href="https://www.scipy.org">the NumPy homepage</a>.</p>
<p>We recommend exploring the docstrings using
<a class="reference external" href="https://ipython.org">IPython</a>, an advanced Python shell with
TAB-completion and introspection capabilities.  See below for further
instructions.</p>
<p>The docstring examples assume that <cite>numpy</cite> has been imported as <cite>np</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
<p>Code snippets are indicated by three greater-than signs:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Use the built-in <code class="docutils literal notranslate"><span class="pre">help</span></code> function to view a function’s docstring:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">help</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">)</span>
<span class="gp">... </span>
</pre></div>
</div>
<p>For some objects, <code class="docutils literal notranslate"><span class="pre">np.info(obj)</span></code> may provide additional help.  This is
particularly true if you see the line “Help on ufunc object:” at the top
of the help() page.  Ufuncs are implemented in C, not Python, for speed.
The native Python help() does not know how to view their help, but our
np.info() function does.</p>
<p>To search for documents containing a keyword, do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">lookfor</span><span class="p">(</span><span class="s1">&#39;keyword&#39;</span><span class="p">)</span>
<span class="gp">... </span>
</pre></div>
</div>
<p>General-purpose documents like a glossary and help on the basic concepts
of numpy are available under the <code class="docutils literal notranslate"><span class="pre">doc</span></code> sub-module:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">doc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">help</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
<span class="gp">... </span>
</pre></div>
</div>
</div>
<div class="section" id="available-subpackages">
<h3>Available subpackages<a class="headerlink" href="#available-subpackages" title="Permalink to this headline">¶</a></h3>
<dl class="simple">
<dt>doc</dt><dd><p>Topical documentation on broadcasting, indexing, etc.</p>
</dd>
<dt>lib</dt><dd><p>Basic functions used by several sub-packages.</p>
</dd>
<dt>random</dt><dd><p>Core Random Tools</p>
</dd>
<dt>linalg</dt><dd><p>Core Linear Algebra Tools</p>
</dd>
<dt>fft</dt><dd><p>Core FFT routines</p>
</dd>
<dt>polynomial</dt><dd><p>Polynomial tools</p>
</dd>
<dt>testing</dt><dd><p>NumPy testing tools</p>
</dd>
<dt>f2py</dt><dd><p>Fortran to Python Interface Generator.</p>
</dd>
<dt>distutils</dt><dd><p>Enhancements to distutils with support for
Fortran compilers support and more.</p>
</dd>
</dl>
</div>
<div class="section" id="utilities">
<h3>Utilities<a class="headerlink" href="#utilities" title="Permalink to this headline">¶</a></h3>
<dl class="simple">
<dt>test</dt><dd><p>Run numpy unittests</p>
</dd>
<dt>show_config</dt><dd><p>Show numpy build configuration</p>
</dd>
<dt>dual</dt><dd><p>Overwrite certain functions with high-performance SciPy tools.
Note: <cite>numpy.dual</cite> is deprecated.  Use the functions from NumPy or Scipy
directly instead of importing them from <cite>numpy.dual</cite>.</p>
</dd>
<dt>matlib</dt><dd><p>Make everything matrices.</p>
</dd>
<dt>__version__</dt><dd><p>NumPy version string</p>
</dd>
</dl>
</div>
<div class="section" id="viewing-documentation-using-ipython">
<h3>Viewing documentation using IPython<a class="headerlink" href="#viewing-documentation-using-ipython" title="Permalink to this headline">¶</a></h3>
<p>Start IPython with the NumPy profile (<code class="docutils literal notranslate"><span class="pre">ipython</span> <span class="pre">-p</span> <span class="pre">numpy</span></code>), which will
import <cite>numpy</cite> under the alias <cite>np</cite>.  Then, use the <code class="docutils literal notranslate"><span class="pre">cpaste</span></code> command to
paste examples into the shell.  To see which functions are available in
<cite>numpy</cite>, type <code class="docutils literal notranslate"><span class="pre">np.&lt;TAB&gt;</span></code> (where <code class="docutils literal notranslate"><span class="pre">&lt;TAB&gt;</span></code> refers to the TAB key), or use
<code class="docutils literal notranslate"><span class="pre">np.*cos*?&lt;ENTER&gt;</span></code> (where <code class="docutils literal notranslate"><span class="pre">&lt;ENTER&gt;</span></code> refers to the ENTER key) to narrow
down the list.  To view the docstring for a function, use
<code class="docutils literal notranslate"><span class="pre">np.cos?&lt;ENTER&gt;</span></code> (to view the docstring) and <code class="docutils literal notranslate"><span class="pre">np.cos??&lt;ENTER&gt;</span></code> (to view
the source code).</p>
</div>
<div class="section" id="copies-vs-in-place-operation">
<h3>Copies vs. in-place operation<a class="headerlink" href="#copies-vs-in-place-operation" title="Permalink to this headline">¶</a></h3>
<p>Most of the functions in <cite>numpy</cite> return a copy of the array argument
(e.g., <cite>np.sort</cite>).  In-place versions of these functions are often
available as array methods, i.e. <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">np.array([1,2,3]);</span> <span class="pre">x.sort()</span></code>.
Exceptions to this rule are documented.</p>
<dl class="py exception">
<dt id="numpy.AxisError">
<em class="property"><span class="pre">exception</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">AxisError</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ndim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg_prefix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.AxisError" title="Permalink to this definition">¶</a></dt>
<dd><p>Axis supplied was invalid.</p>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.Bytes0">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">Bytes0</span></code><a class="headerlink" href="#numpy.Bytes0" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.bytes_" title="numpy.bytes_"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.bytes_</span></code></a></p>
</dd></dl>

<dl class="py exception">
<dt id="numpy.ComplexWarning">
<em class="property"><span class="pre">exception</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">ComplexWarning</span></code><a class="headerlink" href="#numpy.ComplexWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>The warning raised when casting a complex dtype to a real dtype.</p>
<p>As implemented, casting a complex number to a real discards its imaginary
part, but this behavior may not be what the user actually wants.</p>
</dd></dl>

<dl class="py class">
<dt id="numpy.DataSource">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">DataSource</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">destpath</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'.'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.DataSource" title="Permalink to this definition">¶</a></dt>
<dd><p>A generic data source file (file, http, ftp, …).</p>
<p>DataSources can be local files or remote files/URLs.  The files may
also be compressed or uncompressed. DataSource hides some of the
low-level details of downloading the file, allowing you to simply pass
in a valid file path (or URL) and obtain a file object.</p>
<dl class="simple">
<dt>destpath<span class="classifier">str or None, optional</span></dt><dd><p>Path to the directory where the source file gets downloaded to for
use.  If <cite>destpath</cite> is None, a temporary directory will be created.
The default path is the current directory.</p>
</dd>
</dl>
<p>URLs require a scheme string (<code class="docutils literal notranslate"><span class="pre">http://</span></code>) to be used, without it they
will fail:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">repos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">DataSource</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">repos</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s1">&#39;www.google.com/index.html&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">repos</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s1">&#39;http://www.google.com/index.html&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Temporary directories are deleted when the DataSource is deleted.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">DataSource</span><span class="p">(</span><span class="s1">&#39;/home/guido&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urlname</span> <span class="o">=</span> <span class="s1">&#39;http://www.google.com/&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gfile</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;http://www.google.com/&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">urlname</span><span class="p">)</span>
<span class="go">&#39;/home/guido/www.google.com/index.html&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">DataSource</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>  <span class="c1"># use with temporary file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;/home/guido/foobar.txt&#39;</span><span class="p">)</span>
<span class="go">&lt;open file &#39;/home/guido.foobar.txt&#39;, mode &#39;r&#39; at 0x91d4430&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="s1">&#39;/home/guido/foobar.txt&#39;</span><span class="p">)</span>
<span class="go">&#39;/tmp/.../home/guido/foobar.txt&#39;</span>
</pre></div>
</div>
<dl class="py method">
<dt id="numpy.DataSource.abspath">
<code class="sig-name descname"><span class="pre">abspath</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.DataSource.abspath" title="Permalink to this definition">¶</a></dt>
<dd><p>Return absolute path of file in the DataSource directory.</p>
<p>If <cite>path</cite> is an URL, then <cite>abspath</cite> will return either the location
the file exists locally or the location it would exist when opened
using the <cite>open</cite> method.</p>
<dl class="simple">
<dt>path<span class="classifier">str</span></dt><dd><p>Can be a local file or a remote URL.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">str</span></dt><dd><p>Complete path, including the <cite>DataSource</cite> destination directory.</p>
</dd>
</dl>
<p>The functionality is based on <cite>os.path.abspath</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.DataSource.exists">
<code class="sig-name descname"><span class="pre">exists</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.DataSource.exists" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if path exists.</p>
<p>Test if <cite>path</cite> exists as (and in this order):</p>
<ul class="simple">
<li><p>a local file.</p></li>
<li><p>a remote URL that has been downloaded and stored locally in the
<cite>DataSource</cite> directory.</p></li>
<li><p>a remote URL that has not been downloaded, but is valid and
accessible.</p></li>
</ul>
<dl class="simple">
<dt>path<span class="classifier">str</span></dt><dd><p>Can be a local file or a remote URL.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">bool</span></dt><dd><p>True if <cite>path</cite> exists.</p>
</dd>
</dl>
<p>When <cite>path</cite> is an URL, <cite>exists</cite> will return True if it’s either
stored locally in the <cite>DataSource</cite> directory, or is a valid remote
URL.  <cite>DataSource</cite> does not discriminate between the two, the file
is accessible if it exists in either location.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.DataSource.open">
<code class="sig-name descname"><span class="pre">open</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'r'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">newline</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.DataSource.open" title="Permalink to this definition">¶</a></dt>
<dd><p>Open and return file-like object.</p>
<p>If <cite>path</cite> is an URL, it will be downloaded, stored in the
<cite>DataSource</cite> directory and opened from there.</p>
<dl class="simple">
<dt>path<span class="classifier">str</span></dt><dd><p>Local file path or URL to open.</p>
</dd>
<dt>mode<span class="classifier">{‘r’, ‘w’, ‘a’}, optional</span></dt><dd><p>Mode to open <cite>path</cite>.  Mode ‘r’ for reading, ‘w’ for writing,
‘a’ to append. Available modes depend on the type of object
specified by <cite>path</cite>. Default is ‘r’.</p>
</dd>
<dt>encoding<span class="classifier">{None, str}, optional</span></dt><dd><p>Open text file with given encoding. The default encoding will be
what <cite>io.open</cite> uses.</p>
</dd>
<dt>newline<span class="classifier">{None, str}, optional</span></dt><dd><p>Newline to use when reading text file.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">file object</span></dt><dd><p>File object.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py attribute">
<dt id="numpy.Datetime64">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">Datetime64</span></code><a class="headerlink" href="#numpy.Datetime64" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.datetime64" title="numpy.datetime64"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.datetime64</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt id="numpy.MachAr">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">MachAr</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">float_conv=&lt;class</span> <span class="pre">'float'&gt;</span></em>, <em class="sig-param"><span class="pre">int_conv=&lt;class</span> <span class="pre">'int'&gt;</span></em>, <em class="sig-param"><span class="pre">float_to_float=&lt;class</span> <span class="pre">'float'&gt;</span></em>, <em class="sig-param"><span class="pre">float_to_str=&lt;function</span> <span class="pre">MachAr.&lt;lambda&gt;&gt;</span></em>, <em class="sig-param"><span class="pre">title='Python</span> <span class="pre">floating</span> <span class="pre">point</span> <span class="pre">number'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.MachAr" title="Permalink to this definition">¶</a></dt>
<dd><p>Diagnosing machine parameters.</p>
<dl class="simple">
<dt>ibeta<span class="classifier">int</span></dt><dd><p>Radix in which numbers are represented.</p>
</dd>
<dt>it<span class="classifier">int</span></dt><dd><p>Number of base-<cite>ibeta</cite> digits in the floating point mantissa M.</p>
</dd>
<dt>machep<span class="classifier">int</span></dt><dd><p>Exponent of the smallest (most negative) power of <cite>ibeta</cite> that,
added to 1.0, gives something different from 1.0</p>
</dd>
<dt>eps<span class="classifier">float</span></dt><dd><p>Floating-point number <code class="docutils literal notranslate"><span class="pre">beta**machep</span></code> (floating point precision)</p>
</dd>
<dt>negep<span class="classifier">int</span></dt><dd><p>Exponent of the smallest power of <cite>ibeta</cite> that, subtracted
from 1.0, gives something different from 1.0.</p>
</dd>
<dt>epsneg<span class="classifier">float</span></dt><dd><p>Floating-point number <code class="docutils literal notranslate"><span class="pre">beta**negep</span></code>.</p>
</dd>
<dt>iexp<span class="classifier">int</span></dt><dd><p>Number of bits in the exponent (including its sign and bias).</p>
</dd>
<dt>minexp<span class="classifier">int</span></dt><dd><p>Smallest (most negative) power of <cite>ibeta</cite> consistent with there
being no leading zeros in the mantissa.</p>
</dd>
<dt>xmin<span class="classifier">float</span></dt><dd><p>Floating-point number <code class="docutils literal notranslate"><span class="pre">beta**minexp</span></code> (the smallest [in
magnitude] positive floating point number with full precision).</p>
</dd>
<dt>maxexp<span class="classifier">int</span></dt><dd><p>Smallest (positive) power of <cite>ibeta</cite> that causes overflow.</p>
</dd>
<dt>xmax<span class="classifier">float</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(1-epsneg)</span> <span class="pre">*</span> <span class="pre">beta**maxexp</span></code> (the largest [in magnitude]
usable floating value).</p>
</dd>
<dt>irnd<span class="classifier">int</span></dt><dd><p>In <code class="docutils literal notranslate"><span class="pre">range(6)</span></code>, information on what kind of rounding is done
in addition, and on how underflow is handled.</p>
</dd>
<dt>ngrd<span class="classifier">int</span></dt><dd><p>Number of ‘guard digits’ used when truncating the product
of two mantissas to fit the representation.</p>
</dd>
<dt>epsilon<span class="classifier">float</span></dt><dd><p>Same as <cite>eps</cite>.</p>
</dd>
<dt>tiny<span class="classifier">float</span></dt><dd><p>Same as <cite>xmin</cite>.</p>
</dd>
<dt>huge<span class="classifier">float</span></dt><dd><p>Same as <cite>xmax</cite>.</p>
</dd>
<dt>precision<span class="classifier">float</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">-</span> <span class="pre">int(-log10(eps))</span></code></p>
</dd>
<dt>resolution<span class="classifier">float</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">-</span> <span class="pre">10**(-precision)</span></code></p>
</dd>
</dl>
<dl class="simple">
<dt>float_conv<span class="classifier">function, optional</span></dt><dd><p>Function that converts an integer or integer array to a float
or float array. Default is <cite>float</cite>.</p>
</dd>
<dt>int_conv<span class="classifier">function, optional</span></dt><dd><p>Function that converts a float or float array to an integer or
integer array. Default is <cite>int</cite>.</p>
</dd>
<dt>float_to_float<span class="classifier">function, optional</span></dt><dd><p>Function that converts a float array to float. Default is <cite>float</cite>.
Note that this does not seem to do anything useful in the current
implementation.</p>
</dd>
<dt>float_to_str<span class="classifier">function, optional</span></dt><dd><p>Function that converts a single float to a string. Default is
<code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">v:'%24.16e'</span> <span class="pre">%v</span></code>.</p>
</dd>
<dt>title<span class="classifier">str, optional</span></dt><dd><p>Title that is printed in the string representation of <cite>MachAr</cite>.</p>
</dd>
</dl>
<p>finfo : Machine limits for floating point types.
iinfo : Machine limits for integer types.</p>
<dl class="footnote brackets">
<dt class="label" id="id1"><span class="brackets">1</span></dt>
<dd><p>Press, Teukolsky, Vetterling and Flannery,
“Numerical Recipes in C++,” 2nd ed,
Cambridge University Press, 2002, p. 31.</p>
</dd>
</dl>
</dd></dl>

<dl class="py exception">
<dt id="numpy.ModuleDeprecationWarning">
<em class="property"><span class="pre">exception</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">ModuleDeprecationWarning</span></code><a class="headerlink" href="#numpy.ModuleDeprecationWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Module deprecation warning.</p>
<p>The nose tester turns ordinary Deprecation warnings into test failures.
That makes it hard to deprecate whole modules, because they get
imported by default. So this is a special Deprecation warning that the
nose tester will let pass without making tests fail.</p>
</dd></dl>

<dl class="py exception">
<dt id="numpy.RankWarning">
<em class="property"><span class="pre">exception</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">RankWarning</span></code><a class="headerlink" href="#numpy.RankWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Issued by <cite>polyfit</cite> when the Vandermonde matrix is rank deficient.</p>
<p>For more information, a way to suppress the warning, and an example of
<cite>RankWarning</cite> being issued, see <cite>polyfit</cite>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.Str0">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">Str0</span></code><a class="headerlink" href="#numpy.Str0" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.str_" title="numpy.str_"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.str_</span></code></a></p>
</dd></dl>

<dl class="py exception">
<dt id="numpy.TooHardError">
<em class="property"><span class="pre">exception</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">TooHardError</span></code><a class="headerlink" href="#numpy.TooHardError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="numpy.Uint64">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">Uint64</span></code><a class="headerlink" href="#numpy.Uint64" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.uint64" title="numpy.uint64"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.uint64</span></code></a></p>
</dd></dl>

<dl class="py exception">
<dt id="numpy.VisibleDeprecationWarning">
<em class="property"><span class="pre">exception</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">VisibleDeprecationWarning</span></code><a class="headerlink" href="#numpy.VisibleDeprecationWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Visible deprecation warning.</p>
<p>By default, python will not show deprecation warnings, so this class
can be used when a very visible warning is helpful, for example because
the usage is most likely a user bug.</p>
</dd></dl>

<dl class="py function">
<dt id="numpy.add_docstring">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">add_docstring</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">docstring</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.add_docstring" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a docstring to a built-in obj if possible.
If the obj already has a docstring raise a RuntimeError
If this routine does not know how to add a docstring to the object
raise a TypeError</p>
</dd></dl>

<dl class="py function">
<dt id="numpy.add_newdoc">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">add_newdoc</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">place</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">doc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">warn_on_python</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.add_newdoc" title="Permalink to this definition">¶</a></dt>
<dd><p>Add documentation to an existing object, typically one defined in C</p>
<p>The purpose is to allow easier editing of the docstrings without requiring
a re-compile. This exists primarily for internal use within numpy itself.</p>
<dl>
<dt>place<span class="classifier">str</span></dt><dd><p>The absolute name of the module to import from</p>
</dd>
<dt>obj<span class="classifier">str</span></dt><dd><p>The name of the object to add documentation to, typically a class or
function name</p>
</dd>
<dt>doc<span class="classifier">{str, Tuple[str, str], List[Tuple[str, str]]}</span></dt><dd><p>If a string, the documentation to apply to <cite>obj</cite></p>
<p>If a tuple, then the first element is interpreted as an attribute of
<cite>obj</cite> and the second as the docstring to apply - <code class="docutils literal notranslate"><span class="pre">(method,</span> <span class="pre">docstring)</span></code></p>
<p>If a list, then each element of the list should be a tuple of length
two - <code class="docutils literal notranslate"><span class="pre">[(method1,</span> <span class="pre">docstring1),</span> <span class="pre">(method2,</span> <span class="pre">docstring2),</span> <span class="pre">...]</span></code></p>
</dd>
<dt>warn_on_python<span class="classifier">bool</span></dt><dd><p>If True, the default, emit <cite>UserWarning</cite> if this is used to attach
documentation to a pure-python object.</p>
</dd>
</dl>
<p>This routine never raises an error if the docstring can’t be written, but
will raise an error if the object being documented does not exist.</p>
<p>This routine cannot modify read-only docstrings, as appear
in new-style classes or built-in functions. Because this
routine never raises an error the caller must check manually
that the docstrings were changed.</p>
<p>Since this function grabs the <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code> from a c-level str object and puts
it into the <code class="docutils literal notranslate"><span class="pre">tp_doc</span></code> slot of the type of <cite>obj</cite>, it violates a number of
C-API best-practices, by:</p>
<ul class="simple">
<li><p>modifying a <cite>PyTypeObject</cite> after calling <cite>PyType_Ready</cite></p></li>
<li><p>calling <cite>Py_INCREF</cite> on the str and losing the reference, so the str
will never be released</p></li>
</ul>
<p>If possible it should be avoided.</p>
</dd></dl>

<dl class="py function">
<dt id="numpy.add_newdoc_ufunc">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">add_newdoc_ufunc</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.add_newdoc_ufunc" title="Permalink to this definition">¶</a></dt>
<dd><p>add_ufunc_docstring(ufunc, new_docstring)</p>
<p>Replace the docstring for a ufunc with new_docstring.
This method will only work if the current docstring for
the ufunc is NULL. (At the C level, i.e. when ufunc-&gt;doc is NULL.)</p>
<dl class="simple">
<dt>ufunc<span class="classifier">numpy.ufunc</span></dt><dd><p>A ufunc whose current doc is NULL.</p>
</dd>
<dt>new_docstring<span class="classifier">string</span></dt><dd><p>The new docstring for the ufunc.</p>
</dd>
</dl>
<p>This method allocates memory for new_docstring on
the heap. Technically this creates a mempory leak, since this
memory will not be reclaimed until the end of the program
even if the ufunc itself is removed. However this will only
be a problem if the user is repeatedly creating ufuncs with
no documentation, adding documentation via add_newdoc_ufunc,
and then throwing away the ufunc.</p>
</dd></dl>

<dl class="py function">
<dt id="numpy.alen">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">alen</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.alen" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the length of the first dimension of the input array.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 1.18: </span><cite>numpy.alen</cite> is deprecated, use <cite>len</cite> instead.</p>
</div>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
</dl>
<dl class="simple">
<dt>alen<span class="classifier">int</span></dt><dd><p>Length of the first dimension of <cite>a</cite>.</p>
</dd>
</dl>
<p>shape, size</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">7</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">alen</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">7</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.all">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">all</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">a</span></em>, <em class="sig-param"><span class="pre">axis=None</span></em>, <em class="sig-param"><span class="pre">out=None</span></em>, <em class="sig-param"><span class="pre">keepdims=&lt;no</span> <span class="pre">value&gt;</span></em>, <em class="sig-param"><span class="pre">*</span></em>, <em class="sig-param"><span class="pre">where=&lt;no</span> <span class="pre">value&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.all" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether all array elements along a given axis evaluate to True.</p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input array or object that can be converted to an array.</p>
</dd>
<dt>axis<span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Axis or axes along which a logical AND reduction is performed.
The default (<code class="docutils literal notranslate"><span class="pre">axis=None</span></code>) is to perform a logical AND over all
the dimensions of the input array. <cite>axis</cite> may be negative, in
which case it counts from the last to the first axis.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<p>If this is a tuple of ints, a reduction is performed on multiple
axes, instead of a single axis or all the axes as before.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Alternate output array in which to place the result.
It must have the same shape as the expected output and its
type is preserved (e.g., if <code class="docutils literal notranslate"><span class="pre">dtype(out)</span></code> is float, the result
will consist of 0.0’s and 1.0’s). See <span class="xref std std-ref">ufuncs-output-type</span> for more
details.</p>
</dd>
<dt>keepdims<span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p>If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>all</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
<dt>where<span class="classifier">array_like of bool, optional</span></dt><dd><p>Elements to include in checking for all <cite>True</cite> values.
See <cite>~numpy.ufunc.reduce</cite> for details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.20.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>all<span class="classifier">ndarray, bool</span></dt><dd><p>A new boolean or array is returned unless <cite>out</cite> is specified,
in which case a reference to <cite>out</cite> is returned.</p>
</dd>
</dl>
<p>ndarray.all : equivalent method</p>
<p>any : Test whether any element along a given axis evaluates to True.</p>
<p>Not a Number (NaN), positive infinity and negative infinity
evaluate to <cite>True</cite> because these are not equal to zero.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([[</span><span class="kc">True</span><span class="p">,</span><span class="kc">False</span><span class="p">],[</span><span class="kc">True</span><span class="p">,</span><span class="kc">True</span><span class="p">]])</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([[</span><span class="kc">True</span><span class="p">,</span><span class="kc">False</span><span class="p">],[</span><span class="kc">True</span><span class="p">,</span><span class="kc">True</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ True, False])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">]],</span> <span class="n">where</span><span class="o">=</span><span class="p">[[</span><span class="kc">True</span><span class="p">],</span> <span class="p">[</span><span class="kc">False</span><span class="p">]])</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">o</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="nb">id</span><span class="p">(</span><span class="n">o</span><span class="p">),</span> <span class="n">z</span>
<span class="go">(28293632, 28293632, array(True)) # may vary</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.allclose">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">allclose</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">equal_nan</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.allclose" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if two arrays are element-wise equal within a tolerance.</p>
<p>The tolerance values are positive, typically very small numbers.  The
relative difference (<cite>rtol</cite> * abs(<cite>b</cite>)) and the absolute difference
<cite>atol</cite> are added together to compare against the absolute difference
between <cite>a</cite> and <cite>b</cite>.</p>
<p>NaNs are treated as equal if they are in the same place and if
<code class="docutils literal notranslate"><span class="pre">equal_nan=True</span></code>.  Infs are treated as equal if they are in the same
place and of the same sign in both arrays.</p>
<dl>
<dt>a, b<span class="classifier">array_like</span></dt><dd><p>Input arrays to compare.</p>
</dd>
<dt>rtol<span class="classifier">float</span></dt><dd><p>The relative tolerance parameter (see Notes).</p>
</dd>
<dt>atol<span class="classifier">float</span></dt><dd><p>The absolute tolerance parameter (see Notes).</p>
</dd>
<dt>equal_nan<span class="classifier">bool</span></dt><dd><p>Whether to compare NaN’s as equal.  If True, NaN’s in <cite>a</cite> will be
considered equal to NaN’s in <cite>b</cite> in the output array.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>allclose<span class="classifier">bool</span></dt><dd><p>Returns True if the two arrays are equal within the given
tolerance; False otherwise.</p>
</dd>
</dl>
<p>isclose, all, any, equal</p>
<p>If the following equation is element-wise True, then allclose returns
True.</p>
<blockquote>
<div><p>absolute(<cite>a</cite> - <cite>b</cite>) &lt;= (<cite>atol</cite> + <cite>rtol</cite> * absolute(<cite>b</cite>))</p>
</div></blockquote>
<p>The above equation is not symmetric in <cite>a</cite> and <cite>b</cite>, so that
<code class="docutils literal notranslate"><span class="pre">allclose(a,</span> <span class="pre">b)</span></code> might be different from <code class="docutils literal notranslate"><span class="pre">allclose(b,</span> <span class="pre">a)</span></code> in
some rare cases.</p>
<p>The comparison of <cite>a</cite> and <cite>b</cite> uses standard broadcasting, which
means that <cite>a</cite> and <cite>b</cite> need not have the same shape in order for
<code class="docutils literal notranslate"><span class="pre">allclose(a,</span> <span class="pre">b)</span></code> to evaluate to True.  The same is true for
<cite>equal</cite> but not <cite>array_equal</cite>.</p>
<p><cite>allclose</cite> is not defined for non-numeric data types.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">([</span><span class="mf">1e10</span><span class="p">,</span><span class="mf">1e-7</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.00001e10</span><span class="p">,</span><span class="mf">1e-8</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">([</span><span class="mf">1e10</span><span class="p">,</span><span class="mf">1e-8</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.00001e10</span><span class="p">,</span><span class="mf">1e-9</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">([</span><span class="mf">1e10</span><span class="p">,</span><span class="mf">1e-8</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0001e10</span><span class="p">,</span><span class="mf">1e-9</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">equal_nan</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.alltrue">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">alltrue</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.alltrue" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if all elements of input array are true.</p>
<p>numpy.all : Equivalent function; see for details.</p>
</dd></dl>

<dl class="py function">
<dt id="numpy.amax">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">amax</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">a</span></em>, <em class="sig-param"><span class="pre">axis=None</span></em>, <em class="sig-param"><span class="pre">out=None</span></em>, <em class="sig-param"><span class="pre">keepdims=&lt;no</span> <span class="pre">value&gt;</span></em>, <em class="sig-param"><span class="pre">initial=&lt;no</span> <span class="pre">value&gt;</span></em>, <em class="sig-param"><span class="pre">where=&lt;no</span> <span class="pre">value&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.amax" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum of an array or maximum along an axis.</p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input data.</p>
</dd>
<dt>axis<span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Axis or axes along which to operate.  By default, flattened input is
used.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<p>If this is a tuple of ints, the maximum is selected over multiple axes,
instead of a single axis or all the axes as before.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Alternative output array in which to place the result.  Must
be of the same shape and buffer length as the expected output.
See <span class="xref std std-ref">ufuncs-output-type</span> for more details.</p>
</dd>
<dt>keepdims<span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p>If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>amax</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
<dt>initial<span class="classifier">scalar, optional</span></dt><dd><p>The minimum value of an output element. Must be present to allow
computation on empty slice. See <cite>~numpy.ufunc.reduce</cite> for details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.15.0.</span></p>
</div>
</dd>
<dt>where<span class="classifier">array_like of bool, optional</span></dt><dd><p>Elements to compare for the maximum. See <cite>~numpy.ufunc.reduce</cite>
for details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.17.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>amax<span class="classifier">ndarray or scalar</span></dt><dd><p>Maximum of <cite>a</cite>. If <cite>axis</cite> is None, the result is a scalar value.
If <cite>axis</cite> is given, the result is an array of dimension
<code class="docutils literal notranslate"><span class="pre">a.ndim</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
</dd>
</dl>
<dl class="simple">
<dt>amin :</dt><dd><p>The minimum value of an array along a given axis, propagating any NaNs.</p>
</dd>
<dt>nanmax :</dt><dd><p>The maximum value of an array along a given axis, ignoring any NaNs.</p>
</dd>
<dt>maximum :</dt><dd><p>Element-wise maximum of two arrays, propagating any NaNs.</p>
</dd>
<dt>fmax :</dt><dd><p>Element-wise maximum of two arrays, ignoring any NaNs.</p>
</dd>
<dt>argmax :</dt><dd><p>Return the indices of the maximum values.</p>
</dd>
</dl>
<p>nanmin, minimum, fmin</p>
<p>NaN values are propagated, that is if at least one item is NaN, the
corresponding max value will be NaN as well. To ignore NaN values
(MATLAB behavior), please use nanmax.</p>
<p>Don’t use <cite>amax</cite> for element-wise comparison of 2 arrays; when
<code class="docutils literal notranslate"><span class="pre">a.shape[0]</span></code> is 2, <code class="docutils literal notranslate"><span class="pre">maximum(a[0],</span> <span class="pre">a[1])</span></code> is faster than
<code class="docutils literal notranslate"><span class="pre">amax(a,</span> <span class="pre">axis=0)</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>           <span class="c1"># Maximum of the flattened array</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>   <span class="c1"># Maxima along the first axis</span>
<span class="go">array([2, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># Maxima along the second axis</span>
<span class="go">array([1, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="n">initial</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([-1,  3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">nan</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">where</span><span class="o">=~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">initial</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">4.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">4.0</span>
</pre></div>
</div>
<p>You can use an initial value to compute the maximum of an empty slice, or
to initialize it to a different value:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([[</span><span class="o">-</span><span class="mi">50</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 0, 10])</span>
</pre></div>
</div>
<p>Notice that the initial value is used as one of the elements for which the
maximum is determined, unlike for the default argument Python’s max
function, which is only used for empty iterables.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="mi">5</span><span class="p">],</span> <span class="n">initial</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span><span class="p">([</span><span class="mi">5</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.amin">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">amin</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">a</span></em>, <em class="sig-param"><span class="pre">axis=None</span></em>, <em class="sig-param"><span class="pre">out=None</span></em>, <em class="sig-param"><span class="pre">keepdims=&lt;no</span> <span class="pre">value&gt;</span></em>, <em class="sig-param"><span class="pre">initial=&lt;no</span> <span class="pre">value&gt;</span></em>, <em class="sig-param"><span class="pre">where=&lt;no</span> <span class="pre">value&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.amin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the minimum of an array or minimum along an axis.</p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input data.</p>
</dd>
<dt>axis<span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Axis or axes along which to operate.  By default, flattened input is
used.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<p>If this is a tuple of ints, the minimum is selected over multiple axes,
instead of a single axis or all the axes as before.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Alternative output array in which to place the result.  Must
be of the same shape and buffer length as the expected output.
See <span class="xref std std-ref">ufuncs-output-type</span> for more details.</p>
</dd>
<dt>keepdims<span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p>If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>amin</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
<dt>initial<span class="classifier">scalar, optional</span></dt><dd><p>The maximum value of an output element. Must be present to allow
computation on empty slice. See <cite>~numpy.ufunc.reduce</cite> for details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.15.0.</span></p>
</div>
</dd>
<dt>where<span class="classifier">array_like of bool, optional</span></dt><dd><p>Elements to compare for the minimum. See <cite>~numpy.ufunc.reduce</cite>
for details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.17.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>amin<span class="classifier">ndarray or scalar</span></dt><dd><p>Minimum of <cite>a</cite>. If <cite>axis</cite> is None, the result is a scalar value.
If <cite>axis</cite> is given, the result is an array of dimension
<code class="docutils literal notranslate"><span class="pre">a.ndim</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
</dd>
</dl>
<dl class="simple">
<dt>amax :</dt><dd><p>The maximum value of an array along a given axis, propagating any NaNs.</p>
</dd>
<dt>nanmin :</dt><dd><p>The minimum value of an array along a given axis, ignoring any NaNs.</p>
</dd>
<dt>minimum :</dt><dd><p>Element-wise minimum of two arrays, propagating any NaNs.</p>
</dd>
<dt>fmin :</dt><dd><p>Element-wise minimum of two arrays, ignoring any NaNs.</p>
</dd>
<dt>argmin :</dt><dd><p>Return the indices of the minimum values.</p>
</dd>
</dl>
<p>nanmax, maximum, fmax</p>
<p>NaN values are propagated, that is if at least one item is NaN, the
corresponding min value will be NaN as well. To ignore NaN values
(MATLAB behavior), please use nanmin.</p>
<p>Don’t use <cite>amin</cite> for element-wise comparison of 2 arrays; when
<code class="docutils literal notranslate"><span class="pre">a.shape[0]</span></code> is 2, <code class="docutils literal notranslate"><span class="pre">minimum(a[0],</span> <span class="pre">a[1])</span></code> is faster than
<code class="docutils literal notranslate"><span class="pre">amin(a,</span> <span class="pre">axis=0)</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>           <span class="c1"># Minimum of the flattened array</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>   <span class="c1"># Minima along the first axis</span>
<span class="go">array([0, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># Minima along the second axis</span>
<span class="go">array([0, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="n">initial</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([10,  1])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">nan</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">where</span><span class="o">=~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">initial</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([[</span><span class="o">-</span><span class="mi">50</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([-50,   0])</span>
</pre></div>
</div>
<p>Notice that the initial value is used as one of the elements for which the
minimum is determined, unlike for the default argument Python’s max
function, which is only used for empty iterables.</p>
<p>Notice that this isn’t the same as Python’s <code class="docutils literal notranslate"><span class="pre">default</span></code> argument.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="mi">6</span><span class="p">],</span> <span class="n">initial</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">min</span><span class="p">([</span><span class="mi">6</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">6</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.angle">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">angle</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the angle of the complex argument.</p>
<dl class="simple">
<dt>z<span class="classifier">array_like</span></dt><dd><p>A complex number or sequence of complex numbers.</p>
</dd>
<dt>deg<span class="classifier">bool, optional</span></dt><dd><p>Return angle in degrees if True, radians if False (default).</p>
</dd>
</dl>
<dl>
<dt>angle<span class="classifier">ndarray or scalar</span></dt><dd><p>The counterclockwise angle from the positive real axis on the complex
plane in the range <code class="docutils literal notranslate"><span class="pre">(-pi,</span> <span class="pre">pi]</span></code>, with dtype as numpy.float64.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.16.0: </span>This function works on subclasses of ndarray like <cite>ma.array</cite>.</p>
</div>
</dd>
</dl>
<p>arctan2
absolute</p>
<p>Although the angle of the complex number 0 is undefined, <code class="docutils literal notranslate"><span class="pre">numpy.angle(0)</span></code>
returns the value 0.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">])</span>               <span class="c1"># in radians</span>
<span class="go">array([ 0.        ,  1.57079633,  0.78539816]) # may vary</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>                  <span class="c1"># in degrees</span>
<span class="go">45.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.any">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">any</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">a</span></em>, <em class="sig-param"><span class="pre">axis=None</span></em>, <em class="sig-param"><span class="pre">out=None</span></em>, <em class="sig-param"><span class="pre">keepdims=&lt;no</span> <span class="pre">value&gt;</span></em>, <em class="sig-param"><span class="pre">*</span></em>, <em class="sig-param"><span class="pre">where=&lt;no</span> <span class="pre">value&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.any" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether any array element along a given axis evaluates to True.</p>
<p>Returns single boolean unless <cite>axis</cite> is not <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input array or object that can be converted to an array.</p>
</dd>
<dt>axis<span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Axis or axes along which a logical OR reduction is performed.
The default (<code class="docutils literal notranslate"><span class="pre">axis=None</span></code>) is to perform a logical OR over all
the dimensions of the input array. <cite>axis</cite> may be negative, in
which case it counts from the last to the first axis.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<p>If this is a tuple of ints, a reduction is performed on multiple
axes, instead of a single axis or all the axes as before.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Alternate output array in which to place the result.  It must have
the same shape as the expected output and its type is preserved
(e.g., if it is of type float, then it will remain so, returning
1.0 for True and 0.0 for False, regardless of the type of <cite>a</cite>).
See <span class="xref std std-ref">ufuncs-output-type</span> for more details.</p>
</dd>
<dt>keepdims<span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p>If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>any</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
<dt>where<span class="classifier">array_like of bool, optional</span></dt><dd><p>Elements to include in checking for any <cite>True</cite> values.
See <cite>~numpy.ufunc.reduce</cite> for details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.20.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>any<span class="classifier">bool or ndarray</span></dt><dd><p>A new boolean or <cite>ndarray</cite> is returned unless <cite>out</cite> is specified,
in which case a reference to <cite>out</cite> is returned.</p>
</dd>
</dl>
<p>ndarray.any : equivalent method</p>
<p>all : Test whether all elements along a given axis evaluate to True.</p>
<p>Not a Number (NaN), positive infinity and negative infinity evaluate
to <cite>True</cite> because these are not equal to zero.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]])</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ True, False])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]],</span> <span class="n">where</span><span class="o">=</span><span class="p">[[</span><span class="kc">False</span><span class="p">],</span> <span class="p">[</span><span class="kc">True</span><span class="p">]])</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">o</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="p">,</span> <span class="n">o</span>
<span class="go">(array(True), array(True))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Check now that z is a reference to o</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="ow">is</span> <span class="n">o</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="nb">id</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="c1"># identity of z and o              </span>
<span class="go">(191614240, 191614240)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.append">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">append</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Append values to the end of an array.</p>
<dl class="simple">
<dt>arr<span class="classifier">array_like</span></dt><dd><p>Values are appended to a copy of this array.</p>
</dd>
<dt>values<span class="classifier">array_like</span></dt><dd><p>These values are appended to a copy of <cite>arr</cite>.  It must be of the
correct shape (the same shape as <cite>arr</cite>, excluding <cite>axis</cite>).  If
<cite>axis</cite> is not specified, <cite>values</cite> can be any shape and will be
flattened before use.</p>
</dd>
<dt>axis<span class="classifier">int, optional</span></dt><dd><p>The axis along which <cite>values</cite> are appended.  If <cite>axis</cite> is not
given, both <cite>arr</cite> and <cite>values</cite> are flattened before use.</p>
</dd>
</dl>
<dl class="simple">
<dt>append<span class="classifier">ndarray</span></dt><dd><p>A copy of <cite>arr</cite> with <cite>values</cite> appended to <cite>axis</cite>.  Note that
<cite>append</cite> does not occur in-place: a new array is allocated and
filled.  If <cite>axis</cite> is None, <cite>out</cite> is a flattened array.</p>
</dd>
</dl>
<p>insert : Insert elements into an array.
delete : Delete elements from an array.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]])</span>
<span class="go">array([1, 2, 3, ..., 7, 8, 9])</span>
</pre></div>
</div>
<p>When <cite>axis</cite> is specified, <cite>values</cite> must have the correct shape.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [4, 5, 6],</span>
<span class="go">       [7, 8, 9]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">ValueError</span>: <span class="n">all the input arrays must have same number of dimensions, but</span>
<span class="go">the array at index 0 has 2 dimension(s) and the array at index 1 has 1</span>
<span class="go">dimension(s)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.apply_along_axis">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">apply_along_axis</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func1d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.apply_along_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a function to 1-D slices along the given axis.</p>
<p>Execute <cite>func1d(a, *args, **kwargs)</cite> where <cite>func1d</cite> operates on 1-D arrays
and <cite>a</cite> is a 1-D slice of <cite>arr</cite> along <cite>axis</cite>.</p>
<p>This is equivalent to (but faster than) the following use of <cite>ndindex</cite> and
<cite>s_</cite>, which sets each of <code class="docutils literal notranslate"><span class="pre">ii</span></code>, <code class="docutils literal notranslate"><span class="pre">jj</span></code>, and <code class="docutils literal notranslate"><span class="pre">kk</span></code> to a tuple of indices:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ni</span><span class="p">,</span> <span class="n">Nk</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">],</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
<span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Ni</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Nk</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">func1d</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">s_</span><span class="p">[:,]</span> <span class="o">+</span> <span class="n">kk</span><span class="p">])</span>
        <span class="n">Nj</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Nj</span><span class="p">):</span>
            <span class="n">out</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">jj</span> <span class="o">+</span> <span class="n">kk</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span>
</pre></div>
</div>
<p>Equivalently, eliminating the inner loop, this can be expressed as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ni</span><span class="p">,</span> <span class="n">Nk</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">],</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
<span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Ni</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Nk</span><span class="p">):</span>
        <span class="n">out</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">s_</span><span class="p">[</span><span class="o">...</span><span class="p">,]</span> <span class="o">+</span> <span class="n">kk</span><span class="p">]</span> <span class="o">=</span> <span class="n">func1d</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">s_</span><span class="p">[:,]</span> <span class="o">+</span> <span class="n">kk</span><span class="p">])</span>
</pre></div>
</div>
<dl>
<dt>func1d<span class="classifier">function (M,) -&gt; (Nj…)</span></dt><dd><p>This function should accept 1-D arrays. It is applied to 1-D
slices of <cite>arr</cite> along the specified axis.</p>
</dd>
<dt>axis<span class="classifier">integer</span></dt><dd><p>Axis along which <cite>arr</cite> is sliced.</p>
</dd>
<dt>arr<span class="classifier">ndarray (Ni…, M, Nk…)</span></dt><dd><p>Input array.</p>
</dd>
<dt>args<span class="classifier">any</span></dt><dd><p>Additional arguments to <cite>func1d</cite>.</p>
</dd>
<dt>kwargs<span class="classifier">any</span></dt><dd><p>Additional named arguments to <cite>func1d</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.9.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray  (Ni…, Nj…, Nk…)</span></dt><dd><p>The output array. The shape of <cite>out</cite> is identical to the shape of
<cite>arr</cite>, except along the <cite>axis</cite> dimension. This axis is removed, and
replaced with new dimensions equal to the shape of the return value
of <cite>func1d</cite>. So if <cite>func1d</cite> returns a scalar <cite>out</cite> will have one
fewer dimensions than <cite>arr</cite>.</p>
</dd>
</dl>
<p>apply_over_axes : Apply a function repeatedly over multiple axes.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">my_func</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="gp">... </span>    <span class="sd">&quot;&quot;&quot;Average first and last element of a 1-D array&quot;&quot;&quot;</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">my_func</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([4., 5., 6.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">my_func</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([2.,  5.,  8.])</span>
</pre></div>
</div>
<p>For a function that returns a 1D array, the number of dimensions in
<cite>outarr</cite> is the same as <cite>arr</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="nb">sorted</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[1, 7, 8],</span>
<span class="go">       [3, 4, 9],</span>
<span class="go">       [2, 5, 6]])</span>
</pre></div>
</div>
<p>For a function that returns a higher dimensional array, those dimensions
are inserted in place of the <cite>axis</cite> dimension.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[[1, 0, 0],</span>
<span class="go">        [0, 2, 0],</span>
<span class="go">        [0, 0, 3]],</span>
<span class="go">       [[4, 0, 0],</span>
<span class="go">        [0, 5, 0],</span>
<span class="go">        [0, 0, 6]],</span>
<span class="go">       [[7, 0, 0],</span>
<span class="go">        [0, 8, 0],</span>
<span class="go">        [0, 0, 9]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.apply_over_axes">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">apply_over_axes</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.apply_over_axes" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a function repeatedly over multiple axes.</p>
<p><cite>func</cite> is called as <cite>res = func(a, axis)</cite>, where <cite>axis</cite> is the first
element of <cite>axes</cite>.  The result <cite>res</cite> of the function call must have
either the same dimensions as <cite>a</cite> or one less dimension.  If <cite>res</cite>
has one less dimension than <cite>a</cite>, a dimension is inserted before
<cite>axis</cite>.  The call to <cite>func</cite> is then repeated for each axis in <cite>axes</cite>,
with <cite>res</cite> as the first argument.</p>
<dl class="simple">
<dt>func<span class="classifier">function</span></dt><dd><p>This function must take two arguments, <cite>func(a, axis)</cite>.</p>
</dd>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt>axes<span class="classifier">array_like</span></dt><dd><p>Axes over which <cite>func</cite> is applied; the elements must be integers.</p>
</dd>
</dl>
<dl class="simple">
<dt>apply_over_axis<span class="classifier">ndarray</span></dt><dd><p>The output array.  The number of dimensions is the same as <cite>a</cite>,
but the shape can be different.  This depends on whether <cite>func</cite>
changes the shape of its output with respect to its input.</p>
</dd>
</dl>
<dl class="simple">
<dt>apply_along_axis :</dt><dd><p>Apply a function to 1-D slices of an array along the given axis.</p>
</dd>
</dl>
<p>This function is equivalent to tuple axis arguments to reorderable ufuncs
with keepdims=True. Tuple axis arguments to ufuncs have been available since
version 1.7.0.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]],</span>
<span class="go">       [[12, 13, 14, 15],</span>
<span class="go">        [16, 17, 18, 19],</span>
<span class="go">        [20, 21, 22, 23]]])</span>
</pre></div>
</div>
<p>Sum over axes 0 and 2. The result has same number of dimensions
as the original array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">apply_over_axes</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">array([[[ 60],</span>
<span class="go">        [ 92],</span>
<span class="go">        [124]]])</span>
</pre></div>
</div>
<p>Tuple axis arguments to ufuncs are equivalent:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([[[ 60],</span>
<span class="go">        [ 92],</span>
<span class="go">        [124]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.arange">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">arange</span></code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="pre">start</span></em>, <span class="optional">]</span><em class="sig-param"><span class="pre">stop</span></em>, <span class="optional">[</span><em class="sig-param"><span class="pre">step</span></em>, <span class="optional">]</span><em class="sig-param"><span class="pre">dtype=None</span></em>, <em class="sig-param"><span class="pre">*</span></em>, <em class="sig-param"><span class="pre">like=None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.arange" title="Permalink to this definition">¶</a></dt>
<dd><p>Return evenly spaced values within a given interval.</p>
<p>Values are generated within the half-open interval <code class="docutils literal notranslate"><span class="pre">[start,</span> <span class="pre">stop)</span></code>
(in other words, the interval including <cite>start</cite> but excluding <cite>stop</cite>).
For integer arguments the function is equivalent to the Python built-in
<cite>range</cite> function, but returns an ndarray rather than a list.</p>
<p>When using a non-integer step, such as 0.1, the results will often not
be consistent.  It is better to use <cite>numpy.linspace</cite> for these cases.</p>
<dl>
<dt>start<span class="classifier">integer or real, optional</span></dt><dd><p>Start of interval.  The interval includes this value.  The default
start value is 0.</p>
</dd>
<dt>stop<span class="classifier">integer or real</span></dt><dd><p>End of interval.  The interval does not include this value, except
in some cases where <cite>step</cite> is not an integer and floating point
round-off affects the length of <cite>out</cite>.</p>
</dd>
<dt>step<span class="classifier">integer or real, optional</span></dt><dd><p>Spacing between values.  For any output <cite>out</cite>, this is the distance
between two adjacent values, <code class="docutils literal notranslate"><span class="pre">out[i+1]</span> <span class="pre">-</span> <span class="pre">out[i]</span></code>.  The default
step size is 1.  If <cite>step</cite> is specified as a position argument,
<cite>start</cite> must also be given.</p>
</dd>
<dt>dtype<span class="classifier">dtype</span></dt><dd><p>The type of the output array.  If <cite>dtype</cite> is not given, infer the data
type from the other input arguments.</p>
</dd>
<dt>like<span class="classifier">array_like</span></dt><dd><p>Reference object to allow the creation of arrays which are not
NumPy arrays. If an array-like passed in as <code class="docutils literal notranslate"><span class="pre">like</span></code> supports
the <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> protocol, the result will be defined
by it. In this case, it ensures the creation of an array object
compatible with that passed in via this argument.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.20.0.</span></p>
</div>
</dd>
</dl>
<dl>
<dt>arange<span class="classifier">ndarray</span></dt><dd><p>Array of evenly spaced values.</p>
<p>For floating point arguments, the length of the result is
<code class="docutils literal notranslate"><span class="pre">ceil((stop</span> <span class="pre">-</span> <span class="pre">start)/step)</span></code>.  Because of floating point overflow,
this rule may result in the last element of <cite>out</cite> being greater
than <cite>stop</cite>.</p>
</dd>
</dl>
<p>numpy.linspace : Evenly spaced numbers with careful handling of endpoints.
numpy.ogrid: Arrays of evenly spaced numbers in N-dimensions.
numpy.mgrid: Grid-shaped arrays of evenly spaced numbers in N-dimensions.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">array([0, 1, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span>
<span class="go">array([ 0.,  1.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span>
<span class="go">array([3, 4, 5, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([3, 5])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.argmax">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">argmax</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.argmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the indices of the maximum values along an axis.</p>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt>axis<span class="classifier">int, optional</span></dt><dd><p>By default, the index is into the flattened array, otherwise
along the specified axis.</p>
</dd>
<dt>out<span class="classifier">array, optional</span></dt><dd><p>If provided, the result will be inserted into this array. It should
be of the appropriate shape and dtype.</p>
</dd>
</dl>
<dl class="simple">
<dt>index_array<span class="classifier">ndarray of ints</span></dt><dd><p>Array of indices into the array. It has the same shape as <cite>a.shape</cite>
with the dimension along <cite>axis</cite> removed.</p>
</dd>
</dl>
<p>ndarray.argmax, argmin
amax : The maximum value along a given axis.
unravel_index : Convert a flat index into an index tuple.
take_along_axis : Apply <code class="docutils literal notranslate"><span class="pre">np.expand_dims(index_array,</span> <span class="pre">axis)</span></code></p>
<blockquote>
<div><p>from argmax to an array as if by calling max.</p>
</div></blockquote>
<p>In case of multiple occurrences of the maximum values, the indices
corresponding to the first occurrence are returned.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[10, 11, 12],</span>
<span class="go">       [13, 14, 15]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([1, 1, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([2, 2])</span>
</pre></div>
</div>
<p>Indexes of the maximal elements of a N-dimensional array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">),</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span>
<span class="go">(1, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
<span class="go">15</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([0, 5, 2, 3, 4, 5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  <span class="c1"># Only the first occurrence is returned.</span>
<span class="go">1</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">index_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Same as np.max(x, axis=-1, keepdims=True)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">index_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[4],</span>
<span class="go">       [3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Same as np.max(x, axis=-1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">index_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([4, 3])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.argmin">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">argmin</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.argmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the indices of the minimum values along an axis.</p>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt>axis<span class="classifier">int, optional</span></dt><dd><p>By default, the index is into the flattened array, otherwise
along the specified axis.</p>
</dd>
<dt>out<span class="classifier">array, optional</span></dt><dd><p>If provided, the result will be inserted into this array. It should
be of the appropriate shape and dtype.</p>
</dd>
</dl>
<dl class="simple">
<dt>index_array<span class="classifier">ndarray of ints</span></dt><dd><p>Array of indices into the array. It has the same shape as <cite>a.shape</cite>
with the dimension along <cite>axis</cite> removed.</p>
</dd>
</dl>
<p>ndarray.argmin, argmax
amin : The minimum value along a given axis.
unravel_index : Convert a flat index into an index tuple.
take_along_axis : Apply <code class="docutils literal notranslate"><span class="pre">np.expand_dims(index_array,</span> <span class="pre">axis)</span></code></p>
<blockquote>
<div><p>from argmin to an array as if by calling min.</p>
</div></blockquote>
<p>In case of multiple occurrences of the minimum values, the indices
corresponding to the first occurrence are returned.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[10, 11, 12],</span>
<span class="go">       [13, 14, 15]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([0, 0, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([0, 0])</span>
</pre></div>
</div>
<p>Indices of the minimum elements of a N-dimensional array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">),</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span>
<span class="go">(0, 0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
<span class="go">10</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([10, 11, 12, 13, 10, 15])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  <span class="c1"># Only the first occurrence is returned.</span>
<span class="go">0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">index_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Same as np.min(x, axis=-1, keepdims=True)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">index_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[2],</span>
<span class="go">       [0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Same as np.max(x, axis=-1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">index_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([2, 0])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.argpartition">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">argpartition</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'introselect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.argpartition" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform an indirect partition along the given axis using the
algorithm specified by the <cite>kind</cite> keyword. It returns an array of
indices of the same shape as <cite>a</cite> that index data along the given
axis in partitioned order.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>Array to sort.</p>
</dd>
<dt>kth<span class="classifier">int or sequence of ints</span></dt><dd><p>Element index to partition by. The k-th element will be in its
final sorted position and all smaller elements will be moved
before it and all larger elements behind it. The order all
elements in the partitions is undefined. If provided with a
sequence of k-th it will partition all of them into their sorted
position at once.</p>
</dd>
<dt>axis<span class="classifier">int or None, optional</span></dt><dd><p>Axis along which to sort. The default is -1 (the last axis). If
None, the flattened array is used.</p>
</dd>
<dt>kind<span class="classifier">{‘introselect’}, optional</span></dt><dd><p>Selection algorithm. Default is ‘introselect’</p>
</dd>
<dt>order<span class="classifier">str or list of str, optional</span></dt><dd><p>When <cite>a</cite> is an array with fields defined, this argument
specifies which fields to compare first, second, etc. A single
field can be specified as a string, and not all fields need be
specified, but unspecified fields will still be used, in the
order in which they come up in the dtype, to break ties.</p>
</dd>
</dl>
<dl class="simple">
<dt>index_array<span class="classifier">ndarray, int</span></dt><dd><p>Array of indices that partition <cite>a</cite> along the specified axis.
If <cite>a</cite> is one-dimensional, <code class="docutils literal notranslate"><span class="pre">a[index_array]</span></code> yields a partitioned <cite>a</cite>.
More generally, <code class="docutils literal notranslate"><span class="pre">np.take_along_axis(a,</span> <span class="pre">index_array,</span> <span class="pre">axis=a)</span></code> always
yields the partitioned <cite>a</cite>, irrespective of dimensionality.</p>
</dd>
</dl>
<p>partition : Describes partition algorithms used.
ndarray.partition : Inplace partition.
argsort : Full indirect sort.
take_along_axis : Apply <code class="docutils literal notranslate"><span class="pre">index_array</span></code> from argpartition</p>
<blockquote>
<div><p>to an array as if by calling partition.</p>
</div></blockquote>
<p>See <cite>partition</cite> for notes on the different selection algorithms.</p>
<p>One dimensional array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argpartition</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
<span class="go">array([2, 1, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argpartition</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))]</span>
<span class="go">array([1, 2, 3, 4])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">argpartition</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
<span class="go">array([2, 1, 3, 4])</span>
</pre></div>
</div>
<p>Multi-dimensional array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">index_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argpartition</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">kth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">index_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># same as np.partition(x, kth=1)</span>
<span class="go">array([[2, 3, 4],</span>
<span class="go">       [1, 1, 3]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.argsort">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">argsort</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.argsort" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the indices that would sort an array.</p>
<p>Perform an indirect sort along the given axis using the algorithm specified
by the <cite>kind</cite> keyword. It returns an array of indices of the same shape as
<cite>a</cite> that index data along the given axis in sorted order.</p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Array to sort.</p>
</dd>
<dt>axis<span class="classifier">int or None, optional</span></dt><dd><p>Axis along which to sort.  The default is -1 (the last axis). If None,
the flattened array is used.</p>
</dd>
<dt>kind<span class="classifier">{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional</span></dt><dd><p>Sorting algorithm. The default is ‘quicksort’. Note that both ‘stable’
and ‘mergesort’ use timsort under the covers and, in general, the
actual implementation will vary with data type. The ‘mergesort’ option
is retained for backwards compatibility.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.15.0.: </span>The ‘stable’ option was added.</p>
</div>
</dd>
<dt>order<span class="classifier">str or list of str, optional</span></dt><dd><p>When <cite>a</cite> is an array with fields defined, this argument specifies
which fields to compare first, second, etc.  A single field can
be specified as a string, and not all fields need be specified,
but unspecified fields will still be used, in the order in which
they come up in the dtype, to break ties.</p>
</dd>
</dl>
<dl class="simple">
<dt>index_array<span class="classifier">ndarray, int</span></dt><dd><p>Array of indices that sort <cite>a</cite> along the specified <cite>axis</cite>.
If <cite>a</cite> is one-dimensional, <code class="docutils literal notranslate"><span class="pre">a[index_array]</span></code> yields a sorted <cite>a</cite>.
More generally, <code class="docutils literal notranslate"><span class="pre">np.take_along_axis(a,</span> <span class="pre">index_array,</span> <span class="pre">axis=axis)</span></code>
always yields the sorted <cite>a</cite>, irrespective of dimensionality.</p>
</dd>
</dl>
<p>sort : Describes sorting algorithms used.
lexsort : Indirect stable sort with multiple keys.
ndarray.sort : Inplace sort.
argpartition : Indirect partial sort.
take_along_axis : Apply <code class="docutils literal notranslate"><span class="pre">index_array</span></code> from argsort</p>
<blockquote>
<div><p>to an array as if by calling sort.</p>
</div></blockquote>
<p>See <cite>sort</cite> for notes on the different sorting algorithms.</p>
<p>As of NumPy 1.4.0 <cite>argsort</cite> works with real/complex arrays containing
nan values. The enhanced sort order is documented in <cite>sort</cite>.</p>
<p>One dimensional array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([1, 2, 0])</span>
</pre></div>
</div>
<p>Two-dimensional array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 3],</span>
<span class="go">       [2, 2]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># sorts along first axis (down)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [1, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># same as np.sort(x, axis=0)</span>
<span class="go">array([[0, 2],</span>
<span class="go">       [2, 3]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># sorts along last axis (across)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [0, 1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># same as np.sort(x, axis=1)</span>
<span class="go">array([[0, 3],</span>
<span class="go">       [2, 2]])</span>
</pre></div>
</div>
<p>Indices of the sorted elements of a N-dimensional array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span>
<span class="go">(array([0, 1, 1, 0]), array([0, 0, 1, 1]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>  <span class="c1"># same as np.sort(x, axis=None)</span>
<span class="go">array([0, 2, 2, 3])</span>
</pre></div>
</div>
<p>Sorting with keys:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i4&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i4&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([(1, 0), (0, 1)],</span>
<span class="go">      dtype=[(&#39;x&#39;, &#39;&lt;i4&#39;), (&#39;y&#39;, &#39;&lt;i4&#39;)])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">))</span>
<span class="go">array([1, 0])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">))</span>
<span class="go">array([0, 1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.argwhere">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">argwhere</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.argwhere" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the indices of array elements that are non-zero, grouped by element.</p>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input data.</p>
</dd>
</dl>
<dl class="simple">
<dt>index_array<span class="classifier">(N, a.ndim) ndarray</span></dt><dd><p>Indices of elements that are non-zero. Indices are grouped by element.
This array will have shape <code class="docutils literal notranslate"><span class="pre">(N,</span> <span class="pre">a.ndim)</span></code> where <code class="docutils literal notranslate"><span class="pre">N</span></code> is the number of
non-zero items.</p>
</dd>
</dl>
<p>where, nonzero</p>
<p><code class="docutils literal notranslate"><span class="pre">np.argwhere(a)</span></code> is almost the same as <code class="docutils literal notranslate"><span class="pre">np.transpose(np.nonzero(a))</span></code>,
but produces a result of the correct shape for a 0D array.</p>
<p>The output of <code class="docutils literal notranslate"><span class="pre">argwhere</span></code> is not suitable for indexing arrays.
For this purpose use <code class="docutils literal notranslate"><span class="pre">nonzero(a)</span></code> instead.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">x</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[0, 2],</span>
<span class="go">       [1, 0],</span>
<span class="go">       [1, 1],</span>
<span class="go">       [1, 2]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.around">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">around</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decimals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.around" title="Permalink to this definition">¶</a></dt>
<dd><p>Evenly round to the given number of decimals.</p>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input data.</p>
</dd>
<dt>decimals<span class="classifier">int, optional</span></dt><dd><p>Number of decimal places to round to (default: 0).  If
decimals is negative, it specifies the number of positions to
the left of the decimal point.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Alternative output array in which to place the result. It must have
the same shape as the expected output, but the type of the output
values will be cast if necessary. See <span class="xref std std-ref">ufuncs-output-type</span> for more
details.</p>
</dd>
</dl>
<dl>
<dt>rounded_array<span class="classifier">ndarray</span></dt><dd><p>An array of the same type as <cite>a</cite>, containing the rounded values.
Unless <cite>out</cite> was specified, a new array is created.  A reference to
the result is returned.</p>
<p>The real and imaginary parts of complex numbers are rounded
separately.  The result of rounding a float is a float.</p>
</dd>
</dl>
<p>ndarray.round : equivalent method</p>
<p>ceil, fix, floor, rint, trunc</p>
<p>For values exactly halfway between rounded decimal values, NumPy
rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0,
-0.5 and 0.5 round to 0.0, etc.</p>
<p><code class="docutils literal notranslate"><span class="pre">np.around</span></code> uses a fast but sometimes inexact algorithm to round
floating-point datatypes. For positive <cite>decimals</cite> it is equivalent to
<code class="docutils literal notranslate"><span class="pre">np.true_divide(np.rint(a</span> <span class="pre">*</span> <span class="pre">10**decimals),</span> <span class="pre">10**decimals)</span></code>, which has
error due to the inexact representation of decimal fractions in the IEEE
floating point standard <a href="#id74"><span class="problematic" id="id2">[1]_</span></a> and errors introduced when scaling by powers
of ten. For instance, note the extra “1” in the following:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mf">56294995342131.5</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">56294995342131.51</span>
</pre></div>
</div>
<p>If your goal is to print such values with a fixed number of decimals, it is
preferable to use numpy’s float printing routines to limit the number of
printed decimals:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">format_float_positional</span><span class="p">(</span><span class="mf">56294995342131.5</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">&#39;56294995342131.5&#39;</span>
</pre></div>
</div>
<p>The float printing routines use an accurate but much more computationally
demanding algorithm to compute the number of digits after the decimal
point.</p>
<p>Alternatively, Python’s builtin <cite>round</cite> function uses a more accurate
but slower algorithm for 64-bit floating point values:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="mf">56294995342131.5</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">56294995342131.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mf">16.055</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">round</span><span class="p">(</span><span class="mf">16.055</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># equals 16.0549999999999997</span>
<span class="go">(16.06, 16.05)</span>
</pre></div>
</div>
<dl class="footnote brackets">
<dt class="label" id="id3"><span class="brackets">1</span></dt>
<dd><p>“Lecture Notes on the Status of IEEE 754”, William Kahan,
<a class="reference external" href="https://people.eecs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF">https://people.eecs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF</a></p>
</dd>
<dt class="label" id="id4"><span class="brackets">2</span></dt>
<dd><p>“How Futile are Mindless Assessments of
Roundoff in Floating-Point Computation?”, William Kahan,
<a class="reference external" href="https://people.eecs.berkeley.edu/~wkahan/Mindless.pdf">https://people.eecs.berkeley.edu/~wkahan/Mindless.pdf</a></p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">([</span><span class="mf">0.37</span><span class="p">,</span> <span class="mf">1.64</span><span class="p">])</span>
<span class="go">array([0.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">([</span><span class="mf">0.37</span><span class="p">,</span> <span class="mf">1.64</span><span class="p">],</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([0.4,  1.6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">([</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">])</span> <span class="c1"># rounds to nearest even value</span>
<span class="go">array([0.,  2.,  2.,  4.,  4.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">11</span><span class="p">],</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># ndarray of ints is returned</span>
<span class="go">array([ 1,  2,  3, 11])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">11</span><span class="p">],</span> <span class="n">decimals</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 0,  0,  0, 10])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.array">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">array</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.array" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>array(object, dtype=None, <a href="#id5"><span class="problematic" id="id6">*</span></a>, copy=True, order=’K’, subok=False, ndmin=0,</dt><dd><p>like=None)</p>
</dd>
</dl>
<p>Create an array.</p>
<dl>
<dt>object<span class="classifier">array_like</span></dt><dd><p>An array, any object exposing the array interface, an object whose
__array__ method returns an array, or any (nested) sequence.</p>
</dd>
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>The desired data-type for the array.  If not given, then the type will
be determined as the minimum type required to hold the objects in the
sequence.</p>
</dd>
<dt>copy<span class="classifier">bool, optional</span></dt><dd><p>If true (default), then the object is copied.  Otherwise, a copy will
only be made if __array__ returns a copy, if obj is a nested sequence,
or if a copy is needed to satisfy any of the other requirements
(<cite>dtype</cite>, <cite>order</cite>, etc.).</p>
</dd>
<dt>order<span class="classifier">{‘K’, ‘A’, ‘C’, ‘F’}, optional</span></dt><dd><p>Specify the memory layout of the array. If object is not an array, the
newly created array will be in C order (row major) unless ‘F’ is
specified, in which case it will be in Fortran order (column major).
If object is an array the following holds.</p>
<table class="table">
<colgroup>
<col style="width: 8%" />
<col style="width: 14%" />
<col style="width: 78%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>order</p></th>
<th class="head"><p>no copy</p></th>
<th class="head"><p>copy=True</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>‘K’</p></td>
<td><p>unchanged</p></td>
<td><p>F &amp; C order preserved, otherwise most similar order</p></td>
</tr>
<tr class="row-odd"><td><p>‘A’</p></td>
<td><p>unchanged</p></td>
<td><p>F order if input is F and not C, otherwise C order</p></td>
</tr>
<tr class="row-even"><td><p>‘C’</p></td>
<td><p>C order</p></td>
<td><p>C order</p></td>
</tr>
<tr class="row-odd"><td><p>‘F’</p></td>
<td><p>F order</p></td>
<td><p>F order</p></td>
</tr>
</tbody>
</table>
<p>When <code class="docutils literal notranslate"><span class="pre">copy=False</span></code> and a copy is made for other reasons, the result is
the same as if <code class="docutils literal notranslate"><span class="pre">copy=True</span></code>, with some exceptions for ‘A’, see the
Notes section. The default order is ‘K’.</p>
</dd>
<dt>subok<span class="classifier">bool, optional</span></dt><dd><p>If True, then sub-classes will be passed-through, otherwise
the returned array will be forced to be a base-class array (default).</p>
</dd>
<dt>ndmin<span class="classifier">int, optional</span></dt><dd><p>Specifies the minimum number of dimensions that the resulting
array should have.  Ones will be pre-pended to the shape as
needed to meet this requirement.</p>
</dd>
<dt>like<span class="classifier">array_like</span></dt><dd><p>Reference object to allow the creation of arrays which are not
NumPy arrays. If an array-like passed in as <code class="docutils literal notranslate"><span class="pre">like</span></code> supports
the <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> protocol, the result will be defined
by it. In this case, it ensures the creation of an array object
compatible with that passed in via this argument.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.20.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>An array object satisfying the specified requirements.</p>
</dd>
</dl>
<p>empty_like : Return an empty array with shape and type of input.
ones_like : Return an array of ones with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full_like : Return a new array with shape of input filled with value.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
zeros : Return a new array setting values to zero.
full : Return a new array of given shape filled with value.</p>
<p>When order is ‘A’ and <cite>object</cite> is an array in neither ‘C’ nor ‘F’ order,
and a copy is forced by a change in dtype, then the order of the result is
not necessarily ‘C’ as expected. This is likely a bug.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">array([1, 2, 3])</span>
</pre></div>
</div>
<p>Upcasting:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">])</span>
<span class="go">array([ 1.,  2.,  3.])</span>
</pre></div>
</div>
<p>More than one dimension:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
<p>Minimum dimensions 2:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([[1, 2, 3]])</span>
</pre></div>
</div>
<p>Type provided:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="go">array([ 1.+0.j,  2.+0.j,  3.+0.j])</span>
</pre></div>
</div>
<p>Data-type consisting of more than one element:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)],</span><span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;&lt;i4&#39;</span><span class="p">),(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;&lt;i4&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
<span class="go">array([1, 3])</span>
</pre></div>
</div>
<p>Creating an array from sub-classes:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span><span class="s1">&#39;1 2; 3 4&#39;</span><span class="p">))</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span><span class="s1">&#39;1 2; 3 4&#39;</span><span class="p">),</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">matrix([[1, 2],</span>
<span class="go">        [3, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.array2string">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">array2string</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">a</span></em>, <em class="sig-param"><span class="pre">max_line_width=None</span></em>, <em class="sig-param"><span class="pre">precision=None</span></em>, <em class="sig-param"><span class="pre">suppress_small=None</span></em>, <em class="sig-param"><span class="pre">separator='</span> <span class="pre">'</span></em>, <em class="sig-param"><span class="pre">prefix=''</span></em>, <em class="sig-param"><span class="pre">style=&lt;no</span> <span class="pre">value&gt;</span></em>, <em class="sig-param"><span class="pre">formatter=None</span></em>, <em class="sig-param"><span class="pre">threshold=None</span></em>, <em class="sig-param"><span class="pre">edgeitems=None</span></em>, <em class="sig-param"><span class="pre">sign=None</span></em>, <em class="sig-param"><span class="pre">floatmode=None</span></em>, <em class="sig-param"><span class="pre">suffix=''</span></em>, <em class="sig-param"><span class="pre">*</span></em>, <em class="sig-param"><span class="pre">legacy=None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.array2string" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string representation of an array.</p>
<dl class="simple">
<dt>a<span class="classifier">ndarray</span></dt><dd><p>Input array.</p>
</dd>
<dt>max_line_width<span class="classifier">int, optional</span></dt><dd><p>Inserts newlines if text is longer than <cite>max_line_width</cite>.
Defaults to <code class="docutils literal notranslate"><span class="pre">numpy.get_printoptions()['linewidth']</span></code>.</p>
</dd>
<dt>precision<span class="classifier">int or None, optional</span></dt><dd><p>Floating point precision.
Defaults to <code class="docutils literal notranslate"><span class="pre">numpy.get_printoptions()['precision']</span></code>.</p>
</dd>
<dt>suppress_small<span class="classifier">bool, optional</span></dt><dd><p>Represent numbers “very close” to zero as zero; default is False.
Very close is defined by precision: if the precision is 8, e.g.,
numbers smaller (in absolute value) than 5e-9 are represented as
zero.
Defaults to <code class="docutils literal notranslate"><span class="pre">numpy.get_printoptions()['suppress']</span></code>.</p>
</dd>
<dt>separator<span class="classifier">str, optional</span></dt><dd><p>Inserted between elements.</p>
</dd>
</dl>
<p>prefix : str, optional
suffix : str, optional</p>
<blockquote>
<div><p>The length of the prefix and suffix strings are used to respectively
align and wrap the output. An array is typically printed as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">prefix</span> <span class="o">+</span> <span class="n">array2string</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="n">suffix</span>
</pre></div>
</div>
<p>The output is left-padded by the length of the prefix string, and
wrapping is forced at the column <code class="docutils literal notranslate"><span class="pre">max_line_width</span> <span class="pre">-</span> <span class="pre">len(suffix)</span></code>.
It should be noted that the content of prefix and suffix strings are
not included in the output.</p>
</div></blockquote>
<dl>
<dt>style<span class="classifier">_NoValue, optional</span></dt><dd><p>Has no effect, do not use.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 1.14.0.</span></p>
</div>
</dd>
<dt>formatter<span class="classifier">dict of callables, optional</span></dt><dd><p>If not None, the keys should indicate the type(s) that the respective
formatting function applies to.  Callables should return a string.
Types that are not specified (by their corresponding keys) are handled
by the default formatters.  Individual types for which a formatter
can be set are:</p>
<ul class="simple">
<li><p>‘bool’</p></li>
<li><p>‘int’</p></li>
<li><p>‘timedelta’ : a <cite>numpy.timedelta64</cite></p></li>
<li><p>‘datetime’ : a <cite>numpy.datetime64</cite></p></li>
<li><p>‘float’</p></li>
<li><p>‘longfloat’ : 128-bit floats</p></li>
<li><p>‘complexfloat’</p></li>
<li><p>‘longcomplexfloat’ : composed of two 128-bit floats</p></li>
<li><p>‘void’ : type <cite>numpy.void</cite></p></li>
<li><p>‘numpystr’ : types <cite>numpy.string_</cite> and <cite>numpy.unicode_</cite></p></li>
</ul>
<p>Other keys that can be used to set a group of types at once are:</p>
<ul class="simple">
<li><p>‘all’ : sets all types</p></li>
<li><p>‘int_kind’ : sets ‘int’</p></li>
<li><p>‘float_kind’ : sets ‘float’ and ‘longfloat’</p></li>
<li><p>‘complex_kind’ : sets ‘complexfloat’ and ‘longcomplexfloat’</p></li>
<li><p>‘str_kind’ : sets ‘numpystr’</p></li>
</ul>
</dd>
<dt>threshold<span class="classifier">int, optional</span></dt><dd><p>Total number of array elements which trigger summarization
rather than full repr.
Defaults to <code class="docutils literal notranslate"><span class="pre">numpy.get_printoptions()['threshold']</span></code>.</p>
</dd>
<dt>edgeitems<span class="classifier">int, optional</span></dt><dd><p>Number of array items in summary at beginning and end of
each dimension.
Defaults to <code class="docutils literal notranslate"><span class="pre">numpy.get_printoptions()['edgeitems']</span></code>.</p>
</dd>
<dt>sign<span class="classifier">string, either ‘-‘, ‘+’, or ‘ ‘, optional</span></dt><dd><p>Controls printing of the sign of floating-point types. If ‘+’, always
print the sign of positive values. If ‘ ‘, always prints a space
(whitespace character) in the sign position of positive values.  If
‘-‘, omit the sign character of positive values.
Defaults to <code class="docutils literal notranslate"><span class="pre">numpy.get_printoptions()['sign']</span></code>.</p>
</dd>
<dt>floatmode<span class="classifier">str, optional</span></dt><dd><p>Controls the interpretation of the <cite>precision</cite> option for
floating-point types.
Defaults to <code class="docutils literal notranslate"><span class="pre">numpy.get_printoptions()['floatmode']</span></code>.
Can take the following values:</p>
<ul class="simple">
<li><p>‘fixed’: Always print exactly <cite>precision</cite> fractional digits,
even if this would print more or fewer digits than
necessary to specify the value uniquely.</p></li>
<li><p>‘unique’: Print the minimum number of fractional digits necessary
to represent each value uniquely. Different elements may
have a different number of digits.  The value of the
<cite>precision</cite> option is ignored.</p></li>
<li><p>‘maxprec’: Print at most <cite>precision</cite> fractional digits, but if
an element can be uniquely represented with fewer digits
only print it with that many.</p></li>
<li><p>‘maxprec_equal’: Print at most <cite>precision</cite> fractional digits,
but if every element in the array can be uniquely
represented with an equal number of fewer digits, use that
many digits for all elements.</p></li>
</ul>
</dd>
<dt>legacy<span class="classifier">string or <cite>False</cite>, optional</span></dt><dd><p>If set to the string <cite>‘1.13’</cite> enables 1.13 legacy printing mode. This
approximates numpy 1.13 print output by including a space in the sign
position of floats and different behavior for 0d arrays. If set to
<cite>False</cite>, disables legacy mode. Unrecognized strings will be ignored
with a warning for forward compatibility.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.14.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>array_str<span class="classifier">str</span></dt><dd><p>String representation of the array.</p>
</dd>
</dl>
<dl class="simple">
<dt>TypeError</dt><dd><p>if a callable in <cite>formatter</cite> does not return a string.</p>
</dd>
</dl>
<p>array_str, array_repr, set_printoptions, get_printoptions</p>
<p>If a formatter is specified for a certain type, the <cite>precision</cite> keyword is
ignored for that type.</p>
<p>This is a very flexible function; <cite>array_repr</cite> and <cite>array_str</cite> are using
<cite>array2string</cite> internally so keywords with the same name should work
identically in all three functions.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1e-16</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">suppress_small</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;[0.,1.,2.,3.]&#39;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">3.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">formatter</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;float_kind&#39;</span><span class="p">:</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s2">&quot;</span><span class="si">%.2f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">x</span><span class="p">})</span>
<span class="go">&#39;[0.00 1.00 2.00]&#39;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">formatter</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;int&#39;</span><span class="p">:</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">hex</span><span class="p">(</span><span class="n">x</span><span class="p">)})</span>
<span class="go">&#39;[0x0 0x1 0x2]&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.array_equal">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">array_equal</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">equal_nan</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.array_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>True if two arrays have the same shape and elements, False otherwise.</p>
<dl>
<dt>a1, a2<span class="classifier">array_like</span></dt><dd><p>Input arrays.</p>
</dd>
<dt>equal_nan<span class="classifier">bool</span></dt><dd><p>Whether to compare NaN’s as equal. If the dtype of a1 and a2 is
complex, values will be considered equal if either the real or the
imaginary component of a given value is <code class="docutils literal notranslate"><span class="pre">nan</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.19.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>b<span class="classifier">bool</span></dt><dd><p>Returns True if the arrays are equal.</p>
</dd>
</dl>
<dl class="simple">
<dt>allclose: Returns True if two arrays are element-wise equal within a</dt><dd><p>tolerance.</p>
</dd>
<dt>array_equiv: Returns True if input arrays are shape consistent and all</dt><dd><p>elements equal.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">equal_nan</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">equal_nan</span></code> is True, complex values with nan components are
considered equal if either the real <em>or</em> the imaginary components are nan.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">equal_nan</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.array_equiv">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">array_equiv</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.array_equiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if input arrays are shape consistent and all elements equal.</p>
<p>Shape consistent means they are either the same shape, or one input array
can be broadcasted to create the same shape as the other one.</p>
<dl class="simple">
<dt>a1, a2<span class="classifier">array_like</span></dt><dd><p>Input arrays.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">bool</span></dt><dd><p>True if equivalent, False otherwise.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_equiv</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_equiv</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Showing the shape equivalence:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_equiv</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_equiv</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_equiv</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.array_repr">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">array_repr</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_line_width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suppress_small</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.array_repr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the string representation of an array.</p>
<dl class="simple">
<dt>arr<span class="classifier">ndarray</span></dt><dd><p>Input array.</p>
</dd>
<dt>max_line_width<span class="classifier">int, optional</span></dt><dd><p>Inserts newlines if text is longer than <cite>max_line_width</cite>.
Defaults to <code class="docutils literal notranslate"><span class="pre">numpy.get_printoptions()['linewidth']</span></code>.</p>
</dd>
<dt>precision<span class="classifier">int, optional</span></dt><dd><p>Floating point precision.
Defaults to <code class="docutils literal notranslate"><span class="pre">numpy.get_printoptions()['precision']</span></code>.</p>
</dd>
<dt>suppress_small<span class="classifier">bool, optional</span></dt><dd><p>Represent numbers “very close” to zero as zero; default is False.
Very close is defined by precision: if the precision is 8, e.g.,
numbers smaller (in absolute value) than 5e-9 are represented as
zero.
Defaults to <code class="docutils literal notranslate"><span class="pre">numpy.get_printoptions()['suppress']</span></code>.</p>
</dd>
</dl>
<dl class="simple">
<dt>string<span class="classifier">str</span></dt><dd><p>The string representation of an array.</p>
</dd>
</dl>
<p>array_str, array2string, set_printoptions</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_repr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">&#39;array([1, 2])&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_repr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">]))</span>
<span class="go">&#39;MaskedArray([0.])&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_repr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>
<span class="go">&#39;array([], dtype=int32)&#39;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1e-6</span><span class="p">,</span> <span class="mf">4e-7</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_repr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">suppress_small</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;array([0.000001,  0.      ,  2.      ,  3.      ])&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.array_split">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">array_split</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ary</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices_or_sections</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.array_split" title="Permalink to this definition">¶</a></dt>
<dd><p>Split an array into multiple sub-arrays.</p>
<p>Please refer to the <code class="docutils literal notranslate"><span class="pre">split</span></code> documentation.  The only difference
between these functions is that <code class="docutils literal notranslate"><span class="pre">array_split</span></code> allows
<cite>indices_or_sections</cite> to be an integer that does <em>not</em> equally
divide the axis. For an array of length l that should be split
into n sections, it returns l % n sub-arrays of size l//n + 1
and the rest of size l//n.</p>
<p>split : Split array into multiple sub-arrays of equal size.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">8.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[array([0.,  1.,  2.]), array([3.,  4.,  5.]), array([6.,  7.])]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">[array([0, 1, 2]), array([3, 4]), array([5, 6]), array([7, 8])]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.array_str">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">array_str</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_line_width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suppress_small</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.array_str" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string representation of the data in an array.</p>
<p>The data in the array is returned as a single string.  This function is
similar to <cite>array_repr</cite>, the difference being that <cite>array_repr</cite> also
returns information on the kind of array and its data type.</p>
<dl class="simple">
<dt>a<span class="classifier">ndarray</span></dt><dd><p>Input array.</p>
</dd>
<dt>max_line_width<span class="classifier">int, optional</span></dt><dd><p>Inserts newlines if text is longer than <cite>max_line_width</cite>.
Defaults to <code class="docutils literal notranslate"><span class="pre">numpy.get_printoptions()['linewidth']</span></code>.</p>
</dd>
<dt>precision<span class="classifier">int, optional</span></dt><dd><p>Floating point precision.
Defaults to <code class="docutils literal notranslate"><span class="pre">numpy.get_printoptions()['precision']</span></code>.</p>
</dd>
<dt>suppress_small<span class="classifier">bool, optional</span></dt><dd><p>Represent numbers “very close” to zero as zero; default is False.
Very close is defined by precision: if the precision is 8, e.g.,
numbers smaller (in absolute value) than 5e-9 are represented as
zero.
Defaults to <code class="docutils literal notranslate"><span class="pre">numpy.get_printoptions()['suppress']</span></code>.</p>
</dd>
</dl>
<p>array2string, array_repr, set_printoptions</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">&#39;[0 1 2]&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.asanyarray">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">asanyarray</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">like</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.asanyarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input to an ndarray, but pass ndarray subclasses through.</p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input data, in any form that can be converted to an array.  This
includes scalars, lists, lists of tuples, tuples, tuples of tuples,
tuples of lists, and ndarrays.</p>
</dd>
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>By default, the data-type is inferred from the input data.</p>
</dd>
<dt>order<span class="classifier">{‘C’, ‘F’, ‘A’, ‘K’}, optional</span></dt><dd><p>Memory layout.  ‘A’ and ‘K’ depend on the order of input array a.
‘C’ row-major (C-style),
‘F’ column-major (Fortran-style) memory representation.
‘A’ (any) means ‘F’ if <cite>a</cite> is Fortran contiguous, ‘C’ otherwise
‘K’ (keep) preserve input order
Defaults to ‘C’.</p>
</dd>
<dt>like<span class="classifier">array_like</span></dt><dd><p>Reference object to allow the creation of arrays which are not
NumPy arrays. If an array-like passed in as <code class="docutils literal notranslate"><span class="pre">like</span></code> supports
the <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> protocol, the result will be defined
by it. In this case, it ensures the creation of an array object
compatible with that passed in via this argument.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.20.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray or an ndarray subclass</span></dt><dd><p>Array interpretation of <cite>a</cite>.  If <cite>a</cite> is an ndarray or a subclass
of ndarray, it is returned as-is and no copy is performed.</p>
</dd>
</dl>
<p>asarray : Similar function which always returns ndarrays.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major</p>
<blockquote>
<div><p>memory order.</p>
</div></blockquote>
<dl class="simple">
<dt>asarray_chkfinite<span class="classifier">Similar function which checks input for NaNs and</span></dt><dd><p>Infs.</p>
</dd>
</dl>
<p>fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid</p>
<blockquote>
<div><p>positions.</p>
</div></blockquote>
<p>Convert a list into an array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([1, 2])</span>
</pre></div>
</div>
<p>Instances of <cite>ndarray</cite> subclasses are passed through as-is:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;f4,i4&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.asarray">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">asarray</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">like</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.asarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input to an array.</p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input data, in any form that can be converted to an array.  This
includes lists, lists of tuples, tuples, tuples of tuples, tuples
of lists and ndarrays.</p>
</dd>
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>By default, the data-type is inferred from the input data.</p>
</dd>
<dt>order<span class="classifier">{‘C’, ‘F’, ‘A’, ‘K’}, optional</span></dt><dd><p>Memory layout.  ‘A’ and ‘K’ depend on the order of input array a.
‘C’ row-major (C-style),
‘F’ column-major (Fortran-style) memory representation.
‘A’ (any) means ‘F’ if <cite>a</cite> is Fortran contiguous, ‘C’ otherwise
‘K’ (keep) preserve input order
Defaults to ‘C’.</p>
</dd>
<dt>like<span class="classifier">array_like</span></dt><dd><p>Reference object to allow the creation of arrays which are not
NumPy arrays. If an array-like passed in as <code class="docutils literal notranslate"><span class="pre">like</span></code> supports
the <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> protocol, the result will be defined
by it. In this case, it ensures the creation of an array object
compatible with that passed in via this argument.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.20.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>Array interpretation of <cite>a</cite>.  No copy is performed if the input
is already an ndarray with matching dtype and order.  If <cite>a</cite> is a
subclass of ndarray, a base class ndarray is returned.</p>
</dd>
</dl>
<p>asanyarray : Similar function which passes through subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major</p>
<blockquote>
<div><p>memory order.</p>
</div></blockquote>
<p>asarray_chkfinite : Similar function which checks input for NaNs and Infs.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid</p>
<blockquote>
<div><p>positions.</p>
</div></blockquote>
<p>Convert a list into an array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([1, 2])</span>
</pre></div>
</div>
<p>Existing arrays are not copied:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If <cite>dtype</cite> is set, array is copied only if dtype does not match:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Contrary to <cite>asanyarray</cite>, ndarray subclasses are not passed through:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">issubclass</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;f4,i4&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.asarray_chkfinite">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">asarray_chkfinite</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.asarray_chkfinite" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input to an array, checking for NaNs or Infs.</p>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input data, in any form that can be converted to an array.  This
includes lists, lists of tuples, tuples, tuples of tuples, tuples
of lists and ndarrays.  Success requires no NaNs or Infs.</p>
</dd>
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>By default, the data-type is inferred from the input data.</p>
</dd>
<dt>order<span class="classifier">{‘C’, ‘F’, ‘A’, ‘K’}, optional</span></dt><dd><p>Memory layout.  ‘A’ and ‘K’ depend on the order of input array a.
‘C’ row-major (C-style),
‘F’ column-major (Fortran-style) memory representation.
‘A’ (any) means ‘F’ if <cite>a</cite> is Fortran contiguous, ‘C’ otherwise
‘K’ (keep) preserve input order
Defaults to ‘C’.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>Array interpretation of <cite>a</cite>.  No copy is performed if the input
is already an ndarray.  If <cite>a</cite> is a subclass of ndarray, a base
class ndarray is returned.</p>
</dd>
</dl>
<dl class="simple">
<dt>ValueError</dt><dd><p>Raises ValueError if <cite>a</cite> contains NaN (Not a Number) or Inf (Infinity).</p>
</dd>
</dl>
<p>asarray : Create and array.
asanyarray : Similar function which passes through subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major</p>
<blockquote>
<div><p>memory order.</p>
</div></blockquote>
<p>fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid</p>
<blockquote>
<div><p>positions.</p>
</div></blockquote>
<p>Convert a list into an array.  If all elements are finite
<code class="docutils literal notranslate"><span class="pre">asarray_chkfinite</span></code> is identical to <code class="docutils literal notranslate"><span class="pre">asarray</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">asarray_chkfinite</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="go">array([1., 2.])</span>
</pre></div>
</div>
<p>Raises ValueError if array_like contains Nans or Infs.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">np</span><span class="o">.</span><span class="n">asarray_chkfinite</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">... </span><span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ValueError&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">ValueError</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.ascontiguousarray">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">ascontiguousarray</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">like</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ascontiguousarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a contiguous array (ndim &gt;= 1) in memory (C order).</p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt>dtype<span class="classifier">str or dtype object, optional</span></dt><dd><p>Data-type of returned array.</p>
</dd>
<dt>like<span class="classifier">array_like</span></dt><dd><p>Reference object to allow the creation of arrays which are not
NumPy arrays. If an array-like passed in as <code class="docutils literal notranslate"><span class="pre">like</span></code> supports
the <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> protocol, the result will be defined
by it. In this case, it ensures the creation of an array object
compatible with that passed in via this argument.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.20.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>Contiguous array of same shape and content as <cite>a</cite>, with type <cite>dtype</cite>
if specified.</p>
</dd>
</dl>
<dl class="simple">
<dt>asfortranarray<span class="classifier">Convert input to an ndarray with column-major</span></dt><dd><p>memory order.</p>
</dd>
</dl>
<p>require : Return an ndarray that satisfies requirements.
ndarray.flags : Information about the memory layout of the array.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="go">array([[0., 1., 2.],</span>
<span class="go">       [3., 4., 5.]], dtype=float32)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s1">&#39;C_CONTIGUOUS&#39;</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Note: This function returns an array with at least one-dimension (1-d)
so it will not preserve 0-d arrays.</p>
</dd></dl>

<dl class="py function">
<dt id="numpy.asfarray">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">asfarray</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">a</span></em>, <em class="sig-param"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.float64'&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.asfarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array converted to a float type.</p>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>The input array.</p>
</dd>
<dt>dtype<span class="classifier">str or dtype object, optional</span></dt><dd><p>Float type code to coerce input array <cite>a</cite>.  If <cite>dtype</cite> is one of the
‘int’ dtypes, it is replaced with float64.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>The input <cite>a</cite> as a float ndarray.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">asfarray</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">array([2.,  3.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">asfarray</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
<span class="go">array([2.,  3.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">asfarray</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int8&#39;</span><span class="p">)</span>
<span class="go">array([2.,  3.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.asfortranarray">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">asfortranarray</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">like</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.asfortranarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array (ndim &gt;= 1) laid out in Fortran order in memory.</p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt>dtype<span class="classifier">str or dtype object, optional</span></dt><dd><p>By default, the data-type is inferred from the input data.</p>
</dd>
<dt>like<span class="classifier">array_like</span></dt><dd><p>Reference object to allow the creation of arrays which are not
NumPy arrays. If an array-like passed in as <code class="docutils literal notranslate"><span class="pre">like</span></code> supports
the <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> protocol, the result will be defined
by it. In this case, it ensures the creation of an array object
compatible with that passed in via this argument.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.20.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>The input <cite>a</cite> in Fortran, or column-major, order.</p>
</dd>
</dl>
<p>ascontiguousarray : Convert input to a contiguous (C order) array.
asanyarray : Convert input to an ndarray with either row or</p>
<blockquote>
<div><p>column-major memory order.</p>
</div></blockquote>
<p>require : Return an ndarray that satisfies requirements.
ndarray.flags : Information about the memory layout of the array.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s1">&#39;F_CONTIGUOUS&#39;</span><span class="p">]</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s1">&#39;F_CONTIGUOUS&#39;</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Note: This function returns an array with at least one-dimension (1-d)
so it will not preserve 0-d arrays.</p>
</dd></dl>

<dl class="py function">
<dt id="numpy.asmatrix">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">asmatrix</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.asmatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret the input as a matrix.</p>
<p>Unlike <cite>matrix</cite>, <cite>asmatrix</cite> does not make a copy if the input is already
a matrix or an ndarray.  Equivalent to <code class="docutils literal notranslate"><span class="pre">matrix(data,</span> <span class="pre">copy=False)</span></code>.</p>
<dl class="simple">
<dt>data<span class="classifier">array_like</span></dt><dd><p>Input data.</p>
</dd>
<dt>dtype<span class="classifier">data-type</span></dt><dd><p>Data-type of the output matrix.</p>
</dd>
</dl>
<dl class="simple">
<dt>mat<span class="classifier">matrix</span></dt><dd><p><cite>data</cite> interpreted as a matrix.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asmatrix</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">matrix([[5, 2],</span>
<span class="go">        [3, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.asscalar">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">asscalar</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.asscalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an array of size 1 to its scalar equivalent.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 1.16: </span>Deprecated, use <cite>numpy.ndarray.item()</cite> instead.</p>
</div>
<dl class="simple">
<dt>a<span class="classifier">ndarray</span></dt><dd><p>Input array of size 1.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">scalar</span></dt><dd><p>Scalar representation of <cite>a</cite>. The output data type is the same type
returned by the input’s <cite>item</cite> method.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">asscalar</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">24</span><span class="p">]))</span>
<span class="go">24</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.atleast_1d">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">atleast_1d</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">arys</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.atleast_1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert inputs to arrays with at least one dimension.</p>
<p>Scalar inputs are converted to 1-dimensional arrays, whilst
higher-dimensional inputs are preserved.</p>
<dl class="simple">
<dt>arys1, arys2, …<span class="classifier">array_like</span></dt><dd><p>One or more input arrays.</p>
</dd>
</dl>
<dl class="simple">
<dt>ret<span class="classifier">ndarray</span></dt><dd><p>An array, or list of arrays, each with <code class="docutils literal notranslate"><span class="pre">a.ndim</span> <span class="pre">&gt;=</span> <span class="pre">1</span></code>.
Copies are made only if necessary.</p>
</dd>
</dl>
<p>atleast_2d, atleast_3d</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
<span class="go">array([1.])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">9.0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([[0., 1., 2.],</span>
<span class="go">       [3., 4., 5.],</span>
<span class="go">       [6., 7., 8.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">x</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="go">[array([1]), array([3, 4])]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.atleast_2d">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">atleast_2d</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">arys</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.atleast_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>View inputs as arrays with at least two dimensions.</p>
<dl class="simple">
<dt>arys1, arys2, …<span class="classifier">array_like</span></dt><dd><p>One or more array-like sequences.  Non-array inputs are converted
to arrays.  Arrays that already have two or more dimensions are
preserved.</p>
</dd>
</dl>
<dl class="simple">
<dt>res, res2, …<span class="classifier">ndarray</span></dt><dd><p>An array, or list of arrays, each with <code class="docutils literal notranslate"><span class="pre">a.ndim</span> <span class="pre">&gt;=</span> <span class="pre">2</span></code>.
Copies are avoided where possible, and views with two or more
dimensions are returned.</p>
</dd>
</dl>
<p>atleast_1d, atleast_3d</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span>
<span class="go">array([[3.]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([[0., 1., 2.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="n">x</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="go">[array([[1]]), array([[1, 2]]), array([[1, 2]])]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.atleast_3d">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">atleast_3d</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">arys</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.atleast_3d" title="Permalink to this definition">¶</a></dt>
<dd><p>View inputs as arrays with at least three dimensions.</p>
<dl class="simple">
<dt>arys1, arys2, …<span class="classifier">array_like</span></dt><dd><p>One or more array-like sequences.  Non-array inputs are converted to
arrays.  Arrays that already have three or more dimensions are
preserved.</p>
</dd>
</dl>
<dl class="simple">
<dt>res1, res2, …<span class="classifier">ndarray</span></dt><dd><p>An array, or list of arrays, each with <code class="docutils literal notranslate"><span class="pre">a.ndim</span> <span class="pre">&gt;=</span> <span class="pre">3</span></code>.  Copies are
avoided where possible, and views with three or more dimensions are
returned.  For example, a 1-D array of shape <code class="docutils literal notranslate"><span class="pre">(N,)</span></code> becomes a view
of shape <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">N,</span> <span class="pre">1)</span></code>, and a 2-D array of shape <code class="docutils literal notranslate"><span class="pre">(M,</span> <span class="pre">N)</span></code> becomes a
view of shape <code class="docutils literal notranslate"><span class="pre">(M,</span> <span class="pre">N,</span> <span class="pre">1)</span></code>.</p>
</dd>
</dl>
<p>atleast_1d, atleast_2d</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_3d</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span>
<span class="go">array([[[3.]]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_3d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 3, 1)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">12.0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_3d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(4, 3, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_3d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="n">x</span><span class="o">.</span><span class="n">base</span>  <span class="c1"># x is a reshape, so not base itself</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_3d</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span> <span class="p">[[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]]):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> 
<span class="gp">...</span>
<span class="go">[[[1]</span>
<span class="go">  [2]]] (1, 2, 1)</span>
<span class="go">[[[1]</span>
<span class="go">  [2]]] (1, 2, 1)</span>
<span class="go">[[[1 2]]] (1, 1, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.average">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">average</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">returned</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.average" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the weighted average along the specified axis.</p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Array containing data to be averaged. If <cite>a</cite> is not an array, a
conversion is attempted.</p>
</dd>
<dt>axis<span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Axis or axes along which to average <cite>a</cite>.  The default,
axis=None, will average over all of the elements of the input array.
If axis is negative it counts from the last to the first axis.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<p>If axis is a tuple of ints, averaging is performed on all of the axes
specified in the tuple instead of a single axis or all the axes as
before.</p>
</dd>
<dt>weights<span class="classifier">array_like, optional</span></dt><dd><p>An array of weights associated with the values in <cite>a</cite>. Each value in
<cite>a</cite> contributes to the average according to its associated weight.
The weights array can either be 1-D (in which case its length must be
the size of <cite>a</cite> along the given axis) or of the same shape as <cite>a</cite>.
If <cite>weights=None</cite>, then all data in <cite>a</cite> are assumed to have a
weight equal to one.  The 1-D calculation is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">avg</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">weights</span><span class="p">)</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
</pre></div>
</div>
<p>The only constraint on <cite>weights</cite> is that <cite>sum(weights)</cite> must not be 0.</p>
</dd>
<dt>returned<span class="classifier">bool, optional</span></dt><dd><p>Default is <cite>False</cite>. If <cite>True</cite>, the tuple (<cite>average</cite>, <cite>sum_of_weights</cite>)
is returned, otherwise only the average is returned.
If <cite>weights=None</cite>, <cite>sum_of_weights</cite> is equivalent to the number of
elements over which the average is taken.</p>
</dd>
</dl>
<dl class="simple">
<dt>retval, [sum_of_weights]<span class="classifier">array_type or double</span></dt><dd><p>Return the average along the specified axis. When <cite>returned</cite> is <cite>True</cite>,
return a tuple with the average as the first element and the sum
of the weights as the second element. <cite>sum_of_weights</cite> is of the
same type as <cite>retval</cite>. The result dtype follows a genereal pattern.
If <cite>weights</cite> is None, the result dtype will be that of <cite>a</cite> , or <code class="docutils literal notranslate"><span class="pre">float64</span></code>
if <cite>a</cite> is integral. Otherwise, if <cite>weights</cite> is not None and <cite>a</cite> is non-
integral, the result type will be the type of lowest precision capable of
representing values of both <cite>a</cite> and <cite>weights</cite>. If <cite>a</cite> happens to be
integral, the previous rules still applies but the result dtype will
at least be <code class="docutils literal notranslate"><span class="pre">float64</span></code>.</p>
</dd>
</dl>
<dl class="simple">
<dt>ZeroDivisionError</dt><dd><p>When all weights along axis are zero. See <cite>numpy.ma.average</cite> for a
version robust to this type of error.</p>
</dd>
<dt>TypeError</dt><dd><p>When the length of 1D <cite>weights</cite> is not the same as the shape of <cite>a</cite>
along axis.</p>
</dd>
</dl>
<p>mean</p>
<dl class="simple">
<dt>ma.average<span class="classifier">average for masked arrays – useful if your data contains</span></dt><dd><p>“missing” values</p>
</dd>
<dt>numpy.result_type<span class="classifier">Returns the type that results from applying the</span></dt><dd><p>numpy type promotion rules to the arguments.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">array([1, 2, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">2.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">),</span> <span class="n">weights</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="go">4.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3],</span>
<span class="go">       [4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="mf">1.</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mf">3.</span><span class="o">/</span><span class="mi">4</span><span class="p">])</span>
<span class="go">array([0.75, 2.75, 4.75])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="mf">1.</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mf">3.</span><span class="o">/</span><span class="mi">4</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">TypeError</span>: <span class="n">Axis must be specified when shapes of a and weights differ.</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float128</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">avg</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="go">complex256</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.bartlett">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">bartlett</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.bartlett" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Bartlett window.</p>
<p>The Bartlett window is very similar to a triangular window, except
that the end points are at zero.  It is often used in signal
processing for tapering a signal, without generating too much
ripple in the frequency domain.</p>
<dl class="simple">
<dt>M<span class="classifier">int</span></dt><dd><p>Number of points in the output window. If zero or less, an
empty array is returned.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">array</span></dt><dd><p>The triangular window, with the maximum value normalized to one
(the value one appears only if the number of samples is odd), with
the first and last samples equal to zero.</p>
</dd>
</dl>
<p>blackman, hamming, hanning, kaiser</p>
<p>The Bartlett window is defined as</p>
<div class="math notranslate nohighlight">
\[w(n) = \frac{2}{M-1} \left(
\frac{M-1}{2} - \left|n - \frac{M-1}{2}\right|
\right)\]</div>
<p>Most references to the Bartlett window come from the signal
processing literature, where it is used as one of many windowing
functions for smoothing values.  Note that convolution with this
window produces linear interpolation.  It is also known as an
apodization (which means”removing the foot”, i.e. smoothing
discontinuities at the beginning and end of the sampled signal) or
tapering function. The fourier transform of the Bartlett is the product
of two sinc functions.
Note the excellent discussion in Kanasewich.</p>
<dl class="footnote brackets">
<dt class="label" id="id7"><span class="brackets">1</span></dt>
<dd><p>M.S. Bartlett, “Periodogram Analysis and Continuous Spectra”,
Biometrika 37, 1-16, 1950.</p>
</dd>
<dt class="label" id="id8"><span class="brackets">2</span></dt>
<dd><p>E.R. Kanasewich, “Time Sequence Analysis in Geophysics”,
The University of Alberta Press, 1975, pp. 109-110.</p>
</dd>
<dt class="label" id="id9"><span class="brackets">3</span></dt>
<dd><p>A.V. Oppenheim and R.W. Schafer, “Discrete-Time Signal
Processing”, Prentice-Hall, 1999, pp. 468-471.</p>
</dd>
<dt class="label" id="id10"><span class="brackets">4</span></dt>
<dd><p>Wikipedia, “Window function”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Window_function">https://en.wikipedia.org/wiki/Window_function</a></p>
</dd>
<dt class="label" id="id11"><span class="brackets">5</span></dt>
<dd><p>W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
“Numerical Recipes”, Cambridge University Press, 1986, page 429.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bartlett</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="go">array([ 0.        ,  0.18181818,  0.36363636,  0.54545455,  0.72727273, # may vary</span>
<span class="go">        0.90909091,  0.90909091,  0.72727273,  0.54545455,  0.36363636,</span>
<span class="go">        0.18181818,  0.        ])</span>
</pre></div>
</div>
<p>Plot the window and its frequency response (requires SciPy and matplotlib):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy.fft</span> <span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">fftshift</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bartlett</span><span class="p">(</span><span class="mi">51</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Bartlett window&quot;</span><span class="p">)</span>
<span class="go">Text(0.5, 1.0, &#39;Bartlett window&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Amplitude&quot;</span><span class="p">)</span>
<span class="go">Text(0, 0.5, &#39;Amplitude&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Sample&quot;</span><span class="p">)</span>
<span class="go">Text(0.5, 0, &#39;Sample&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="go">&lt;Figure size 640x480 with 0 Axes&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span> <span class="o">/</span> <span class="mf">25.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fftshift</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">response</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">mag</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">response</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Frequency response of Bartlett window&quot;</span><span class="p">)</span>
<span class="go">Text(0.5, 1.0, &#39;Frequency response of Bartlett window&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Magnitude [dB]&quot;</span><span class="p">)</span>
<span class="go">Text(0, 0.5, &#39;Magnitude [dB]&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Normalized frequency [cycles per sample]&quot;</span><span class="p">)</span>
<span class="go">Text(0.5, 0, &#39;Normalized frequency [cycles per sample]&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.base_repr">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">base_repr</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">padding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.base_repr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string representation of a number in the given base system.</p>
<dl class="simple">
<dt>number<span class="classifier">int</span></dt><dd><p>The value to convert. Positive and negative values are handled.</p>
</dd>
<dt>base<span class="classifier">int, optional</span></dt><dd><p>Convert <cite>number</cite> to the <cite>base</cite> number system. The valid range is 2-36,
the default value is 2.</p>
</dd>
<dt>padding<span class="classifier">int, optional</span></dt><dd><p>Number of zeros padded on the left. Default is 0 (no padding).</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">str</span></dt><dd><p>String representation of <cite>number</cite> in <cite>base</cite> system.</p>
</dd>
</dl>
<p>binary_repr : Faster version of <cite>base_repr</cite> for base 2.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">base_repr</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">&#39;101&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">base_repr</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">&#39;11&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">base_repr</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">&#39;00012&#39;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">base_repr</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="go">&#39;A&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">base_repr</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="go">&#39;20&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.binary_repr">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">binary_repr</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.binary_repr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the binary representation of the input number as a string.</p>
<p>For negative numbers, if width is not given, a minus sign is added to the
front. If width is given, the two’s complement of the number is
returned, with respect to that width.</p>
<p>In a two’s-complement system negative numbers are represented by the two’s
complement of the absolute value. This is the most common method of
representing signed integers on computers <a href="#id75"><span class="problematic" id="id12">[1]_</span></a>. A N-bit two’s-complement
system can represent every integer in the range
<span class="math notranslate nohighlight">\(-2^{N-1}\)</span> to <span class="math notranslate nohighlight">\(+2^{N-1}-1\)</span>.</p>
<dl>
<dt>num<span class="classifier">int</span></dt><dd><p>Only an integer decimal number can be used.</p>
</dd>
<dt>width<span class="classifier">int, optional</span></dt><dd><p>The length of the returned string if <cite>num</cite> is positive, or the length
of the two’s complement if <cite>num</cite> is negative, provided that <cite>width</cite> is
at least a sufficient number of bits for <cite>num</cite> to be represented in the
designated form.</p>
<p>If the <cite>width</cite> value is insufficient, it will be ignored, and <cite>num</cite> will
be returned in binary (<cite>num</cite> &gt; 0) or two’s complement (<cite>num</cite> &lt; 0) form
with its width equal to the minimum number of bits needed to represent
the number in the designated form. This behavior is deprecated and will
later raise an error.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 1.12.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>bin<span class="classifier">str</span></dt><dd><p>Binary representation of <cite>num</cite> or two’s complement of <cite>num</cite>.</p>
</dd>
</dl>
<dl class="simple">
<dt>base_repr: Return a string representation of a number in the given base</dt><dd><p>system.</p>
</dd>
</dl>
<p>bin: Python’s built-in binary representation generator of an integer.</p>
<p><cite>binary_repr</cite> is equivalent to using <cite>base_repr</cite> with base 2, but about 25x
faster.</p>
<dl class="footnote brackets">
<dt class="label" id="id13"><span class="brackets">1</span></dt>
<dd><p>Wikipedia, “Two’s complement”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Two's_complement">https://en.wikipedia.org/wiki/Two’s_complement</a></p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">binary_repr</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">&#39;11&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">binary_repr</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="go">&#39;-11&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">binary_repr</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">&#39;0011&#39;</span>
</pre></div>
</div>
<p>The two’s complement is returned when the input number is negative and
width is specified:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">binary_repr</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">&#39;101&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">binary_repr</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">&#39;11101&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.bincount">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">bincount</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minlength</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.bincount" title="Permalink to this definition">¶</a></dt>
<dd><p>Count number of occurrences of each value in array of non-negative ints.</p>
<p>The number of bins (of size 1) is one larger than the largest value in
<cite>x</cite>. If <cite>minlength</cite> is specified, there will be at least this number
of bins in the output array (though it will be longer if necessary,
depending on the contents of <cite>x</cite>).
Each bin gives the number of occurrences of its index value in <cite>x</cite>.
If <cite>weights</cite> is specified the input array is weighted by it, i.e. if a
value <code class="docutils literal notranslate"><span class="pre">n</span></code> is found at position <code class="docutils literal notranslate"><span class="pre">i</span></code>, <code class="docutils literal notranslate"><span class="pre">out[n]</span> <span class="pre">+=</span> <span class="pre">weight[i]</span></code> instead
of <code class="docutils literal notranslate"><span class="pre">out[n]</span> <span class="pre">+=</span> <span class="pre">1</span></code>.</p>
<dl>
<dt>x<span class="classifier">array_like, 1 dimension, nonnegative ints</span></dt><dd><p>Input array.</p>
</dd>
<dt>weights<span class="classifier">array_like, optional</span></dt><dd><p>Weights, array of the same shape as <cite>x</cite>.</p>
</dd>
<dt>minlength<span class="classifier">int, optional</span></dt><dd><p>A minimum number of bins for the output array.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.6.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray of ints</span></dt><dd><p>The result of binning the input array.
The length of <cite>out</cite> is equal to <code class="docutils literal notranslate"><span class="pre">np.amax(x)+1</span></code>.</p>
</dd>
</dl>
<dl class="simple">
<dt>ValueError</dt><dd><p>If the input is not 1-dimensional, or contains elements with negative
values, or if <cite>minlength</cite> is negative.</p>
</dd>
<dt>TypeError</dt><dd><p>If the type of the input is float or complex.</p>
</dd>
</dl>
<p>histogram, digitize, unique</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">array([1, 1, 1, 1, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">]))</span>
<span class="go">array([1, 3, 1, 1, 0, 0, 0, 1])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">23</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The input array needs to be of integer dtype, otherwise a
TypeError is raised:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">Cannot cast array data from dtype(&#39;float64&#39;) to dtype(&#39;int64&#39;)</span>
<span class="go">according to the rule &#39;safe&#39;</span>
</pre></div>
</div>
<p>A possible use of <code class="docutils literal notranslate"><span class="pre">bincount</span></code> is to perform sums over
variable-size chunks of an array, using the <code class="docutils literal notranslate"><span class="pre">weights</span></code> keyword.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.6</span><span class="p">])</span> <span class="c1"># weights</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">x</span><span class="p">,</span>  <span class="n">weights</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
<span class="go">array([ 0.3,  0.7,  1.1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.blackman">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">blackman</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.blackman" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Blackman window.</p>
<p>The Blackman window is a taper formed by using the first three
terms of a summation of cosines. It was designed to have close to the
minimal leakage possible.  It is close to optimal, only slightly worse
than a Kaiser window.</p>
<dl class="simple">
<dt>M<span class="classifier">int</span></dt><dd><p>Number of points in the output window. If zero or less, an empty
array is returned.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>The window, with the maximum value normalized to one (the value one
appears only if the number of samples is odd).</p>
</dd>
</dl>
<p>bartlett, hamming, hanning, kaiser</p>
<p>The Blackman window is defined as</p>
<div class="math notranslate nohighlight">
\[w(n) = 0.42 - 0.5 \cos(2\pi n/M) + 0.08 \cos(4\pi n/M)\]</div>
<p>Most references to the Blackman window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
“removing the foot”, i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function. It is known as a
“near optimal” tapering function, almost as good (by some measures)
as the kaiser window.</p>
<p>Blackman, R.B. and Tukey, J.W., (1958) The measurement of power spectra,
Dover Publications, New York.</p>
<p>Oppenheim, A.V., and R.W. Schafer. Discrete-Time Signal Processing.
Upper Saddle River, NJ: Prentice-Hall, 1999, pp. 468-471.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">blackman</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="go">array([-1.38777878e-17,   3.26064346e-02,   1.59903635e-01, # may vary</span>
<span class="go">        4.14397981e-01,   7.36045180e-01,   9.67046769e-01,</span>
<span class="go">        9.67046769e-01,   7.36045180e-01,   4.14397981e-01,</span>
<span class="go">        1.59903635e-01,   3.26064346e-02,  -1.38777878e-17])</span>
</pre></div>
</div>
<p>Plot the window and the frequency response:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy.fft</span> <span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">fftshift</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">blackman</span><span class="p">(</span><span class="mi">51</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Blackman window&quot;</span><span class="p">)</span>
<span class="go">Text(0.5, 1.0, &#39;Blackman window&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Amplitude&quot;</span><span class="p">)</span>
<span class="go">Text(0, 0.5, &#39;Amplitude&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Sample&quot;</span><span class="p">)</span>
<span class="go">Text(0.5, 0, &#39;Sample&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="go">&lt;Figure size 640x480 with 0 Axes&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span> <span class="o">/</span> <span class="mf">25.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fftshift</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">response</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">mag</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">response</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Frequency response of Blackman window&quot;</span><span class="p">)</span>
<span class="go">Text(0.5, 1.0, &#39;Frequency response of Blackman window&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Magnitude [dB]&quot;</span><span class="p">)</span>
<span class="go">Text(0, 0.5, &#39;Magnitude [dB]&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Normalized frequency [cycles per sample]&quot;</span><span class="p">)</span>
<span class="go">Text(0.5, 0, &#39;Normalized frequency [cycles per sample]&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.block">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">block</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arrays</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.block" title="Permalink to this definition">¶</a></dt>
<dd><p>Assemble an nd-array from nested lists of blocks.</p>
<p>Blocks in the innermost lists are concatenated (see <cite>concatenate</cite>) along
the last dimension (-1), then these are concatenated along the
second-last dimension (-2), and so on until the outermost list is reached.</p>
<p>Blocks can be of any dimension, but will not be broadcasted using the normal
rules. Instead, leading axes of size 1 are inserted, to make <code class="docutils literal notranslate"><span class="pre">block.ndim</span></code>
the same for all blocks. This is primarily useful for working with scalars,
and means that code like <code class="docutils literal notranslate"><span class="pre">np.block([v,</span> <span class="pre">1])</span></code> is valid, where
<code class="docutils literal notranslate"><span class="pre">v.ndim</span> <span class="pre">==</span> <span class="pre">1</span></code>.</p>
<p>When the nested list is two levels deep, this allows block matrices to be
constructed from their components.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.13.0.</span></p>
</div>
<dl>
<dt>arrays<span class="classifier">nested list of array_like or scalars (but not tuples)</span></dt><dd><p>If passed a single ndarray or scalar (a nested list of depth 0), this
is returned unmodified (and not copied).</p>
<p>Elements shapes must match along the appropriate axes (without
broadcasting), but leading 1s will be prepended to the shape as
necessary to make the dimensions match.</p>
</dd>
</dl>
<dl>
<dt>block_array<span class="classifier">ndarray</span></dt><dd><p>The array assembled from the given blocks.</p>
<p>The dimensionality of the output is equal to the greatest of:
* the dimensionality of all the inputs
* the depth to which the input list is nested</p>
</dd>
</dl>
<dl class="simple">
<dt>ValueError</dt><dd><ul class="simple">
<li><p>If list depths are mismatched - for instance, <code class="docutils literal notranslate"><span class="pre">[[a,</span> <span class="pre">b],</span> <span class="pre">c]</span></code> is
illegal, and should be spelt <code class="docutils literal notranslate"><span class="pre">[[a,</span> <span class="pre">b],</span> <span class="pre">[c]]</span></code></p></li>
<li><p>If lists are empty - for instance, <code class="docutils literal notranslate"><span class="pre">[[a,</span> <span class="pre">b],</span> <span class="pre">[]]</span></code></p></li>
</ul>
</dd>
</dl>
<p>concatenate : Join a sequence of arrays along an existing axis.
stack : Join a sequence of arrays along a new axis.
vstack : Stack arrays in sequence vertically (row wise).
hstack : Stack arrays in sequence horizontally (column wise).
dstack : Stack arrays in sequence depth wise (along third axis).
column_stack : Stack 1-D arrays as columns into a 2-D array.
vsplit : Split an array into multiple sub-arrays vertically (row-wise).</p>
<p>When called with only scalars, <code class="docutils literal notranslate"><span class="pre">np.block</span></code> is equivalent to an ndarray
call. So <code class="docutils literal notranslate"><span class="pre">np.block([[1,</span> <span class="pre">2],</span> <span class="pre">[3,</span> <span class="pre">4]])</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">np.array([[1,</span> <span class="pre">2],</span> <span class="pre">[3,</span> <span class="pre">4]])</span></code>.</p>
<p>This function does not enforce that the blocks lie on a fixed grid.
<code class="docutils literal notranslate"><span class="pre">np.block([[a,</span> <span class="pre">b],</span> <span class="pre">[c,</span> <span class="pre">d]])</span></code> is not restricted to arrays of the form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">AAAbb</span>
<span class="n">AAAbb</span>
<span class="n">cccDD</span>
</pre></div>
</div>
<p>But is also allowed to produce, for some <code class="docutils literal notranslate"><span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">c,</span> <span class="pre">d</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">AAAbb</span>
<span class="n">AAAbb</span>
<span class="n">cDDDD</span>
</pre></div>
</div>
<p>Since concatenation happens along the last axis first, <cite>block</cite> is _not_
capable of producing the following directly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">AAAbb</span>
<span class="n">cccbb</span>
<span class="n">cccDD</span>
</pre></div>
</div>
<p>Matlab’s “square bracket stacking”, <code class="docutils literal notranslate"><span class="pre">[A,</span> <span class="pre">B,</span> <span class="pre">...;</span> <span class="pre">p,</span> <span class="pre">q,</span> <span class="pre">...]</span></code>, is
equivalent to <code class="docutils literal notranslate"><span class="pre">np.block([[A,</span> <span class="pre">B,</span> <span class="pre">...],</span> <span class="pre">[p,</span> <span class="pre">q,</span> <span class="pre">...]])</span></code>.</p>
<p>The most common use of this function is to build a block matrix</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([</span>
<span class="gp">... </span>    <span class="p">[</span><span class="n">A</span><span class="p">,</span>               <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span> <span class="n">B</span>               <span class="p">]</span>
<span class="gp">... </span><span class="p">])</span>
<span class="go">array([[2., 0., 0., 0., 0.],</span>
<span class="go">       [0., 2., 0., 0., 0.],</span>
<span class="go">       [1., 1., 3., 0., 0.],</span>
<span class="go">       [1., 1., 0., 3., 0.],</span>
<span class="go">       [1., 1., 0., 0., 3.]])</span>
</pre></div>
</div>
<p>With a list of depth 1, <cite>block</cite> can be used as <cite>hstack</cite></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>              <span class="c1"># hstack([1, 2, 3])</span>
<span class="go">array([1, 2, 3])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>             <span class="c1"># hstack([a, b, 10])</span>
<span class="go">array([ 1,  2,  3,  4,  5,  6, 10])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">])</span>                 <span class="c1"># hstack([A, B])</span>
<span class="go">array([[1, 1, 2, 2],</span>
<span class="go">       [1, 1, 2, 2]])</span>
</pre></div>
</div>
<p>With a list of depth 2, <cite>block</cite> can be used in place of <cite>vstack</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([[</span><span class="n">a</span><span class="p">],</span> <span class="p">[</span><span class="n">b</span><span class="p">]])</span>             <span class="c1"># vstack([a, b])</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [4, 5, 6]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([[</span><span class="n">A</span><span class="p">],</span> <span class="p">[</span><span class="n">B</span><span class="p">]])</span>             <span class="c1"># vstack([A, B])</span>
<span class="go">array([[1, 1],</span>
<span class="go">       [1, 1],</span>
<span class="go">       [2, 2],</span>
<span class="go">       [2, 2]])</span>
</pre></div>
</div>
<p>It can also be used in places of <cite>atleast_1d</cite> and <cite>atleast_2d</cite></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([</span><span class="n">a</span><span class="p">])</span>                    <span class="c1"># atleast_1d(a)</span>
<span class="go">array([0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([</span><span class="n">b</span><span class="p">])</span>                    <span class="c1"># atleast_1d(b)</span>
<span class="go">array([1])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([[</span><span class="n">a</span><span class="p">]])</span>                  <span class="c1"># atleast_2d(a)</span>
<span class="go">array([[0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([[</span><span class="n">b</span><span class="p">]])</span>                  <span class="c1"># atleast_2d(b)</span>
<span class="go">array([[1]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.bmat">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">bmat</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ldict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gdict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.bmat" title="Permalink to this definition">¶</a></dt>
<dd><p>Build a matrix object from a string, nested sequence, or array.</p>
<dl class="simple">
<dt>obj<span class="classifier">str or array_like</span></dt><dd><p>Input data. If a string, variables in the current scope may be
referenced by name.</p>
</dd>
<dt>ldict<span class="classifier">dict, optional</span></dt><dd><p>A dictionary that replaces local operands in current frame.
Ignored if <cite>obj</cite> is not a string or <cite>gdict</cite> is None.</p>
</dd>
<dt>gdict<span class="classifier">dict, optional</span></dt><dd><p>A dictionary that replaces global operands in current frame.
Ignored if <cite>obj</cite> is not a string.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">matrix</span></dt><dd><p>Returns a matrix object, which is a specialized 2-D array.</p>
</dd>
</dl>
<dl class="simple">
<dt>block :</dt><dd><p>A generalization of this function for N-d arrays, that returns normal
ndarrays.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span><span class="s1">&#39;1 1; 1 1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span><span class="s1">&#39;2 2; 2 2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span><span class="s1">&#39;3 4; 5 6&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span><span class="s1">&#39;7 8; 9 0&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>All the following expressions construct the same block matrix:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bmat</span><span class="p">([[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">],</span> <span class="p">[</span><span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">]])</span>
<span class="go">matrix([[1, 1, 2, 2],</span>
<span class="go">        [1, 1, 2, 2],</span>
<span class="go">        [3, 4, 7, 8],</span>
<span class="go">        [5, 6, 9, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bmat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">]])</span>
<span class="go">matrix([[1, 1, 2, 2],</span>
<span class="go">        [1, 1, 2, 2],</span>
<span class="go">        [3, 4, 7, 8],</span>
<span class="go">        [5, 6, 9, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bmat</span><span class="p">(</span><span class="s1">&#39;A,B; C,D&#39;</span><span class="p">)</span>
<span class="go">matrix([[1, 1, 2, 2],</span>
<span class="go">        [1, 1, 2, 2],</span>
<span class="go">        [3, 4, 7, 8],</span>
<span class="go">        [5, 6, 9, 0]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.bool8">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">bool8</span></code><a class="headerlink" href="#numpy.bool8" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.bool_" title="numpy.bool_"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.bool_</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt id="numpy.bool_">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">bool_</span></code><a class="headerlink" href="#numpy.bool_" title="Permalink to this definition">¶</a></dt>
<dd><p>Boolean type (True or False), stored as a byte.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The <a class="reference internal" href="#numpy.bool_" title="numpy.bool_"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool_</span></code></a> type is not a subclass of the <a class="reference internal" href="#numpy.int_" title="numpy.int_"><code class="xref py py-class docutils literal notranslate"><span class="pre">int_</span></code></a> type
(the <a class="reference internal" href="#numpy.bool_" title="numpy.bool_"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool_</span></code></a> is not even a number type). This is different
than Python’s default implementation of <code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code> as a
sub-class of <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Character code</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">'?'</span></code></p>
</dd>
<dt class="field-even">Alias</dt>
<dd class="field-even"><p><cite>numpy.bool8</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="numpy.broadcast">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">broadcast</span></code><a class="headerlink" href="#numpy.broadcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Produce an object that mimics broadcasting.</p>
<dl class="simple">
<dt>in1, in2, …<span class="classifier">array_like</span></dt><dd><p>Input parameters.</p>
</dd>
</dl>
<dl class="simple">
<dt>b<span class="classifier">broadcast object</span></dt><dd><p>Broadcast the input parameters against one another, and
return an object that encapsulates the result.
Amongst others, it has <code class="docutils literal notranslate"><span class="pre">shape</span></code> and <code class="docutils literal notranslate"><span class="pre">nd</span></code> properties, and
may be used as an iterator.</p>
</dd>
</dl>
<p>broadcast_arrays
broadcast_to
broadcast_shapes</p>
<p>Manually adding two vectors, using broadcasting:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span><span class="o">.</span><span class="n">flat</span> <span class="o">=</span> <span class="p">[</span><span class="n">u</span><span class="o">+</span><span class="n">v</span> <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">b</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span>
<span class="go">array([[5.,  6.,  7.],</span>
<span class="go">       [6.,  7.,  8.],</span>
<span class="go">       [7.,  8.,  9.]])</span>
</pre></div>
</div>
<p>Compare against built-in broadcasting:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="go">array([[5, 6, 7],</span>
<span class="go">       [6, 7, 8],</span>
<span class="go">       [7, 8, 9]])</span>
</pre></div>
</div>
<dl class="py attribute">
<dt id="numpy.broadcast.index">
<code class="sig-name descname"><span class="pre">index</span></code><a class="headerlink" href="#numpy.broadcast.index" title="Permalink to this definition">¶</a></dt>
<dd><p>current index in broadcasted result</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">index</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">((1, 4), (1, 5), (1, 6))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">index</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.broadcast.iters">
<code class="sig-name descname"><span class="pre">iters</span></code><a class="headerlink" href="#numpy.broadcast.iters" title="Permalink to this definition">¶</a></dt>
<dd><p>tuple of iterators along <code class="docutils literal notranslate"><span class="pre">self</span></code>’s “components.”</p>
<p>Returns a tuple of <cite>numpy.flatiter</cite> objects, one for each “component”
of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>numpy.flatiter</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">iters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">row</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
<span class="go">(1, 4)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.broadcast.nd">
<code class="sig-name descname"><span class="pre">nd</span></code><a class="headerlink" href="#numpy.broadcast.nd" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of dimensions of broadcasted result. For code intended for NumPy
1.12.0 and later the more consistent <cite>ndim</cite> is preferred.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">nd</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.broadcast.ndim">
<code class="sig-name descname"><span class="pre">ndim</span></code><a class="headerlink" href="#numpy.broadcast.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of dimensions of broadcasted result. Alias for <cite>nd</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.12.0.</span></p>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">ndim</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.broadcast.numiter">
<code class="sig-name descname"><span class="pre">numiter</span></code><a class="headerlink" href="#numpy.broadcast.numiter" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of iterators possessed by the broadcasted result.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">numiter</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.broadcast.reset">
<code class="sig-name descname"><span class="pre">reset</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.broadcast.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the broadcasted result’s iterator(s).</p>
<p>None</p>
<p>None</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">index</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">((1, 4), (2, 4), (3, 4))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">index</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">index</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.broadcast.shape">
<code class="sig-name descname"><span class="pre">shape</span></code><a class="headerlink" href="#numpy.broadcast.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Shape of broadcasted result.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.broadcast.size">
<code class="sig-name descname"><span class="pre">size</span></code><a class="headerlink" href="#numpy.broadcast.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Total size of broadcasted result.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">size</span>
<span class="go">9</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="numpy.broadcast_arrays">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">broadcast_arrays</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subok</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.broadcast_arrays" title="Permalink to this definition">¶</a></dt>
<dd><p>Broadcast any number of arrays against each other.</p>
<dl class="simple">
<dt><cite>*args</cite><span class="classifier">array_likes</span></dt><dd><p>The arrays to broadcast.</p>
</dd>
<dt>subok<span class="classifier">bool, optional</span></dt><dd><p>If True, then sub-classes will be passed-through, otherwise
the returned arrays will be forced to be a base-class array (default).</p>
</dd>
</dl>
<dl>
<dt>broadcasted<span class="classifier">list of arrays</span></dt><dd><p>These arrays are views on the original arrays.  They are typically
not contiguous.  Furthermore, more than one element of a
broadcasted array may refer to a single memory location. If you need
to write to the arrays, make copies first. While you can set the
<code class="docutils literal notranslate"><span class="pre">writable</span></code> flag True, writing to a single output value may end up
changing more than one location in the output array.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 1.17: </span>The output is currently marked so that if written to, a deprecation
warning will be emitted. A future version will set the
<code class="docutils literal notranslate"><span class="pre">writable</span></code> flag False so writing to it will raise an error.</p>
</div>
</dd>
</dl>
<p>broadcast
broadcast_to
broadcast_shapes</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">[array([[1, 2, 3],</span>
<span class="go">       [1, 2, 3]]), array([[4, 4, 4],</span>
<span class="go">       [5, 5, 5]])]</span>
</pre></div>
</div>
<p>Here is a useful idiom for getting contiguous copies instead of
non-contiguous views.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span>
<span class="go">[array([[1, 2, 3],</span>
<span class="go">       [1, 2, 3]]), array([[4, 4, 4],</span>
<span class="go">       [5, 5, 5]])]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.broadcast_shapes">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">broadcast_shapes</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.broadcast_shapes" title="Permalink to this definition">¶</a></dt>
<dd><p>Broadcast the input shapes into a single shape.</p>
<p><span class="xref std std-ref">Learn more about broadcasting here</span>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.20.0.</span></p>
</div>
<dl class="simple">
<dt><cite>*args</cite><span class="classifier">tuples of ints, or ints</span></dt><dd><p>The shapes to be broadcast against each other.</p>
</dd>
</dl>
<dl class="simple">
<dt>tuple</dt><dd><p>Broadcasted shape.</p>
</dd>
</dl>
<dl class="simple">
<dt>ValueError</dt><dd><p>If the shapes are not compatible and cannot be broadcast according
to NumPy’s broadcasting rules.</p>
</dd>
</dl>
<p>broadcast
broadcast_arrays
broadcast_to</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_shapes</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">(3, 2)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_shapes</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">7</span><span class="p">,),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
<span class="go">(5, 6, 7)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.broadcast_to">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">broadcast_to</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subok</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.broadcast_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Broadcast an array to a new shape.</p>
<dl class="simple">
<dt>array<span class="classifier">array_like</span></dt><dd><p>The array to broadcast.</p>
</dd>
<dt>shape<span class="classifier">tuple</span></dt><dd><p>The shape of the desired array.</p>
</dd>
<dt>subok<span class="classifier">bool, optional</span></dt><dd><p>If True, then sub-classes will be passed-through, otherwise
the returned array will be forced to be a base-class array (default).</p>
</dd>
</dl>
<dl class="simple">
<dt>broadcast<span class="classifier">array</span></dt><dd><p>A readonly view on the original array with the given shape. It is
typically not contiguous. Furthermore, more than one element of a
broadcasted array may refer to a single memory location.</p>
</dd>
</dl>
<dl class="simple">
<dt>ValueError</dt><dd><p>If the array is not compatible with the new shape according to NumPy’s
broadcasting rules.</p>
</dd>
</dl>
<p>broadcast
broadcast_arrays
broadcast_shapes</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.0.</span></p>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [1, 2, 3],</span>
<span class="go">       [1, 2, 3]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.busday_count">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">busday_count</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">begindates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">enddates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weekmask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'1111100'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">holidays</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">busdaycal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.busday_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Counts the number of valid days between <cite>begindates</cite> and
<cite>enddates</cite>, not including the day of <cite>enddates</cite>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">enddates</span></code> specifies a date value that is earlier than the
corresponding <code class="docutils literal notranslate"><span class="pre">begindates</span></code> date value, the count will be negative.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<dl class="simple">
<dt>begindates<span class="classifier">array_like of datetime64[D]</span></dt><dd><p>The array of the first dates for counting.</p>
</dd>
<dt>enddates<span class="classifier">array_like of datetime64[D]</span></dt><dd><p>The array of the end dates for counting, which are excluded
from the count themselves.</p>
</dd>
<dt>weekmask<span class="classifier">str or array_like of bool, optional</span></dt><dd><p>A seven-element array indicating which of Monday through Sunday are
valid days. May be specified as a length-seven list or array, like
[1,1,1,1,1,0,0]; a length-seven string, like ‘1111100’; or a string
like “Mon Tue Wed Thu Fri”, made up of 3-character abbreviations for
weekdays, optionally separated by white space. Valid abbreviations
are: Mon Tue Wed Thu Fri Sat Sun</p>
</dd>
<dt>holidays<span class="classifier">array_like of datetime64[D], optional</span></dt><dd><p>An array of dates to consider as invalid dates.  They may be
specified in any order, and NaT (not-a-time) dates are ignored.
This list is saved in a normalized form that is suited for
fast calculations of valid days.</p>
</dd>
<dt>busdaycal<span class="classifier">busdaycalendar, optional</span></dt><dd><p>A <cite>busdaycalendar</cite> object which specifies the valid days. If this
parameter is provided, neither weekmask nor holidays may be
provided.</p>
</dd>
<dt>out<span class="classifier">array of int, optional</span></dt><dd><p>If provided, this array is filled with the result.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">array of int</span></dt><dd><p>An array with a shape from broadcasting <code class="docutils literal notranslate"><span class="pre">begindates</span></code> and <code class="docutils literal notranslate"><span class="pre">enddates</span></code>
together, containing the number of valid days between
the begin and end dates.</p>
</dd>
</dl>
<p>busdaycalendar : An object that specifies a custom set of valid days.
is_busday : Returns a boolean array indicating valid days.
busday_offset : Applies an offset counted in valid days.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Number of weekdays in January 2011</span>
<span class="gp">... </span><span class="n">np</span><span class="o">.</span><span class="n">busday_count</span><span class="p">(</span><span class="s1">&#39;2011-01&#39;</span><span class="p">,</span> <span class="s1">&#39;2011-02&#39;</span><span class="p">)</span>
<span class="go">21</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Number of weekdays in 2011</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">busday_count</span><span class="p">(</span><span class="s1">&#39;2011&#39;</span><span class="p">,</span> <span class="s1">&#39;2012&#39;</span><span class="p">)</span>
<span class="go">260</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Number of Saturdays in 2011</span>
<span class="gp">... </span><span class="n">np</span><span class="o">.</span><span class="n">busday_count</span><span class="p">(</span><span class="s1">&#39;2011&#39;</span><span class="p">,</span> <span class="s1">&#39;2012&#39;</span><span class="p">,</span> <span class="n">weekmask</span><span class="o">=</span><span class="s1">&#39;Sat&#39;</span><span class="p">)</span>
<span class="go">53</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.busday_offset">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">busday_offset</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roll</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'raise'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weekmask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'1111100'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">holidays</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">busdaycal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.busday_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>First adjusts the date to fall on a valid day according to
the <code class="docutils literal notranslate"><span class="pre">roll</span></code> rule, then applies offsets to the given dates
counted in valid days.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<dl>
<dt>dates<span class="classifier">array_like of datetime64[D]</span></dt><dd><p>The array of dates to process.</p>
</dd>
<dt>offsets<span class="classifier">array_like of int</span></dt><dd><p>The array of offsets, which is broadcast with <code class="docutils literal notranslate"><span class="pre">dates</span></code>.</p>
</dd>
<dt>roll<span class="classifier">{‘raise’, ‘nat’, ‘forward’, ‘following’, ‘backward’, ‘preceding’, ‘modifiedfollowing’, ‘modifiedpreceding’}, optional</span></dt><dd><p>How to treat dates that do not fall on a valid day. The default
is ‘raise’.</p>
<blockquote>
<div><ul class="simple">
<li><p>‘raise’ means to raise an exception for an invalid day.</p></li>
<li><p>‘nat’ means to return a NaT (not-a-time) for an invalid day.</p></li>
<li><p>‘forward’ and ‘following’ mean to take the first valid day
later in time.</p></li>
<li><p>‘backward’ and ‘preceding’ mean to take the first valid day
earlier in time.</p></li>
<li><p>‘modifiedfollowing’ means to take the first valid day
later in time unless it is across a Month boundary, in which
case to take the first valid day earlier in time.</p></li>
<li><p>‘modifiedpreceding’ means to take the first valid day
earlier in time unless it is across a Month boundary, in which
case to take the first valid day later in time.</p></li>
</ul>
</div></blockquote>
</dd>
<dt>weekmask<span class="classifier">str or array_like of bool, optional</span></dt><dd><p>A seven-element array indicating which of Monday through Sunday are
valid days. May be specified as a length-seven list or array, like
[1,1,1,1,1,0,0]; a length-seven string, like ‘1111100’; or a string
like “Mon Tue Wed Thu Fri”, made up of 3-character abbreviations for
weekdays, optionally separated by white space. Valid abbreviations
are: Mon Tue Wed Thu Fri Sat Sun</p>
</dd>
<dt>holidays<span class="classifier">array_like of datetime64[D], optional</span></dt><dd><p>An array of dates to consider as invalid dates.  They may be
specified in any order, and NaT (not-a-time) dates are ignored.
This list is saved in a normalized form that is suited for
fast calculations of valid days.</p>
</dd>
<dt>busdaycal<span class="classifier">busdaycalendar, optional</span></dt><dd><p>A <cite>busdaycalendar</cite> object which specifies the valid days. If this
parameter is provided, neither weekmask nor holidays may be
provided.</p>
</dd>
<dt>out<span class="classifier">array of datetime64[D], optional</span></dt><dd><p>If provided, this array is filled with the result.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">array of datetime64[D]</span></dt><dd><p>An array with a shape from broadcasting <code class="docutils literal notranslate"><span class="pre">dates</span></code> and <code class="docutils literal notranslate"><span class="pre">offsets</span></code>
together, containing the dates with offsets applied.</p>
</dd>
</dl>
<p>busdaycalendar : An object that specifies a custom set of valid days.
is_busday : Returns a boolean array indicating valid days.
busday_count : Counts how many valid days are in a half-open date range.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># First business day in October 2011 (not accounting for holidays)</span>
<span class="gp">... </span><span class="n">np</span><span class="o">.</span><span class="n">busday_offset</span><span class="p">(</span><span class="s1">&#39;2011-10&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="s1">&#39;forward&#39;</span><span class="p">)</span>
<span class="go">numpy.datetime64(&#39;2011-10-03&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Last business day in February 2012 (not accounting for holidays)</span>
<span class="gp">... </span><span class="n">np</span><span class="o">.</span><span class="n">busday_offset</span><span class="p">(</span><span class="s1">&#39;2012-03&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="s1">&#39;forward&#39;</span><span class="p">)</span>
<span class="go">numpy.datetime64(&#39;2012-02-29&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Third Wednesday in January 2011</span>
<span class="gp">... </span><span class="n">np</span><span class="o">.</span><span class="n">busday_offset</span><span class="p">(</span><span class="s1">&#39;2011-01&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="s1">&#39;forward&#39;</span><span class="p">,</span> <span class="n">weekmask</span><span class="o">=</span><span class="s1">&#39;Wed&#39;</span><span class="p">)</span>
<span class="go">numpy.datetime64(&#39;2011-01-19&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 2012 Mother&#39;s Day in Canada and the U.S.</span>
<span class="gp">... </span><span class="n">np</span><span class="o">.</span><span class="n">busday_offset</span><span class="p">(</span><span class="s1">&#39;2012-05&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="s1">&#39;forward&#39;</span><span class="p">,</span> <span class="n">weekmask</span><span class="o">=</span><span class="s1">&#39;Sun&#39;</span><span class="p">)</span>
<span class="go">numpy.datetime64(&#39;2012-05-13&#39;)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># First business day on or after a date</span>
<span class="gp">... </span><span class="n">np</span><span class="o">.</span><span class="n">busday_offset</span><span class="p">(</span><span class="s1">&#39;2011-03-20&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="s1">&#39;forward&#39;</span><span class="p">)</span>
<span class="go">numpy.datetime64(&#39;2011-03-21&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">busday_offset</span><span class="p">(</span><span class="s1">&#39;2011-03-22&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="s1">&#39;forward&#39;</span><span class="p">)</span>
<span class="go">numpy.datetime64(&#39;2011-03-22&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># First business day after a date</span>
<span class="gp">... </span><span class="n">np</span><span class="o">.</span><span class="n">busday_offset</span><span class="p">(</span><span class="s1">&#39;2011-03-20&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="s1">&#39;backward&#39;</span><span class="p">)</span>
<span class="go">numpy.datetime64(&#39;2011-03-21&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">busday_offset</span><span class="p">(</span><span class="s1">&#39;2011-03-22&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="s1">&#39;backward&#39;</span><span class="p">)</span>
<span class="go">numpy.datetime64(&#39;2011-03-23&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt id="numpy.busdaycalendar">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">busdaycalendar</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weekmask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'1111100'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">holidays</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.busdaycalendar" title="Permalink to this definition">¶</a></dt>
<dd><p>A business day calendar object that efficiently stores information
defining valid days for the busday family of functions.</p>
<p>The default valid days are Monday through Friday (“business days”).
A busdaycalendar object can be specified with any set of weekly
valid days, plus an optional “holiday” dates that always will be invalid.</p>
<p>Once a busdaycalendar object is created, the weekmask and holidays
cannot be modified.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<dl class="simple">
<dt>weekmask<span class="classifier">str or array_like of bool, optional</span></dt><dd><p>A seven-element array indicating which of Monday through Sunday are
valid days. May be specified as a length-seven list or array, like
[1,1,1,1,1,0,0]; a length-seven string, like ‘1111100’; or a string
like “Mon Tue Wed Thu Fri”, made up of 3-character abbreviations for
weekdays, optionally separated by white space. Valid abbreviations
are: Mon Tue Wed Thu Fri Sat Sun</p>
</dd>
<dt>holidays<span class="classifier">array_like of datetime64[D], optional</span></dt><dd><p>An array of dates to consider as invalid dates, no matter which
weekday they fall upon.  Holiday dates may be specified in any
order, and NaT (not-a-time) dates are ignored.  This list is
saved in a normalized form that is suited for fast calculations
of valid days.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">busdaycalendar</span></dt><dd><p>A business day calendar object containing the specified
weekmask and holidays values.</p>
</dd>
</dl>
<p>is_busday : Returns a boolean array indicating valid days.
busday_offset : Applies an offset counted in valid days.
busday_count : Counts how many valid days are in a half-open date range.</p>
<p>Note: once a busdaycalendar object is created, you cannot modify the
weekmask or holidays.  The attributes return copies of internal data.
weekmask : (copy) seven-element array of bool
holidays : (copy) sorted array of datetime64[D]</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Some important days in July</span>
<span class="gp">... </span><span class="n">bdd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">busdaycalendar</span><span class="p">(</span>
<span class="gp">... </span>            <span class="n">holidays</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;2011-07-01&#39;</span><span class="p">,</span> <span class="s1">&#39;2011-07-04&#39;</span><span class="p">,</span> <span class="s1">&#39;2011-07-17&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Default is Monday to Friday weekdays</span>
<span class="gp">... </span><span class="n">bdd</span><span class="o">.</span><span class="n">weekmask</span>
<span class="go">array([ True,  True,  True,  True,  True, False, False])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Any holidays already on the weekend are removed</span>
<span class="gp">... </span><span class="n">bdd</span><span class="o">.</span><span class="n">holidays</span>
<span class="go">array([&#39;2011-07-01&#39;, &#39;2011-07-04&#39;], dtype=&#39;datetime64[D]&#39;)</span>
</pre></div>
</div>
<dl class="py attribute">
<dt id="numpy.busdaycalendar.holidays">
<code class="sig-name descname"><span class="pre">holidays</span></code><a class="headerlink" href="#numpy.busdaycalendar.holidays" title="Permalink to this definition">¶</a></dt>
<dd><p>A copy of the holiday array indicating additional invalid days.</p>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.busdaycalendar.weekmask">
<code class="sig-name descname"><span class="pre">weekmask</span></code><a class="headerlink" href="#numpy.busdaycalendar.weekmask" title="Permalink to this definition">¶</a></dt>
<dd><p>A copy of the seven-element boolean mask indicating valid days.</p>
</dd></dl>

</dd></dl>

<dl class="py attribute">
<dt id="numpy.byte">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">byte</span></code><a class="headerlink" href="#numpy.byte" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.int8" title="numpy.int8"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.int8</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="numpy.byte_bounds">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">byte_bounds</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.byte_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns pointers to the end-points of an array.</p>
<dl class="simple">
<dt>a<span class="classifier">ndarray</span></dt><dd><p>Input array. It must conform to the Python-side of the array
interface.</p>
</dd>
</dl>
<dl class="simple">
<dt>(low, high)<span class="classifier">tuple of 2 integers</span></dt><dd><p>The first integer is the first byte of the array, the second
integer is just past the last byte of the array.  If <cite>a</cite> is not
contiguous it will not use every byte between the (<cite>low</cite>, <cite>high</cite>)
values.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">);</span> <span class="n">I</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype(&#39;float32&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">byte_bounds</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span> <span class="o">==</span> <span class="n">I</span><span class="o">.</span><span class="n">size</span><span class="o">*</span><span class="n">I</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="n">I</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype(&#39;float64&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">byte_bounds</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span> <span class="o">==</span> <span class="n">I</span><span class="o">.</span><span class="n">size</span><span class="o">*</span><span class="n">I</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.bytes0">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">bytes0</span></code><a class="headerlink" href="#numpy.bytes0" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.bytes_" title="numpy.bytes_"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.bytes_</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt id="numpy.bytes_">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">bytes_</span></code><a class="headerlink" href="#numpy.bytes_" title="Permalink to this definition">¶</a></dt>
<dd><p>A byte string.</p>
<p>When used in arrays, this type strips trailing null bytes.</p>
<dl class="field-list simple">
<dt class="field-odd">Character code</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">'S'</span></code></p>
</dd>
<dt class="field-even">Alias</dt>
<dd class="field-even"><p><cite>numpy.string_</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="numpy.can_cast">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">can_cast</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">from_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">casting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'safe'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.can_cast" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if cast between data types can occur according to the
casting rule.  If from is a scalar or array scalar, also returns
True if the scalar value can be cast without overflow or truncation
to an integer.</p>
<dl>
<dt><a href="#id76"><span class="problematic" id="id77">from_</span></a><span class="classifier">dtype, dtype specifier, scalar, or array</span></dt><dd><p>Data type, scalar, or array to cast from.</p>
</dd>
<dt>to<span class="classifier">dtype or dtype specifier</span></dt><dd><p>Data type to cast to.</p>
</dd>
<dt>casting<span class="classifier">{‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional</span></dt><dd><p>Controls what kind of data casting may occur.</p>
<blockquote>
<div><ul class="simple">
<li><p>‘no’ means the data types should not be cast at all.</p></li>
<li><p>‘equiv’ means only byte-order changes are allowed.</p></li>
<li><p>‘safe’ means only casts which can preserve values are allowed.</p></li>
<li><p>‘same_kind’ means only safe casts or casts within a kind,
like float64 to float32, are allowed.</p></li>
<li><p>‘unsafe’ means any data conversions may be done.</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">bool</span></dt><dd><p>True if cast can occur according to the casting rule.</p>
</dd>
</dl>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.17.0: </span>Casting between a simple data type and a structured one is possible only
for “unsafe” casting.  Casting to multiple fields is allowed, but
casting from multiple fields is not.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.9.0: </span>Casting from numeric to string types in ‘safe’ casting mode requires
that the string dtype length is long enough to store the maximum
integer/float value converted.</p>
</div>
<p>dtype, result_type</p>
<p>Basic examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="nb">complex</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="s1">&#39;i8&#39;</span><span class="p">,</span> <span class="s1">&#39;f8&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="s1">&#39;i8&#39;</span><span class="p">,</span> <span class="s1">&#39;f4&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="s1">&#39;i4&#39;</span><span class="p">,</span> <span class="s1">&#39;S4&#39;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Casting scalars</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="s1">&#39;i1&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="mi">150</span><span class="p">,</span> <span class="s1">&#39;i1&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="mi">150</span><span class="p">,</span> <span class="s1">&#39;u1&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="mf">3.5e100</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="mf">1000.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Array scalar checks the value, array does not</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mf">1000.0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1000.0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Using the casting rules</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="s1">&#39;i8&#39;</span><span class="p">,</span> <span class="s1">&#39;i8&#39;</span><span class="p">,</span> <span class="s1">&#39;no&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="s1">&#39;&lt;i8&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;i8&#39;</span><span class="p">,</span> <span class="s1">&#39;no&#39;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="s1">&#39;&lt;i8&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;i8&#39;</span><span class="p">,</span> <span class="s1">&#39;equiv&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="s1">&#39;&lt;i4&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;i8&#39;</span><span class="p">,</span> <span class="s1">&#39;equiv&#39;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="s1">&#39;&lt;i4&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;i8&#39;</span><span class="p">,</span> <span class="s1">&#39;safe&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="s1">&#39;&lt;i8&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;i4&#39;</span><span class="p">,</span> <span class="s1">&#39;safe&#39;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="s1">&#39;&lt;i8&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;i4&#39;</span><span class="p">,</span> <span class="s1">&#39;same_kind&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="s1">&#39;&lt;i8&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;u4&#39;</span><span class="p">,</span> <span class="s1">&#39;same_kind&#39;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="s1">&#39;&lt;i8&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;u4&#39;</span><span class="p">,</span> <span class="s1">&#39;unsafe&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.cdouble">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">cdouble</span></code><a class="headerlink" href="#numpy.cdouble" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.complex128" title="numpy.complex128"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.complex128</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.cfloat">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">cfloat</span></code><a class="headerlink" href="#numpy.cfloat" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.complex128" title="numpy.complex128"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.complex128</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt id="numpy.character">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">character</span></code><a class="headerlink" href="#numpy.character" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class of all character string scalar types.</p>
</dd></dl>

<dl class="py class">
<dt id="numpy.chararray">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">chararray</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">itemsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unicode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strides</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'C'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>chararray(shape, itemsize=1, unicode=False, buffer=None, offset=0,</dt><dd><p>strides=None, order=None)</p>
</dd>
</dl>
<p>Provides a convenient view on arrays of string and unicode values.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <cite>chararray</cite> class exists for backwards compatibility with
Numarray, it is not recommended for new development. Starting from numpy
1.4, if one needs arrays of strings, it is recommended to use arrays of
<cite>dtype</cite> <cite>object_</cite>, <cite>string_</cite> or <cite>unicode_</cite>, and use the free functions
in the <cite>numpy.char</cite> module for fast vectorized string operations.</p>
</div>
<p>Versus a regular NumPy array of type <cite>str</cite> or <cite>unicode</cite>, this
class adds the following functionality:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>values automatically have whitespace removed from the end
when indexed</p></li>
<li><p>comparison operators automatically remove whitespace from the
end when comparing values</p></li>
<li><p>vectorized string operations are provided as methods
(e.g. <cite>.endswith</cite>) and infix operators (e.g. <code class="docutils literal notranslate"><span class="pre">&quot;+&quot;,</span> <span class="pre">&quot;*&quot;,</span> <span class="pre">&quot;%&quot;</span></code>)</p></li>
</ol>
</div></blockquote>
<p>chararrays should be created using <cite>numpy.char.array</cite> or
<cite>numpy.char.asarray</cite>, rather than this constructor directly.</p>
<p>This constructor creates the array, using <cite>buffer</cite> (with <cite>offset</cite>
and <cite>strides</cite>) if it is not <code class="docutils literal notranslate"><span class="pre">None</span></code>. If <cite>buffer</cite> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, then
constructs a new array with <cite>strides</cite> in “C order”, unless both
<code class="docutils literal notranslate"><span class="pre">len(shape)</span> <span class="pre">&gt;=</span> <span class="pre">2</span></code> and <code class="docutils literal notranslate"><span class="pre">order='F'</span></code>, in which case <cite>strides</cite>
is in “Fortran order”.</p>
<p>astype
argsort
copy
count
decode
dump
dumps
encode
endswith
expandtabs
fill
find
flatten
getfield
index
isalnum
isalpha
isdecimal
isdigit
islower
isnumeric
isspace
istitle
isupper
item
join
ljust
lower
lstrip
nonzero
put
ravel
repeat
replace
reshape
resize
rfind
rindex
rjust
rsplit
rstrip
searchsorted
setfield
setflags
sort
split
splitlines
squeeze
startswith
strip
swapaxes
swapcase
take
title
tofile
tolist
tostring
translate
transpose
upper
view
zfill</p>
<dl class="simple">
<dt>shape<span class="classifier">tuple</span></dt><dd><p>Shape of the array.</p>
</dd>
<dt>itemsize<span class="classifier">int, optional</span></dt><dd><p>Length of each array element, in number of characters. Default is 1.</p>
</dd>
<dt>unicode<span class="classifier">bool, optional</span></dt><dd><p>Are the array elements of type unicode (True) or string (False).
Default is False.</p>
</dd>
<dt>buffer<span class="classifier">object exposing the buffer interface or str, optional</span></dt><dd><p>Memory address of the start of the array data.  Default is None,
in which case a new array is created.</p>
</dd>
<dt>offset<span class="classifier">int, optional</span></dt><dd><p>Fixed stride displacement from the beginning of an axis?
Default is 0. Needs to be &gt;=0.</p>
</dd>
<dt>strides<span class="classifier">array_like of ints, optional</span></dt><dd><p>Strides for the array (see <cite>ndarray.strides</cite> for full description).
Default is None.</p>
</dd>
<dt>order<span class="classifier">{‘C’, ‘F’}, optional</span></dt><dd><p>The order in which the array data is stored in memory: ‘C’ -&gt;
“row major” order (the default), ‘F’ -&gt; “column major”
(Fortran) order.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">charar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">chararray</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">charar</span><span class="p">[:]</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">charar</span>
<span class="go">chararray([[b&#39;a&#39;, b&#39;a&#39;, b&#39;a&#39;],</span>
<span class="go">           [b&#39;a&#39;, b&#39;a&#39;, b&#39;a&#39;],</span>
<span class="go">           [b&#39;a&#39;, b&#39;a&#39;, b&#39;a&#39;]], dtype=&#39;|S1&#39;)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">charar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">chararray</span><span class="p">(</span><span class="n">charar</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">itemsize</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">charar</span><span class="p">[:]</span> <span class="o">=</span> <span class="s1">&#39;abc&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">charar</span>
<span class="go">chararray([[b&#39;abc&#39;, b&#39;abc&#39;, b&#39;abc&#39;],</span>
<span class="go">           [b&#39;abc&#39;, b&#39;abc&#39;, b&#39;abc&#39;],</span>
<span class="go">           [b&#39;abc&#39;, b&#39;abc&#39;, b&#39;abc&#39;]], dtype=&#39;|S5&#39;)</span>
</pre></div>
</div>
<dl class="py method">
<dt id="numpy.chararray.argsort">
<code class="sig-name descname"><span class="pre">argsort</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.argsort" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the indices that would sort this array.</p>
<p>Refer to <cite>numpy.argsort</cite> for full documentation.</p>
<p>numpy.argsort : equivalent function</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.capitalize">
<code class="sig-name descname"><span class="pre">capitalize</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.capitalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of <cite>self</cite> with only the first character of each element
capitalized.</p>
<p>char.capitalize</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.center">
<code class="sig-name descname"><span class="pre">center</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fillchar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'</span> <span class="pre">'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.center" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of <cite>self</cite> with its elements centered in a
string of length <cite>width</cite>.</p>
<p>center</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.count">
<code class="sig-name descname"><span class="pre">count</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array with the number of non-overlapping occurrences of
substring <cite>sub</cite> in the range [<cite>start</cite>, <cite>end</cite>].</p>
<p>char.count</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.decode">
<code class="sig-name descname"><span class="pre">decode</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls <cite>str.decode</cite> element-wise.</p>
<p>char.decode</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.encode">
<code class="sig-name descname"><span class="pre">encode</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.encode" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls <cite>str.encode</cite> element-wise.</p>
<p>char.encode</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.endswith">
<code class="sig-name descname"><span class="pre">endswith</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">suffix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.endswith" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a boolean array which is <cite>True</cite> where the string element
in <cite>self</cite> ends with <cite>suffix</cite>, otherwise <cite>False</cite>.</p>
<p>char.endswith</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.expandtabs">
<code class="sig-name descname"><span class="pre">expandtabs</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tabsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.expandtabs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of each string element where all tab characters are
replaced by one or more spaces.</p>
<p>char.expandtabs</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.find">
<code class="sig-name descname"><span class="pre">find</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.find" title="Permalink to this definition">¶</a></dt>
<dd><p>For each element, return the lowest index in the string where
substring <cite>sub</cite> is found.</p>
<p>char.find</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.index">
<code class="sig-name descname"><span class="pre">index</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <cite>find</cite>, but raises <cite>ValueError</cite> when the substring is not found.</p>
<p>char.index</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.isalnum">
<code class="sig-name descname"><span class="pre">isalnum</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.isalnum" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true for each element if all characters in the string
are alphanumeric and there is at least one character, false
otherwise.</p>
<p>char.isalnum</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.isalpha">
<code class="sig-name descname"><span class="pre">isalpha</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.isalpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true for each element if all characters in the string
are alphabetic and there is at least one character, false
otherwise.</p>
<p>char.isalpha</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.isdecimal">
<code class="sig-name descname"><span class="pre">isdecimal</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.isdecimal" title="Permalink to this definition">¶</a></dt>
<dd><p>For each element in <cite>self</cite>, return True if there are only
decimal characters in the element.</p>
<p>char.isdecimal</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.isdigit">
<code class="sig-name descname"><span class="pre">isdigit</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.isdigit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true for each element if all characters in the string are
digits and there is at least one character, false otherwise.</p>
<p>char.isdigit</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.islower">
<code class="sig-name descname"><span class="pre">islower</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.islower" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true for each element if all cased characters in the
string are lowercase and there is at least one cased character,
false otherwise.</p>
<p>char.islower</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.isnumeric">
<code class="sig-name descname"><span class="pre">isnumeric</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.isnumeric" title="Permalink to this definition">¶</a></dt>
<dd><p>For each element in <cite>self</cite>, return True if there are only
numeric characters in the element.</p>
<p>char.isnumeric</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.isspace">
<code class="sig-name descname"><span class="pre">isspace</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.isspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true for each element if there are only whitespace
characters in the string and there is at least one character,
false otherwise.</p>
<p>char.isspace</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.istitle">
<code class="sig-name descname"><span class="pre">istitle</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.istitle" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true for each element if the element is a titlecased
string and there is at least one character, false otherwise.</p>
<p>char.istitle</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.isupper">
<code class="sig-name descname"><span class="pre">isupper</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.isupper" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true for each element if all cased characters in the
string are uppercase and there is at least one character, false
otherwise.</p>
<p>char.isupper</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.join">
<code class="sig-name descname"><span class="pre">join</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.join" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string which is the concatenation of the strings in the
sequence <cite>seq</cite>.</p>
<p>char.join</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.ljust">
<code class="sig-name descname"><span class="pre">ljust</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fillchar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'</span> <span class="pre">'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.ljust" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array with the elements of <cite>self</cite> left-justified in a
string of length <cite>width</cite>.</p>
<p>char.ljust</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.lower">
<code class="sig-name descname"><span class="pre">lower</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.lower" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array with the elements of <cite>self</cite> converted to
lowercase.</p>
<p>char.lower</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.lstrip">
<code class="sig-name descname"><span class="pre">lstrip</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.lstrip" title="Permalink to this definition">¶</a></dt>
<dd><p>For each element in <cite>self</cite>, return a copy with the leading characters
removed.</p>
<p>char.lstrip</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.partition">
<code class="sig-name descname"><span class="pre">partition</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sep</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.partition" title="Permalink to this definition">¶</a></dt>
<dd><p>Partition each element in <cite>self</cite> around <cite>sep</cite>.</p>
<p>partition</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.replace">
<code class="sig-name descname"><span class="pre">replace</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">old</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>For each element in <cite>self</cite>, return a copy of the string with all
occurrences of substring <cite>old</cite> replaced by <cite>new</cite>.</p>
<p>char.replace</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.rfind">
<code class="sig-name descname"><span class="pre">rfind</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.rfind" title="Permalink to this definition">¶</a></dt>
<dd><p>For each element in <cite>self</cite>, return the highest index in the string
where substring <cite>sub</cite> is found, such that <cite>sub</cite> is contained
within [<cite>start</cite>, <cite>end</cite>].</p>
<p>char.rfind</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.rindex">
<code class="sig-name descname"><span class="pre">rindex</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.rindex" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <cite>rfind</cite>, but raises <cite>ValueError</cite> when the substring <cite>sub</cite> is
not found.</p>
<p>char.rindex</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.rjust">
<code class="sig-name descname"><span class="pre">rjust</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fillchar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'</span> <span class="pre">'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.rjust" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array with the elements of <cite>self</cite>
right-justified in a string of length <cite>width</cite>.</p>
<p>char.rjust</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.rpartition">
<code class="sig-name descname"><span class="pre">rpartition</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sep</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.rpartition" title="Permalink to this definition">¶</a></dt>
<dd><p>Partition each element in <cite>self</cite> around <cite>sep</cite>.</p>
<p>rpartition</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.rsplit">
<code class="sig-name descname"><span class="pre">rsplit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxsplit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.rsplit" title="Permalink to this definition">¶</a></dt>
<dd><p>For each element in <cite>self</cite>, return a list of the words in
the string, using <cite>sep</cite> as the delimiter string.</p>
<p>char.rsplit</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.rstrip">
<code class="sig-name descname"><span class="pre">rstrip</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.rstrip" title="Permalink to this definition">¶</a></dt>
<dd><p>For each element in <cite>self</cite>, return a copy with the trailing
characters removed.</p>
<p>char.rstrip</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.split">
<code class="sig-name descname"><span class="pre">split</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxsplit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.split" title="Permalink to this definition">¶</a></dt>
<dd><p>For each element in <cite>self</cite>, return a list of the words in the
string, using <cite>sep</cite> as the delimiter string.</p>
<p>char.split</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.splitlines">
<code class="sig-name descname"><span class="pre">splitlines</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">keepends</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.splitlines" title="Permalink to this definition">¶</a></dt>
<dd><p>For each element in <cite>self</cite>, return a list of the lines in the
element, breaking at line boundaries.</p>
<p>char.splitlines</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.startswith">
<code class="sig-name descname"><span class="pre">startswith</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prefix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.startswith" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a boolean array which is <cite>True</cite> where the string element
in <cite>self</cite> starts with <cite>prefix</cite>, otherwise <cite>False</cite>.</p>
<p>char.startswith</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.strip">
<code class="sig-name descname"><span class="pre">strip</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.strip" title="Permalink to this definition">¶</a></dt>
<dd><p>For each element in <cite>self</cite>, return a copy with the leading and
trailing characters removed.</p>
<p>char.strip</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.swapcase">
<code class="sig-name descname"><span class="pre">swapcase</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.swapcase" title="Permalink to this definition">¶</a></dt>
<dd><p>For each element in <cite>self</cite>, return a copy of the string with
uppercase characters converted to lowercase and vice versa.</p>
<p>char.swapcase</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.title">
<code class="sig-name descname"><span class="pre">title</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.title" title="Permalink to this definition">¶</a></dt>
<dd><p>For each element in <cite>self</cite>, return a titlecased version of the
string: words start with uppercase characters, all remaining cased
characters are lowercase.</p>
<p>char.title</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.translate">
<code class="sig-name descname"><span class="pre">translate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">table</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deletechars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.translate" title="Permalink to this definition">¶</a></dt>
<dd><p>For each element in <cite>self</cite>, return a copy of the string where
all characters occurring in the optional argument
<cite>deletechars</cite> are removed, and the remaining characters have
been mapped through the given translation table.</p>
<p>char.translate</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.upper">
<code class="sig-name descname"><span class="pre">upper</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.upper" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array with the elements of <cite>self</cite> converted to
uppercase.</p>
<p>char.upper</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.chararray.zfill">
<code class="sig-name descname"><span class="pre">zfill</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.zfill" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the numeric string left-filled with zeros in a string of
length <cite>width</cite>.</p>
<p>char.zfill</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="numpy.choose">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">choose</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">choices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'raise'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.choose" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct an array from an index array and a list of arrays to choose from.</p>
<p>First of all, if confused or uncertain, definitely look at the Examples -
in its full generality, this function is less simple than it might
seem from the following code description (below ndi =
<cite>numpy.lib.index_tricks</cite>):</p>
<p><code class="docutils literal notranslate"><span class="pre">np.choose(a,c)</span> <span class="pre">==</span> <span class="pre">np.array([c[a[I]][I]</span> <span class="pre">for</span> <span class="pre">I</span> <span class="pre">in</span> <span class="pre">ndi.ndindex(a.shape)])</span></code>.</p>
<p>But this omits some subtleties.  Here is a fully general summary:</p>
<p>Given an “index” array (<cite>a</cite>) of integers and a sequence of <code class="docutils literal notranslate"><span class="pre">n</span></code> arrays
(<cite>choices</cite>), <cite>a</cite> and each choice array are first broadcast, as necessary,
to arrays of a common shape; calling these <em>Ba</em> and <em>Bchoices[i], i =
0,…,n-1</em> we have that, necessarily, <code class="docutils literal notranslate"><span class="pre">Ba.shape</span> <span class="pre">==</span> <span class="pre">Bchoices[i].shape</span></code>
for each <code class="docutils literal notranslate"><span class="pre">i</span></code>.  Then, a new array with shape <code class="docutils literal notranslate"><span class="pre">Ba.shape</span></code> is created as
follows:</p>
<ul class="simple">
<li><p>if <code class="docutils literal notranslate"><span class="pre">mode='raise'</span></code> (the default), then, first of all, each element of
<code class="docutils literal notranslate"><span class="pre">a</span></code> (and thus <code class="docutils literal notranslate"><span class="pre">Ba</span></code>) must be in the range <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">n-1]</span></code>; now, suppose
that <code class="docutils literal notranslate"><span class="pre">i</span></code> (in that range) is the value at the <code class="docutils literal notranslate"><span class="pre">(j0,</span> <span class="pre">j1,</span> <span class="pre">...,</span> <span class="pre">jm)</span></code>
position in <code class="docutils literal notranslate"><span class="pre">Ba</span></code> - then the value at the same position in the new array
is the value in <code class="docutils literal notranslate"><span class="pre">Bchoices[i]</span></code> at that same position;</p></li>
<li><p>if <code class="docutils literal notranslate"><span class="pre">mode='wrap'</span></code>, values in <cite>a</cite> (and thus <cite>Ba</cite>) may be any (signed)
integer; modular arithmetic is used to map integers outside the range
<cite>[0, n-1]</cite> back into that range; and then the new array is constructed
as above;</p></li>
<li><p>if <code class="docutils literal notranslate"><span class="pre">mode='clip'</span></code>, values in <cite>a</cite> (and thus <code class="docutils literal notranslate"><span class="pre">Ba</span></code>) may be any (signed)
integer; negative integers are mapped to 0; values greater than <code class="docutils literal notranslate"><span class="pre">n-1</span></code>
are mapped to <code class="docutils literal notranslate"><span class="pre">n-1</span></code>; and then the new array is constructed as above.</p></li>
</ul>
<dl>
<dt>a<span class="classifier">int array</span></dt><dd><p>This array must contain integers in <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">n-1]</span></code>, where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the
number of choices, unless <code class="docutils literal notranslate"><span class="pre">mode=wrap</span></code> or <code class="docutils literal notranslate"><span class="pre">mode=clip</span></code>, in which
cases any integers are permissible.</p>
</dd>
<dt>choices<span class="classifier">sequence of arrays</span></dt><dd><p>Choice arrays. <cite>a</cite> and all of the choices must be broadcastable to the
same shape.  If <cite>choices</cite> is itself an array (not recommended), then
its outermost dimension (i.e., the one corresponding to
<code class="docutils literal notranslate"><span class="pre">choices.shape[0]</span></code>) is taken as defining the “sequence”.</p>
</dd>
<dt>out<span class="classifier">array, optional</span></dt><dd><p>If provided, the result will be inserted into this array. It should
be of the appropriate shape and dtype. Note that <cite>out</cite> is always
buffered if <code class="docutils literal notranslate"><span class="pre">mode='raise'</span></code>; use other modes for better performance.</p>
</dd>
<dt>mode<span class="classifier">{‘raise’ (default), ‘wrap’, ‘clip’}, optional</span></dt><dd><p>Specifies how indices outside <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">n-1]</span></code> will be treated:</p>
<blockquote>
<div><ul class="simple">
<li><p>‘raise’ : an exception is raised</p></li>
<li><p>‘wrap’ : value becomes value mod <code class="docutils literal notranslate"><span class="pre">n</span></code></p></li>
<li><p>‘clip’ : values &lt; 0 are mapped to 0, values &gt; n-1 are mapped to n-1</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
<dl class="simple">
<dt>merged_array<span class="classifier">array</span></dt><dd><p>The merged result.</p>
</dd>
</dl>
<dl class="simple">
<dt>ValueError: shape mismatch</dt><dd><p>If <cite>a</cite> and each choice array are not all broadcastable to the same
shape.</p>
</dd>
</dl>
<p>ndarray.choose : equivalent method
numpy.take_along_axis : Preferable if <cite>choices</cite> is an array</p>
<p>To reduce the chance of misinterpretation, even though the following
“abuse” is nominally supported, <cite>choices</cite> should neither be, nor be
thought of as, a single array, i.e., the outermost sequence-like container
should be either a list or a tuple.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">choices</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">],</span>
<span class="gp">... </span>  <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">23</span><span class="p">],</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">33</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">choices</span>
<span class="gp">... </span><span class="c1"># the first element of the result will be the first element of the</span>
<span class="gp">... </span><span class="c1"># third (2+1) &quot;array&quot; in choices, namely, 20; the second element</span>
<span class="gp">... </span><span class="c1"># will be the second element of the fourth (3+1) choice array, i.e.,</span>
<span class="gp">... </span><span class="c1"># 31, etc.</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">array([20, 31, 12,  3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">choices</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;clip&#39;</span><span class="p">)</span> <span class="c1"># 4 goes to 3 (4-1)</span>
<span class="go">array([20, 31, 12,  3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># because there are 4 choice arrays</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">choices</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;wrap&#39;</span><span class="p">)</span> <span class="c1"># 4 goes to (4 mod 4)</span>
<span class="go">array([20,  1, 12,  3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># i.e., 0</span>
</pre></div>
</div>
<p>A couple examples illustrating how choose broadcasts:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">choices</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">choices</span><span class="p">)</span>
<span class="go">array([[ 10, -10,  10],</span>
<span class="go">       [-10,  10, -10],</span>
<span class="go">       [ 10, -10,  10]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># With thanks to Anne Archibald</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">))</span> <span class="c1"># result is 2x3x5, res[0,:,:]=c1, res[1,:,:]=c2</span>
<span class="go">array([[[ 1,  1,  1,  1,  1],</span>
<span class="go">        [ 2,  2,  2,  2,  2],</span>
<span class="go">        [ 3,  3,  3,  3,  3]],</span>
<span class="go">       [[-1, -2, -3, -4, -5],</span>
<span class="go">        [-1, -2, -3, -4, -5],</span>
<span class="go">        [-1, -2, -3, -4, -5]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.clip">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">clip</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.clip" title="Permalink to this definition">¶</a></dt>
<dd><p>Clip (limit) the values in an array.</p>
<p>Given an interval, values outside the interval are clipped to
the interval edges.  For example, if an interval of <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1]</span></code>
is specified, values smaller than 0 become 0, and values larger
than 1 become 1.</p>
<p>Equivalent to but faster than <code class="docutils literal notranslate"><span class="pre">np.minimum(a_max,</span> <span class="pre">np.maximum(a,</span> <span class="pre">a_min))</span></code>.</p>
<p>No check is performed to ensure <code class="docutils literal notranslate"><span class="pre">a_min</span> <span class="pre">&lt;</span> <span class="pre">a_max</span></code>.</p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Array containing elements to clip.</p>
</dd>
<dt>a_min, a_max<span class="classifier">array_like or None</span></dt><dd><p>Minimum and maximum value. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, clipping is not performed on
the corresponding edge. Only one of <cite>a_min</cite> and <cite>a_max</cite> may be
<code class="docutils literal notranslate"><span class="pre">None</span></code>. Both are broadcast against <cite>a</cite>.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>The results will be placed in this array. It may be the input
array for in-place clipping.  <cite>out</cite> must be of the right shape
to hold the output.  Its type is preserved.</p>
</dd>
<dt><a href="#id14"><span class="problematic" id="id15">**</span></a>kwargs</dt><dd><p>For other keyword-only arguments, see the
<span class="xref std std-ref">ufunc docs</span>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.17.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>clipped_array<span class="classifier">ndarray</span></dt><dd><p>An array with the elements of <cite>a</cite>, but where values
&lt; <cite>a_min</cite> are replaced with <cite>a_min</cite>, and those &gt; <cite>a_max</cite>
with <cite>a_max</cite>.</p>
</dd>
</dl>
<p><span class="xref std std-ref">ufuncs-output-type</span></p>
<p>When <cite>a_min</cite> is greater than <cite>a_max</cite>, <cite>clip</cite> returns an 
array in which all values are equal to <cite>a_max</cite>, 
as shown in the second example.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">array([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">array([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.clongdouble">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">clongdouble</span></code><a class="headerlink" href="#numpy.clongdouble" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.complex256" title="numpy.complex256"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.complex256</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.clongfloat">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">clongfloat</span></code><a class="headerlink" href="#numpy.clongfloat" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.complex256" title="numpy.complex256"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.complex256</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="numpy.column_stack">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">column_stack</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tup</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.column_stack" title="Permalink to this definition">¶</a></dt>
<dd><p>Stack 1-D arrays as columns into a 2-D array.</p>
<p>Take a sequence of 1-D arrays and stack them as columns
to make a single 2-D array. 2-D arrays are stacked as-is,
just like with <cite>hstack</cite>.  1-D arrays are turned into 2-D columns
first.</p>
<dl class="simple">
<dt>tup<span class="classifier">sequence of 1-D or 2-D arrays.</span></dt><dd><p>Arrays to stack. All of them must have the same first dimension.</p>
</dd>
</dl>
<dl class="simple">
<dt>stacked<span class="classifier">2-D array</span></dt><dd><p>The array formed by stacking the given arrays.</p>
</dd>
</dl>
<p>stack, hstack, vstack, concatenate</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [2, 3],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.common_type">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">common_type</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">arrays</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.common_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a scalar type which is common to the input arrays.</p>
<p>The return type will always be an inexact (i.e. floating point) scalar
type, even if all the arrays are integer arrays. If one of the inputs is
an integer array, the minimum precision type that is returned is a
64-bit floating point dtype.</p>
<p>All input arrays except int64 and uint64 can be safely cast to the
returned dtype without loss of information.</p>
<dl class="simple">
<dt>array1, array2, …<span class="classifier">ndarrays</span></dt><dd><p>Input arrays.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">data type code</span></dt><dd><p>Data type code.</p>
</dd>
</dl>
<p>dtype, mintypecode</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">common_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
<span class="go">&lt;class &#39;numpy.float32&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">common_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">&lt;class &#39;numpy.float64&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">common_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">45</span><span class="p">,</span> <span class="mf">6.</span><span class="n">j</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">45.0</span><span class="p">]))</span>
<span class="go">&lt;class &#39;numpy.complex128&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.compare_chararrays">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">compare_chararrays</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmp_op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rstrip</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.compare_chararrays" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs element-wise comparison of two string arrays using the
comparison operator specified by <cite>cmp_op</cite>.</p>
<dl class="simple">
<dt>a, b<span class="classifier">array_like</span></dt><dd><p>Arrays to be compared.</p>
</dd>
<dt>cmp_op<span class="classifier">{“&lt;”, “&lt;=”, “==”, “&gt;=”, “&gt;”, “!=”}</span></dt><dd><p>Type of comparison.</p>
</dd>
<dt>rstrip<span class="classifier">Boolean</span></dt><dd><p>If True, the spaces at the end of Strings are removed before the comparison.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>The output array of type Boolean with the same shape as a and b.</p>
</dd>
</dl>
<dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>cmp_op</cite> is not valid.</p>
</dd>
<dt>TypeError</dt><dd><p>If at least one of <cite>a</cite> or <cite>b</cite> is a non-string array</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;cde&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;dec&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">compare_chararrays</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">array([False,  True, False])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt id="numpy.complex128">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">complex128</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">real</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.complex128" title="Permalink to this definition">¶</a></dt>
<dd><p>Complex number type composed of two double-precision floating-point
numbers, compatible with Python <cite>complex</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Character code</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">'D'</span></code></p>
</dd>
<dt class="field-even">Canonical name</dt>
<dd class="field-even"><p><cite>numpy.cdouble</cite></p>
</dd>
<dt class="field-odd">Alias</dt>
<dd class="field-odd"><p><cite>numpy.cfloat</cite></p>
</dd>
<dt class="field-even">Alias</dt>
<dd class="field-even"><p><cite>numpy.complex_</cite></p>
</dd>
<dt class="field-odd">Alias on this platform (Linux x86_64)</dt>
<dd class="field-odd"><p><cite>numpy.complex128</cite>: Complex number type composed of 2 64-bit-precision floating-point numbers.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="numpy.complex256">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">complex256</span></code><a class="headerlink" href="#numpy.complex256" title="Permalink to this definition">¶</a></dt>
<dd><p>Complex number type composed of two extended-precision floating-point
numbers.</p>
<dl class="field-list simple">
<dt class="field-odd">Character code</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">'G'</span></code></p>
</dd>
<dt class="field-even">Canonical name</dt>
<dd class="field-even"><p><cite>numpy.clongdouble</cite></p>
</dd>
<dt class="field-odd">Alias</dt>
<dd class="field-odd"><p><cite>numpy.clongfloat</cite></p>
</dd>
<dt class="field-even">Alias</dt>
<dd class="field-even"><p><cite>numpy.longcomplex</cite></p>
</dd>
<dt class="field-odd">Alias on this platform (Linux x86_64)</dt>
<dd class="field-odd"><p><cite>numpy.complex256</cite>: Complex number type composed of 2 128-bit extended-precision floating-point numbers.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="numpy.complex64">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">complex64</span></code><a class="headerlink" href="#numpy.complex64" title="Permalink to this definition">¶</a></dt>
<dd><p>Complex number type composed of two single-precision floating-point
numbers.</p>
<dl class="field-list simple">
<dt class="field-odd">Character code</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">'F'</span></code></p>
</dd>
<dt class="field-even">Canonical name</dt>
<dd class="field-even"><p><cite>numpy.csingle</cite></p>
</dd>
<dt class="field-odd">Alias</dt>
<dd class="field-odd"><p><cite>numpy.singlecomplex</cite></p>
</dd>
<dt class="field-even">Alias on this platform (Linux x86_64)</dt>
<dd class="field-even"><p><cite>numpy.complex64</cite>: Complex number type composed of 2 32-bit-precision floating-point numbers.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.complex_">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">complex_</span></code><a class="headerlink" href="#numpy.complex_" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.complex128" title="numpy.complex128"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.complex128</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt id="numpy.complexfloating">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">complexfloating</span></code><a class="headerlink" href="#numpy.complexfloating" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class of all complex number scalar types that are made up of
floating-point numbers.</p>
</dd></dl>

<dl class="py function">
<dt id="numpy.compress">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">compress</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">condition</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.compress" title="Permalink to this definition">¶</a></dt>
<dd><p>Return selected slices of an array along given axis.</p>
<p>When working along a given axis, a slice along that axis is returned in
<cite>output</cite> for each index where <cite>condition</cite> evaluates to True. When
working on a 1-D array, <cite>compress</cite> is equivalent to <cite>extract</cite>.</p>
<dl class="simple">
<dt>condition<span class="classifier">1-D array of bools</span></dt><dd><p>Array that selects which entries to return. If len(condition)
is less than the size of <cite>a</cite> along the given axis, then output is
truncated to the length of the condition array.</p>
</dd>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Array from which to extract a part.</p>
</dd>
<dt>axis<span class="classifier">int, optional</span></dt><dd><p>Axis along which to take slices. If None (default), work on the
flattened array.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Output array.  Its type is preserved and it must be of the right
shape to hold the output.</p>
</dd>
</dl>
<dl class="simple">
<dt>compressed_array<span class="classifier">ndarray</span></dt><dd><p>A copy of <cite>a</cite> without the slices along axis for which <cite>condition</cite>
is false.</p>
</dd>
</dl>
<p>take, choose, diag, diagonal, select
ndarray.compress : Equivalent method in ndarray
extract : Equivalent method when working on 1-D arrays
<span class="xref std std-ref">ufuncs-output-type</span></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4],</span>
<span class="go">       [5, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">([</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[3, 4],</span>
<span class="go">       [5, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">([</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[2],</span>
<span class="go">       [4],</span>
<span class="go">       [6]])</span>
</pre></div>
</div>
<p>Working on the flattened array does not return slices along an axis but
selects elements.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">([</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="n">a</span><span class="p">)</span>
<span class="go">array([2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.concatenate">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">concatenate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">(a1</span></em>, <em class="sig-param"><span class="pre">a2</span></em>, <em class="sig-param"><span class="pre">...)</span></em>, <em class="sig-param"><span class="pre">axis=0</span></em>, <em class="sig-param"><span class="pre">out=None</span></em>, <em class="sig-param"><span class="pre">dtype=None</span></em>, <em class="sig-param"><span class="pre">casting=&quot;same_kind&quot;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.concatenate" title="Permalink to this definition">¶</a></dt>
<dd><p>Join a sequence of arrays along an existing axis.</p>
<dl>
<dt>a1, a2, …<span class="classifier">sequence of array_like</span></dt><dd><p>The arrays must have the same shape, except in the dimension
corresponding to <cite>axis</cite> (the first, by default).</p>
</dd>
<dt>axis<span class="classifier">int, optional</span></dt><dd><p>The axis along which the arrays will be joined.  If axis is None,
arrays are flattened before use.  Default is 0.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>If provided, the destination to place the result. The shape must be
correct, matching that of what concatenate would have returned if no
out argument were specified.</p>
</dd>
<dt>dtype<span class="classifier">str or dtype</span></dt><dd><p>If provided, the destination array will have this dtype. Cannot be
provided together with <cite>out</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.20.0.</span></p>
</div>
</dd>
<dt>casting<span class="classifier">{‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional</span></dt><dd><p>Controls what kind of data casting may occur. Defaults to ‘same_kind’.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.20.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>res<span class="classifier">ndarray</span></dt><dd><p>The concatenated array.</p>
</dd>
</dl>
<p>ma.concatenate : Concatenate function that preserves input masks.
array_split : Split an array into multiple sub-arrays of equal or</p>
<blockquote>
<div><p>near-equal size.</p>
</div></blockquote>
<p>split : Split array into a list of multiple sub-arrays of equal size.
hsplit : Split array into multiple sub-arrays horizontally (column wise).
vsplit : Split array into multiple sub-arrays vertically (row wise).
dsplit : Split array into multiple sub-arrays along the 3rd axis (depth).
stack : Stack a sequence of arrays along a new axis.
block : Assemble arrays from blocks.
hstack : Stack arrays in sequence horizontally (column wise).
vstack : Stack arrays in sequence vertically (row wise).
dstack : Stack arrays in sequence depth wise (along third dimension).
column_stack : Stack 1-D arrays as columns into a 2-D array.</p>
<p>When one or more of the arrays to be concatenated is a MaskedArray,
this function will return a MaskedArray object instead of an ndarray,
but the input masks are <em>not</em> preserved. In cases where a MaskedArray
is expected as input, use the ma.concatenate function from the masked
array module instead.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4],</span>
<span class="go">       [5, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[1, 2, 5],</span>
<span class="go">       [3, 4, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="go">array([1, 2, 3, 4, 5, 6])</span>
</pre></div>
</div>
<p>This function will not preserve masking of MaskedArray inputs.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">masked_array(data=[0, --, 2],</span>
<span class="go">             mask=[False,  True, False],</span>
<span class="go">       fill_value=999999)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([2, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
<span class="go">masked_array(data=[0, 1, 2, 2, 3, 4],</span>
<span class="go">             mask=False,</span>
<span class="go">       fill_value=999999)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
<span class="go">masked_array(data=[0, --, 2, 2, 3, 4],</span>
<span class="go">             mask=[False,  True, False, False, False, False],</span>
<span class="go">       fill_value=999999)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.convolve">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">convolve</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'full'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.convolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the discrete, linear convolution of two one-dimensional sequences.</p>
<p>The convolution operator is often seen in signal processing, where it
models the effect of a linear time-invariant system on a signal <a href="#id78"><span class="problematic" id="id16">[1]_</span></a>.  In
probability theory, the sum of two independent random variables is
distributed according to the convolution of their individual
distributions.</p>
<p>If <cite>v</cite> is longer than <cite>a</cite>, the arrays are swapped before computation.</p>
<dl class="simple">
<dt>a<span class="classifier">(N,) array_like</span></dt><dd><p>First one-dimensional input array.</p>
</dd>
<dt>v<span class="classifier">(M,) array_like</span></dt><dd><p>Second one-dimensional input array.</p>
</dd>
<dt>mode<span class="classifier">{‘full’, ‘valid’, ‘same’}, optional</span></dt><dd><dl class="simple">
<dt>‘full’:</dt><dd><p>By default, mode is ‘full’.  This returns the convolution
at each point of overlap, with an output shape of (N+M-1,). At
the end-points of the convolution, the signals do not overlap
completely, and boundary effects may be seen.</p>
</dd>
<dt>‘same’:</dt><dd><p>Mode ‘same’ returns output of length <code class="docutils literal notranslate"><span class="pre">max(M,</span> <span class="pre">N)</span></code>.  Boundary
effects are still visible.</p>
</dd>
<dt>‘valid’:</dt><dd><p>Mode ‘valid’ returns output of length
<code class="docutils literal notranslate"><span class="pre">max(M,</span> <span class="pre">N)</span> <span class="pre">-</span> <span class="pre">min(M,</span> <span class="pre">N)</span> <span class="pre">+</span> <span class="pre">1</span></code>.  The convolution product is only given
for points where the signals overlap completely.  Values outside
the signal boundary have no effect.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>Discrete, linear convolution of <cite>a</cite> and <cite>v</cite>.</p>
</dd>
</dl>
<dl class="simple">
<dt>scipy.signal.fftconvolve<span class="classifier">Convolve two arrays using the Fast Fourier</span></dt><dd><p>Transform.</p>
</dd>
</dl>
<p>scipy.linalg.toeplitz : Used to construct the convolution operator.
polymul : Polynomial multiplication. Same output as convolve, but also</p>
<blockquote>
<div><p>accepts poly1d objects as input.</p>
</div></blockquote>
<p>The discrete convolution operation is defined as</p>
<div class="math notranslate nohighlight">
\[(a * v)[n] = \sum_{m = -\infty}^{\infty} a[m] v[n - m]\]</div>
<p>It can be shown that a convolution <span class="math notranslate nohighlight">\(x(t) * y(t)\)</span> in time/space
is equivalent to the multiplication <span class="math notranslate nohighlight">\(X(f) Y(f)\)</span> in the Fourier
domain, after appropriate padding (padding is necessary to prevent
circular convolution).  Since multiplication is more efficient (faster)
than convolution, the function <cite>scipy.signal.fftconvolve</cite> exploits the
FFT to calculate the convolution of large data-sets.</p>
<dl class="footnote brackets">
<dt class="label" id="id17"><span class="brackets">1</span></dt>
<dd><p>Wikipedia, “Convolution”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Convolution">https://en.wikipedia.org/wiki/Convolution</a></p>
</dd>
</dl>
<p>Note how the convolution operator flips the second array
before “sliding” the two across one another:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>
<span class="go">array([0. , 1. , 2.5, 4. , 1.5])</span>
</pre></div>
</div>
<p>Only return the middle values of the convolution.
Contains boundary effects, where zeros are taken
into account:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mf">0.5</span><span class="p">],</span> <span class="s1">&#39;same&#39;</span><span class="p">)</span>
<span class="go">array([1. ,  2.5,  4. ])</span>
</pre></div>
</div>
<p>The two arrays are of the same length, so there
is only one position where they completely overlap:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mf">0.5</span><span class="p">],</span> <span class="s1">&#39;valid&#39;</span><span class="p">)</span>
<span class="go">array([2.5])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.copy">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">copy</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'K'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subok</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array copy of the given object.</p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input data.</p>
</dd>
<dt>order<span class="classifier">{‘C’, ‘F’, ‘A’, ‘K’}, optional</span></dt><dd><p>Controls the memory layout of the copy. ‘C’ means C-order,
‘F’ means F-order, ‘A’ means ‘F’ if <cite>a</cite> is Fortran contiguous,
‘C’ otherwise. ‘K’ means match the layout of <cite>a</cite> as closely
as possible. (Note that this function and <a class="reference internal" href="#numpy.ndarray.copy" title="numpy.ndarray.copy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ndarray.copy()</span></code></a> are very
similar, but have different default values for their order=
arguments.)</p>
</dd>
<dt>subok<span class="classifier">bool, optional</span></dt><dd><p>If True, then sub-classes will be passed-through, otherwise the
returned array will be forced to be a base-class array (defaults to False).</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.19.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>arr<span class="classifier">ndarray</span></dt><dd><p>Array interpretation of <cite>a</cite>.</p>
</dd>
</dl>
<p>ndarray.copy : Preferred method for creating an array copy</p>
<p>This is equivalent to:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
</pre></div>
</div>
<p>Create an array x, with a reference y and a copy z:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that, when we modify x, y changes, but not z:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Note that np.copy is a shallow copy and will not copy object
elements within arrays. This is mainly important for arrays
containing Python objects. The new array will contain the
same object which may lead to surprises if that object can
be modified (is mutable):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([1, &#39;m&#39;, list([10, 3, 4])], dtype=object)</span>
</pre></div>
</div>
<p>To ensure all elements within an <code class="docutils literal notranslate"><span class="pre">object</span></code> array are copied,
use <cite>copy.deepcopy</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">copy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">array([1, &#39;m&#39;, list([10, 3, 4])], dtype=object)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([1, &#39;m&#39;, list([2, 3, 4])], dtype=object)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.copyto">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">copyto</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">casting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'same_kind'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">where</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.copyto" title="Permalink to this definition">¶</a></dt>
<dd><p>Copies values from one array to another, broadcasting as necessary.</p>
<p>Raises a TypeError if the <cite>casting</cite> rule is violated, and if
<cite>where</cite> is provided, it selects which elements to copy.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<dl>
<dt>dst<span class="classifier">ndarray</span></dt><dd><p>The array into which values are copied.</p>
</dd>
<dt>src<span class="classifier">array_like</span></dt><dd><p>The array from which values are copied.</p>
</dd>
<dt>casting<span class="classifier">{‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional</span></dt><dd><p>Controls what kind of data casting may occur when copying.</p>
<blockquote>
<div><ul class="simple">
<li><p>‘no’ means the data types should not be cast at all.</p></li>
<li><p>‘equiv’ means only byte-order changes are allowed.</p></li>
<li><p>‘safe’ means only casts which can preserve values are allowed.</p></li>
<li><p>‘same_kind’ means only safe casts or casts within a kind,
like float64 to float32, are allowed.</p></li>
<li><p>‘unsafe’ means any data conversions may be done.</p></li>
</ul>
</div></blockquote>
</dd>
<dt>where<span class="classifier">array_like of bool, optional</span></dt><dd><p>A boolean array which is broadcasted to match the dimensions
of <cite>dst</cite>, and selects elements to copy from <cite>src</cite> to <cite>dst</cite>
wherever it contains the value True.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="numpy.corrcoef">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">corrcoef</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">x</span></em>, <em class="sig-param"><span class="pre">y=None</span></em>, <em class="sig-param"><span class="pre">rowvar=True</span></em>, <em class="sig-param"><span class="pre">bias=&lt;no</span> <span class="pre">value&gt;</span></em>, <em class="sig-param"><span class="pre">ddof=&lt;no</span> <span class="pre">value&gt;</span></em>, <em class="sig-param"><span class="pre">*</span></em>, <em class="sig-param"><span class="pre">dtype=None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.corrcoef" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Pearson product-moment correlation coefficients.</p>
<p>Please refer to the documentation for <cite>cov</cite> for more detail.  The
relationship between the correlation coefficient matrix, <cite>R</cite>, and the
covariance matrix, <cite>C</cite>, is</p>
<div class="math notranslate nohighlight">
\[R_{ij} = \frac{ C_{ij} } { \sqrt{ C_{ii} * C_{jj} } }\]</div>
<p>The values of <cite>R</cite> are between -1 and 1, inclusive.</p>
<dl>
<dt>x<span class="classifier">array_like</span></dt><dd><p>A 1-D or 2-D array containing multiple variables and observations.
Each row of <cite>x</cite> represents a variable, and each column a single
observation of all those variables. Also see <cite>rowvar</cite> below.</p>
</dd>
<dt>y<span class="classifier">array_like, optional</span></dt><dd><p>An additional set of variables and observations. <cite>y</cite> has the same
shape as <cite>x</cite>.</p>
</dd>
<dt>rowvar<span class="classifier">bool, optional</span></dt><dd><p>If <cite>rowvar</cite> is True (default), then each row represents a
variable, with observations in the columns. Otherwise, the relationship
is transposed: each column represents a variable, while the rows
contain observations.</p>
</dd>
<dt>bias<span class="classifier">_NoValue, optional</span></dt><dd><p>Has no effect, do not use.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 1.10.0.</span></p>
</div>
</dd>
<dt>ddof<span class="classifier">_NoValue, optional</span></dt><dd><p>Has no effect, do not use.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 1.10.0.</span></p>
</div>
</dd>
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>Data-type of the result. By default, the return data-type will have
at least <cite>numpy.float64</cite> precision.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.20.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>R<span class="classifier">ndarray</span></dt><dd><p>The correlation coefficient matrix of the variables.</p>
</dd>
</dl>
<p>cov : Covariance matrix</p>
<p>Due to floating point rounding the resulting array may not be Hermitian,
the diagonal elements may not be 1, and the elements may not satisfy the
inequality abs(a) &lt;= 1. The real and imaginary parts are clipped to the
interval [-1,  1] in an attempt to improve on that situation but is not
much help in the complex case.</p>
<p>This function accepts but discards arguments <cite>bias</cite> and <cite>ddof</cite>.  This is
for backwards compatibility with previous versions of this function.  These
arguments had no effect on the return values of the function and can be
safely ignored in this and previous versions of numpy.</p>
<p>In this example we generate two random arrays, <code class="docutils literal notranslate"><span class="pre">xarr</span></code> and <code class="docutils literal notranslate"><span class="pre">yarr</span></code>, and
compute the row-wise and column-wise Pearson correlation coefficients,
<code class="docutils literal notranslate"><span class="pre">R</span></code>. Since <code class="docutils literal notranslate"><span class="pre">rowvar</span></code> is  true by  default, we first find the row-wise
Pearson correlation coefficients between the variables of <code class="docutils literal notranslate"><span class="pre">xarr</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xarr</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xarr</span>
<span class="go">array([[0.77395605, 0.43887844, 0.85859792],</span>
<span class="go">       [0.69736803, 0.09417735, 0.97562235],</span>
<span class="go">       [0.7611397 , 0.78606431, 0.12811363]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">xarr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R1</span>
<span class="go">array([[ 1.        ,  0.99256089, -0.68080986],</span>
<span class="go">       [ 0.99256089,  1.        , -0.76492172],</span>
<span class="go">       [-0.68080986, -0.76492172,  1.        ]])</span>
</pre></div>
</div>
<p>If we add another set of variables and observations <code class="docutils literal notranslate"><span class="pre">yarr</span></code>, we can
compute the row-wise Pearson correlation coefficients between the
variables in <code class="docutils literal notranslate"><span class="pre">xarr</span></code> and <code class="docutils literal notranslate"><span class="pre">yarr</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">yarr</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yarr</span>
<span class="go">array([[0.45038594, 0.37079802, 0.92676499],</span>
<span class="go">       [0.64386512, 0.82276161, 0.4434142 ],</span>
<span class="go">       [0.22723872, 0.55458479, 0.06381726]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">xarr</span><span class="p">,</span> <span class="n">yarr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R2</span>
<span class="go">array([[ 1.        ,  0.99256089, -0.68080986,  0.75008178, -0.934284  ,</span>
<span class="go">        -0.99004057],</span>
<span class="go">       [ 0.99256089,  1.        , -0.76492172,  0.82502011, -0.97074098,</span>
<span class="go">        -0.99981569],</span>
<span class="go">       [-0.68080986, -0.76492172,  1.        , -0.99507202,  0.89721355,</span>
<span class="go">         0.77714685],</span>
<span class="go">       [ 0.75008178,  0.82502011, -0.99507202,  1.        , -0.93657855,</span>
<span class="go">        -0.83571711],</span>
<span class="go">       [-0.934284  , -0.97074098,  0.89721355, -0.93657855,  1.        ,</span>
<span class="go">         0.97517215],</span>
<span class="go">       [-0.99004057, -0.99981569,  0.77714685, -0.83571711,  0.97517215,</span>
<span class="go">         1.        ]])</span>
</pre></div>
</div>
<p>Finally if we use the option <code class="docutils literal notranslate"><span class="pre">rowvar=False</span></code>, the columns are now
being treated as the variables and we will find the column-wise Pearson
correlation coefficients between variables in <code class="docutils literal notranslate"><span class="pre">xarr</span></code> and <code class="docutils literal notranslate"><span class="pre">yarr</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">R3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">xarr</span><span class="p">,</span> <span class="n">yarr</span><span class="p">,</span> <span class="n">rowvar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R3</span>
<span class="go">array([[ 1.        ,  0.77598074, -0.47458546, -0.75078643, -0.9665554 ,</span>
<span class="go">         0.22423734],</span>
<span class="go">       [ 0.77598074,  1.        , -0.92346708, -0.99923895, -0.58826587,</span>
<span class="go">        -0.44069024],</span>
<span class="go">       [-0.47458546, -0.92346708,  1.        ,  0.93773029,  0.23297648,</span>
<span class="go">         0.75137473],</span>
<span class="go">       [-0.75078643, -0.99923895,  0.93773029,  1.        ,  0.55627469,</span>
<span class="go">         0.47536961],</span>
<span class="go">       [-0.9665554 , -0.58826587,  0.23297648,  0.55627469,  1.        ,</span>
<span class="go">        -0.46666491],</span>
<span class="go">       [ 0.22423734, -0.44069024,  0.75137473,  0.47536961, -0.46666491,</span>
<span class="go">         1.        ]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.correlate">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">correlate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'valid'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.correlate" title="Permalink to this definition">¶</a></dt>
<dd><p>Cross-correlation of two 1-dimensional sequences.</p>
<p>This function computes the correlation as generally defined in signal
processing texts:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">c_</span><span class="p">{</span><span class="n">av</span><span class="p">}[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum_n</span> <span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">conj</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
</pre></div>
</div>
<p>with a and v sequences being zero-padded where necessary and conj being
the conjugate.</p>
<dl class="simple">
<dt>a, v<span class="classifier">array_like</span></dt><dd><p>Input sequences.</p>
</dd>
<dt>mode<span class="classifier">{‘valid’, ‘same’, ‘full’}, optional</span></dt><dd><p>Refer to the <cite>convolve</cite> docstring.  Note that the default
is ‘valid’, unlike <cite>convolve</cite>, which uses ‘full’.</p>
</dd>
<dt>old_behavior<span class="classifier">bool</span></dt><dd><p><cite>old_behavior</cite> was removed in NumPy 1.10. If you need the old
behavior, use <cite>multiarray.correlate</cite>.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>Discrete cross-correlation of <cite>a</cite> and <cite>v</cite>.</p>
</dd>
</dl>
<p>convolve : Discrete, linear convolution of two one-dimensional sequences.
multiarray.correlate : Old, no conjugate, version of correlate.
scipy.signal.correlate : uses FFT which has superior performance on large arrays.</p>
<p>The definition of correlation above is not unique and sometimes correlation
may be defined differently. Another common definition is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">c</span><span class="s1">&#39;_</span><span class="si">{av}</span><span class="s1">[k] = sum_n a[n] conj(v[n+k])</span>
</pre></div>
</div>
<p>which is related to <code class="docutils literal notranslate"><span class="pre">c_{av}[k]</span></code> by <code class="docutils literal notranslate"><span class="pre">c'_{av}[k]</span> <span class="pre">=</span> <span class="pre">c_{av}[-k]</span></code>.</p>
<p><cite>numpy.correlate</cite> may perform slowly in large arrays (i.e. n = 1e5) because it does
not use the FFT to compute the convolution; in that case, <cite>scipy.signal.correlate</cite> might
be preferable.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>
<span class="go">array([3.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="s2">&quot;same&quot;</span><span class="p">)</span>
<span class="go">array([2. ,  3.5,  3. ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="s2">&quot;full&quot;</span><span class="p">)</span>
<span class="go">array([0.5,  2. ,  3.5,  3. ,  0. ])</span>
</pre></div>
</div>
<p>Using complex sequences:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">([</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="n">j</span><span class="p">],</span> <span class="s1">&#39;full&#39;</span><span class="p">)</span>
<span class="go">array([ 0.5-0.5j,  1.0+0.j ,  1.5-1.5j,  3.0-1.j ,  0.0+0.j ])</span>
</pre></div>
</div>
<p>Note that you get the time reversed, complex conjugated result
when the two input sequences change places, i.e.,
<code class="docutils literal notranslate"><span class="pre">c_{va}[k]</span> <span class="pre">=</span> <span class="pre">c^{*}_{av}[-k]</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="n">j</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">],</span> <span class="s1">&#39;full&#39;</span><span class="p">)</span>
<span class="go">array([ 0.0+0.j ,  3.0+1.j ,  1.5+1.5j,  1.0+0.j ,  0.5+0.5j])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.count_nonzero">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">count_nonzero</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keepdims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.count_nonzero" title="Permalink to this definition">¶</a></dt>
<dd><p>Counts the number of non-zero values in the array <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<p>The word “non-zero” is in reference to the Python 2.x
built-in method <code class="docutils literal notranslate"><span class="pre">__nonzero__()</span></code> (renamed <code class="docutils literal notranslate"><span class="pre">__bool__()</span></code>
in Python 3.x) of Python objects that tests an object’s
“truthfulness”. For example, any number is considered
truthful if it is nonzero, whereas any string is considered
truthful if it is not the empty string. Thus, this function
(recursively) counts how many elements in <code class="docutils literal notranslate"><span class="pre">a</span></code> (and in
sub-arrays thereof) have their <code class="docutils literal notranslate"><span class="pre">__nonzero__()</span></code> or <code class="docutils literal notranslate"><span class="pre">__bool__()</span></code>
method evaluated to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>The array for which to count non-zeros.</p>
</dd>
<dt>axis<span class="classifier">int or tuple, optional</span></dt><dd><p>Axis or tuple of axes along which to count non-zeros.
Default is None, meaning that non-zeros will be counted
along a flattened version of <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.12.0.</span></p>
</div>
</dd>
<dt>keepdims<span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes that are counted are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.19.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>count<span class="classifier">int or array of int</span></dt><dd><p>Number of non-zero values in the array along a given axis.
Otherwise, the total number of non-zero values in the array
is returned.</p>
</dd>
</dl>
<p>nonzero : Return the coordinates of all the non-zero values.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">19</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([1, 1, 2, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([2, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([[2],</span>
<span class="go">       [3]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.cov">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">cov</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rowvar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ddof</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fweights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aweights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.cov" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate a covariance matrix, given data and weights.</p>
<p>Covariance indicates the level to which two variables vary together.
If we examine N-dimensional samples, <span class="math notranslate nohighlight">\(X = [x_1, x_2, ... x_N]^T\)</span>,
then the covariance matrix element <span class="math notranslate nohighlight">\(C_{ij}\)</span> is the covariance of
<span class="math notranslate nohighlight">\(x_i\)</span> and <span class="math notranslate nohighlight">\(x_j\)</span>. The element <span class="math notranslate nohighlight">\(C_{ii}\)</span> is the variance
of <span class="math notranslate nohighlight">\(x_i\)</span>.</p>
<p>See the notes for an outline of the algorithm.</p>
<dl>
<dt>m<span class="classifier">array_like</span></dt><dd><p>A 1-D or 2-D array containing multiple variables and observations.
Each row of <cite>m</cite> represents a variable, and each column a single
observation of all those variables. Also see <cite>rowvar</cite> below.</p>
</dd>
<dt>y<span class="classifier">array_like, optional</span></dt><dd><p>An additional set of variables and observations. <cite>y</cite> has the same form
as that of <cite>m</cite>.</p>
</dd>
<dt>rowvar<span class="classifier">bool, optional</span></dt><dd><p>If <cite>rowvar</cite> is True (default), then each row represents a
variable, with observations in the columns. Otherwise, the relationship
is transposed: each column represents a variable, while the rows
contain observations.</p>
</dd>
<dt>bias<span class="classifier">bool, optional</span></dt><dd><p>Default normalization (False) is by <code class="docutils literal notranslate"><span class="pre">(N</span> <span class="pre">-</span> <span class="pre">1)</span></code>, where <code class="docutils literal notranslate"><span class="pre">N</span></code> is the
number of observations given (unbiased estimate). If <cite>bias</cite> is True,
then normalization is by <code class="docutils literal notranslate"><span class="pre">N</span></code>. These values can be overridden by using
the keyword <code class="docutils literal notranslate"><span class="pre">ddof</span></code> in numpy versions &gt;= 1.5.</p>
</dd>
<dt>ddof<span class="classifier">int, optional</span></dt><dd><p>If not <code class="docutils literal notranslate"><span class="pre">None</span></code> the default value implied by <cite>bias</cite> is overridden.
Note that <code class="docutils literal notranslate"><span class="pre">ddof=1</span></code> will return the unbiased estimate, even if both
<cite>fweights</cite> and <cite>aweights</cite> are specified, and <code class="docutils literal notranslate"><span class="pre">ddof=0</span></code> will return
the simple average. See the notes for the details. The default value
is <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.5.</span></p>
</div>
</dd>
<dt>fweights<span class="classifier">array_like, int, optional</span></dt><dd><p>1-D array of integer frequency weights; the number of times each
observation vector should be repeated.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.</span></p>
</div>
</dd>
<dt>aweights<span class="classifier">array_like, optional</span></dt><dd><p>1-D array of observation vector weights. These relative weights are
typically large for observations considered “important” and smaller for
observations considered less “important”. If <code class="docutils literal notranslate"><span class="pre">ddof=0</span></code> the array of
weights can be used to assign probabilities to observation vectors.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.</span></p>
</div>
</dd>
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>Data-type of the result. By default, the return data-type will have
at least <cite>numpy.float64</cite> precision.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.20.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>The covariance matrix of the variables.</p>
</dd>
</dl>
<p>corrcoef : Normalized covariance matrix</p>
<p>Assume that the observations are in the columns of the observation
array <cite>m</cite> and let <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">fweights</span></code> and <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">aweights</span></code> for brevity. The
steps to compute the weighted covariance are as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">**</span> <span class="mf">2.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ddof</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">/</span> <span class="n">v1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">v1</span> <span class="o">/</span> <span class="p">(</span><span class="n">v1</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">ddof</span> <span class="o">*</span> <span class="n">v2</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that when <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">1</span></code>, the normalization factor
<code class="docutils literal notranslate"><span class="pre">v1</span> <span class="pre">/</span> <span class="pre">(v1**2</span> <span class="pre">-</span> <span class="pre">ddof</span> <span class="pre">*</span> <span class="pre">v2)</span></code> goes over to <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">/</span> <span class="pre">(np.sum(f)</span> <span class="pre">-</span> <span class="pre">ddof)</span></code>
as it should.</p>
<p>Consider two variables, <span class="math notranslate nohighlight">\(x_0\)</span> and <span class="math notranslate nohighlight">\(x_1\)</span>, which
correlate perfectly, but in opposite directions:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [2, 1, 0]])</span>
</pre></div>
</div>
<p>Note how <span class="math notranslate nohighlight">\(x_0\)</span> increases while <span class="math notranslate nohighlight">\(x_1\)</span> decreases. The covariance
matrix shows this clearly:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([[ 1., -1.],</span>
<span class="go">       [-1.,  1.]])</span>
</pre></div>
</div>
<p>Note that element <span class="math notranslate nohighlight">\(C_{0,1}\)</span>, which shows the correlation between
<span class="math notranslate nohighlight">\(x_0\)</span> and <span class="math notranslate nohighlight">\(x_1\)</span>, is negative.</p>
<p>Further, note how <cite>x</cite> and <cite>y</cite> are combined:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">2.1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mf">4.3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span>  <span class="mf">1.1</span><span class="p">,</span>  <span class="mf">0.12</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">array([[11.71      , -4.286     ], # may vary</span>
<span class="go">       [-4.286     ,  2.144133]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">array([[11.71      , -4.286     ], # may vary</span>
<span class="go">       [-4.286     ,  2.144133]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array(11.71)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.cross">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">cross</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axisa</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axisb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axisc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.cross" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cross product of two (arrays of) vectors.</p>
<p>The cross product of <cite>a</cite> and <cite>b</cite> in <span class="math notranslate nohighlight">\(R^3\)</span> is a vector perpendicular
to both <cite>a</cite> and <cite>b</cite>.  If <cite>a</cite> and <cite>b</cite> are arrays of vectors, the vectors
are defined by the last axis of <cite>a</cite> and <cite>b</cite> by default, and these axes
can have dimensions 2 or 3.  Where the dimension of either <cite>a</cite> or <cite>b</cite> is
2, the third component of the input vector is assumed to be zero and the
cross product calculated accordingly.  In cases where both input vectors
have dimension 2, the z-component of the cross product is returned.</p>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>Components of the first vector(s).</p>
</dd>
<dt>b<span class="classifier">array_like</span></dt><dd><p>Components of the second vector(s).</p>
</dd>
<dt>axisa<span class="classifier">int, optional</span></dt><dd><p>Axis of <cite>a</cite> that defines the vector(s).  By default, the last axis.</p>
</dd>
<dt>axisb<span class="classifier">int, optional</span></dt><dd><p>Axis of <cite>b</cite> that defines the vector(s).  By default, the last axis.</p>
</dd>
<dt>axisc<span class="classifier">int, optional</span></dt><dd><p>Axis of <cite>c</cite> containing the cross product vector(s).  Ignored if
both input vectors have dimension 2, as the return is scalar.
By default, the last axis.</p>
</dd>
<dt>axis<span class="classifier">int, optional</span></dt><dd><p>If defined, the axis of <cite>a</cite>, <cite>b</cite> and <cite>c</cite> that defines the vector(s)
and cross product(s).  Overrides <cite>axisa</cite>, <cite>axisb</cite> and <cite>axisc</cite>.</p>
</dd>
</dl>
<dl class="simple">
<dt>c<span class="classifier">ndarray</span></dt><dd><p>Vector cross product(s).</p>
</dd>
</dl>
<dl class="simple">
<dt>ValueError</dt><dd><p>When the dimension of the vector(s) in <cite>a</cite> and/or <cite>b</cite> does not
equal 2 or 3.</p>
</dd>
</dl>
<p>inner : Inner product
outer : Outer product.
<a href="#id79"><span class="problematic" id="id80">ix_</span></a> : Construct index arrays.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.9.0.</span></p>
</div>
<p>Supports full broadcasting of the inputs.</p>
<p>Vector cross-product.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">array([-3,  6, -3])</span>
</pre></div>
</div>
<p>One vector with dimension 2.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">array([12, -6, -3])</span>
</pre></div>
</div>
<p>Equivalently:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">array([12, -6, -3])</span>
</pre></div>
</div>
<p>Both vectors with dimension 2.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">array(-3)</span>
</pre></div>
</div>
<p>Multiple vector cross-products. Note that the direction of the cross
product vector is defined by the <cite>right-hand rule</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">array([[-3,  6, -3],</span>
<span class="go">       [ 3, -6,  3]])</span>
</pre></div>
</div>
<p>The orientation of <cite>c</cite> can be changed using the <cite>axisc</cite> keyword.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">axisc</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[-3,  3],</span>
<span class="go">       [ 6, -6],</span>
<span class="go">       [-3,  3]])</span>
</pre></div>
</div>
<p>Change the vector definition of <cite>x</cite> and <cite>y</cite> using <cite>axisa</cite> and <cite>axisb</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">array([[ -6,  12,  -6],</span>
<span class="go">       [  0,   0,   0],</span>
<span class="go">       [  6, -12,   6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">axisa</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axisb</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[-24,  48, -24],</span>
<span class="go">       [-30,  60, -30],</span>
<span class="go">       [-36,  72, -36]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.csingle">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">csingle</span></code><a class="headerlink" href="#numpy.csingle" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.complex64" title="numpy.complex64"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.complex64</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="numpy.cumprod">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">cumprod</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.cumprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cumulative product of elements along a given axis.</p>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt>axis<span class="classifier">int, optional</span></dt><dd><p>Axis along which the cumulative product is computed.  By default
the input is flattened.</p>
</dd>
<dt>dtype<span class="classifier">dtype, optional</span></dt><dd><p>Type of the returned array, as well as of the accumulator in which
the elements are multiplied.  If <em>dtype</em> is not specified, it
defaults to the dtype of <cite>a</cite>, unless <cite>a</cite> has an integer dtype with
a precision less than that of the default platform integer.  In
that case, the default platform integer is used instead.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output
but the type of the resulting values will be cast if necessary.</p>
</dd>
</dl>
<dl class="simple">
<dt>cumprod<span class="classifier">ndarray</span></dt><dd><p>A new array holding the result is returned unless <cite>out</cite> is
specified, in which case a reference to out is returned.</p>
</dd>
</dl>
<p><span class="xref std std-ref">ufuncs-output-type</span></p>
<p>Arithmetic is modular when using integer types, and no error is
raised on overflow.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c1"># intermediate results 1, 1*2</span>
<span class="gp">... </span>              <span class="c1"># total product 1*2*3 = 6</span>
<span class="go">array([1, 2, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="c1"># specify type of output</span>
<span class="go">array([   1.,    2.,    6.,   24.,  120.,  720.])</span>
</pre></div>
</div>
<p>The cumulative product for each column (i.e., over the rows) of <cite>a</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[ 1,  2,  3],</span>
<span class="go">       [ 4, 10, 18]])</span>
</pre></div>
</div>
<p>The cumulative product for each row (i.e. over the columns) of <cite>a</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[  1,   2,   6],</span>
<span class="go">       [  4,  20, 120]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.cumproduct">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">cumproduct</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.cumproduct" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cumulative product over the given axis.</p>
<p>cumprod : equivalent function; see for details.</p>
</dd></dl>

<dl class="py function">
<dt id="numpy.cumsum">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">cumsum</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.cumsum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cumulative sum of the elements along a given axis.</p>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt>axis<span class="classifier">int, optional</span></dt><dd><p>Axis along which the cumulative sum is computed. The default
(None) is to compute the cumsum over the flattened array.</p>
</dd>
<dt>dtype<span class="classifier">dtype, optional</span></dt><dd><p>Type of the returned array and of the accumulator in which the
elements are summed.  If <cite>dtype</cite> is not specified, it defaults
to the dtype of <cite>a</cite>, unless <cite>a</cite> has an integer dtype with a
precision less than that of the default platform integer.  In
that case, the default platform integer is used.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output
but the type will be cast if necessary. See <span class="xref std std-ref">ufuncs-output-type</span> for
more details.</p>
</dd>
</dl>
<dl class="simple">
<dt>cumsum_along_axis<span class="classifier">ndarray.</span></dt><dd><p>A new array holding the result is returned unless <cite>out</cite> is
specified, in which case a reference to <cite>out</cite> is returned. The
result has the same size as <cite>a</cite>, and the same shape as <cite>a</cite> if
<cite>axis</cite> is not None or <cite>a</cite> is a 1-d array.</p>
</dd>
</dl>
<p>sum : Sum array elements.
trapz : Integration of array values using the composite trapezoidal rule.
diff : Calculate the n-th discrete difference along given axis.</p>
<p>Arithmetic is modular when using integer types, and no error is
raised on overflow.</p>
<p><code class="docutils literal notranslate"><span class="pre">cumsum(a)[-1]</span></code> may not be equal to <code class="docutils literal notranslate"><span class="pre">sum(a)</span></code> for floating-point
values since <code class="docutils literal notranslate"><span class="pre">sum</span></code> may use a pairwise summation routine, reducing
the roundoff-error. See <cite>sum</cite> for more information.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [4, 5, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([ 1,  3,  6, 10, 15, 21])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>     <span class="c1"># specifies type of output value(s)</span>
<span class="go">array([  1.,   3.,   6.,  10.,  15.,  21.])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>      <span class="c1"># sum over rows for each of the 3 columns</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [5, 7, 9]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>      <span class="c1"># sum over columns for each of the 2 rows</span>
<span class="go">array([[ 1,  3,  6],</span>
<span class="go">       [ 4,  9, 15]])</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">cumsum(b)[-1]</span></code> may not be equal to <code class="docutils literal notranslate"><span class="pre">sum(b)</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2e-9</span><span class="p">,</span> <span class="mf">3e-9</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1000000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">1000000.0050045159</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>                    
<span class="go">1000000.0050000029</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt id="numpy.datetime64">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">datetime64</span></code><a class="headerlink" href="#numpy.datetime64" title="Permalink to this definition">¶</a></dt>
<dd><p>If created from a 64-bit integer, it represents an offset from
<code class="docutils literal notranslate"><span class="pre">1970-01-01T00:00:00</span></code>.
If created from string, the string can be in ISO 8601 date
or datetime format.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">)</span>
<span class="go">numpy.datetime64(&#39;1980&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">&#39;1980&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">)</span>
<span class="go">numpy.datetime64(&#39;1980&#39;)   </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">)</span>
<span class="go">numpy.datetime64(&#39;1970-01-11&#39;)</span>
</pre></div>
</div>
<p>See <span class="xref std std-ref">arrays.datetime</span> for more information.</p>
<dl class="field-list simple">
<dt class="field-odd">Character code</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">'M'</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="numpy.datetime_as_string">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">datetime_as_string</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timezone</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'naive'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">casting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'same_kind'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.datetime_as_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an array of datetimes into an array of strings.</p>
<dl class="simple">
<dt>arr<span class="classifier">array_like of datetime64</span></dt><dd><p>The array of UTC timestamps to format.</p>
</dd>
<dt>unit<span class="classifier">str</span></dt><dd><p>One of None, ‘auto’, or a <span class="xref std std-ref">datetime unit</span>.</p>
</dd>
<dt>timezone<span class="classifier">{‘naive’, ‘UTC’, ‘local’} or tzinfo</span></dt><dd><p>Timezone information to use when displaying the datetime. If ‘UTC’, end
with a Z to indicate UTC time. If ‘local’, convert to the local timezone
first, and suffix with a +-#### timezone offset. If a tzinfo object,
then do as with ‘local’, but use the specified timezone.</p>
</dd>
<dt>casting<span class="classifier">{‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}</span></dt><dd><p>Casting to allow when changing between datetime units.</p>
</dd>
</dl>
<dl class="simple">
<dt>str_arr<span class="classifier">ndarray</span></dt><dd><p>An array of strings the same shape as <cite>arr</cite>.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pytz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="s1">&#39;2002-10-27T04:30&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="mi">60</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;M8[m]&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>
<span class="go">array([&#39;2002-10-27T04:30&#39;, &#39;2002-10-27T05:30&#39;, &#39;2002-10-27T06:30&#39;,</span>
<span class="go">       &#39;2002-10-27T07:30&#39;], dtype=&#39;datetime64[m]&#39;)</span>
</pre></div>
</div>
<p>Setting the timezone to UTC shows the same information, but with a Z suffix</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">datetime_as_string</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">timezone</span><span class="o">=</span><span class="s1">&#39;UTC&#39;</span><span class="p">)</span>
<span class="go">array([&#39;2002-10-27T04:30Z&#39;, &#39;2002-10-27T05:30Z&#39;, &#39;2002-10-27T06:30Z&#39;,</span>
<span class="go">       &#39;2002-10-27T07:30Z&#39;], dtype=&#39;&lt;U35&#39;)</span>
</pre></div>
</div>
<p>Note that we picked datetimes that cross a DST boundary. Passing in a
<code class="docutils literal notranslate"><span class="pre">pytz</span></code> timezone object will print the appropriate offset</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">datetime_as_string</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">timezone</span><span class="o">=</span><span class="n">pytz</span><span class="o">.</span><span class="n">timezone</span><span class="p">(</span><span class="s1">&#39;US/Eastern&#39;</span><span class="p">))</span>
<span class="go">array([&#39;2002-10-27T00:30-0400&#39;, &#39;2002-10-27T01:30-0400&#39;,</span>
<span class="go">       &#39;2002-10-27T01:30-0500&#39;, &#39;2002-10-27T02:30-0500&#39;], dtype=&#39;&lt;U39&#39;)</span>
</pre></div>
</div>
<p>Passing in a unit will change the precision</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">datetime_as_string</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;h&#39;</span><span class="p">)</span>
<span class="go">array([&#39;2002-10-27T04&#39;, &#39;2002-10-27T05&#39;, &#39;2002-10-27T06&#39;, &#39;2002-10-27T07&#39;],</span>
<span class="go">      dtype=&#39;&lt;U32&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">datetime_as_string</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">)</span>
<span class="go">array([&#39;2002-10-27T04:30:00&#39;, &#39;2002-10-27T05:30:00&#39;, &#39;2002-10-27T06:30:00&#39;,</span>
<span class="go">       &#39;2002-10-27T07:30:00&#39;], dtype=&#39;&lt;U38&#39;)</span>
</pre></div>
</div>
<p>‘casting’ can be used to specify whether precision can be changed</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">datetime_as_string</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;h&#39;</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;safe&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">TypeError</span>: <span class="n">Cannot create a datetime string as units &#39;h&#39; from a NumPy</span>
<span class="go">datetime with units &#39;m&#39; according to the rule &#39;safe&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.datetime_data">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">datetime_data</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dtype</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.datetime_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Get information about the step size of a date or time type.</p>
<p>The returned tuple can be passed as the second argument of <cite>numpy.datetime64</cite> and
<cite>numpy.timedelta64</cite>.</p>
<dl class="simple">
<dt>dtype<span class="classifier">dtype</span></dt><dd><p>The dtype object, which must be a <cite>datetime64</cite> or <cite>timedelta64</cite> type.</p>
</dd>
</dl>
<dl class="simple">
<dt>unit<span class="classifier">str</span></dt><dd><p>The <span class="xref std std-ref">datetime unit</span> on which this dtype
is based.</p>
</dd>
<dt>count<span class="classifier">int</span></dt><dd><p>The number of base units in a step.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt_25s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;timedelta64[25s]&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">datetime_data</span><span class="p">(</span><span class="n">dt_25s</span><span class="p">)</span>
<span class="go">(&#39;s&#39;, 25)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">dt_25s</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;timedelta64[s]&#39;</span><span class="p">)</span>
<span class="go">array(250, dtype=&#39;timedelta64[s]&#39;)</span>
</pre></div>
</div>
<p>The result can be used to construct a datetime that uses the same units
as a timedelta</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">&#39;2010&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime_data</span><span class="p">(</span><span class="n">dt_25s</span><span class="p">))</span>
<span class="go">numpy.datetime64(&#39;2010-01-01T00:00:00&#39;,&#39;25s&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.delete">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">delete</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new array with sub-arrays along an axis deleted. For a one
dimensional array, this returns those entries not returned by
<cite>arr[obj]</cite>.</p>
<dl>
<dt>arr<span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt>obj<span class="classifier">slice, int or array of ints</span></dt><dd><p>Indicate indices of sub-arrays to remove along the specified axis.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.19.0: </span>Boolean indices are now treated as a mask of elements to remove,
rather than being cast to the integers 0 and 1.</p>
</div>
</dd>
<dt>axis<span class="classifier">int, optional</span></dt><dd><p>The axis along which to delete the subarray defined by <cite>obj</cite>.
If <cite>axis</cite> is None, <cite>obj</cite> is applied to the flattened array.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>A copy of <cite>arr</cite> with the elements specified by <cite>obj</cite> removed. Note
that <cite>delete</cite> does not occur in-place. If <cite>axis</cite> is None, <cite>out</cite> is
a flattened array.</p>
</dd>
</dl>
<p>insert : Insert elements into an array.
append : Append elements at the end of an array.</p>
<p>Often it is preferable to use a boolean mask. For example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>Is equivalent to <cite>np.delete(arr, [0,2,4], axis=0)</cite>, but allows further
use of <cite>mask</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span>
<span class="go">array([[ 1,  2,  3,  4],</span>
<span class="go">       [ 5,  6,  7,  8],</span>
<span class="go">       [ 9, 10, 11, 12]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">array([[ 1,  2,  3,  4],</span>
<span class="go">       [ 9, 10, 11, 12]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[::</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">array([[ 2,  4],</span>
<span class="go">       [ 6,  8],</span>
<span class="go">       [10, 12]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>
<span class="go">array([ 1,  3,  5,  7,  8,  9, 10, 11, 12])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.deprecate">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">deprecate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.deprecate" title="Permalink to this definition">¶</a></dt>
<dd><p>Issues a DeprecationWarning, adds warning to <cite>old_name</cite>’s
docstring, rebinds <code class="docutils literal notranslate"><span class="pre">old_name.__name__</span></code> and returns the new
function object.</p>
<p>This function may also be used as a decorator.</p>
<dl class="simple">
<dt>func<span class="classifier">function</span></dt><dd><p>The function to be deprecated.</p>
</dd>
<dt>old_name<span class="classifier">str, optional</span></dt><dd><p>The name of the function to be deprecated. Default is None, in
which case the name of <cite>func</cite> is used.</p>
</dd>
<dt>new_name<span class="classifier">str, optional</span></dt><dd><p>The new name for the function. Default is None, in which case the
deprecation message is that <cite>old_name</cite> is deprecated. If given, the
deprecation message is that <cite>old_name</cite> is deprecated and <cite>new_name</cite>
should be used instead.</p>
</dd>
<dt>message<span class="classifier">str, optional</span></dt><dd><p>Additional explanation of the deprecation.  Displayed in the
docstring after the warning.</p>
</dd>
</dl>
<dl class="simple">
<dt>old_func<span class="classifier">function</span></dt><dd><p>The deprecated function.</p>
</dd>
</dl>
<p>Note that <code class="docutils literal notranslate"><span class="pre">olduint</span></code> returns a value after printing Deprecation
Warning:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">olduint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deprecate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint</span><span class="p">)</span>
<span class="go">DeprecationWarning: `uint64` is deprecated! # may vary</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">olduint</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">6</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.deprecate_with_doc">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">deprecate_with_doc</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.deprecate_with_doc" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecates a function and includes the deprecation in its docstring.</p>
<p>This function is used as a decorator. It returns an object that can be
used to issue a DeprecationWarning, by passing the to-be decorated
function as argument, this adds warning to the to-be decorated function’s
docstring and returns the new function object.</p>
<p>deprecate : Decorate a function such that it issues a <cite>DeprecationWarning</cite></p>
<dl class="simple">
<dt>msg<span class="classifier">str</span></dt><dd><p>Additional explanation of the deprecation. Displayed in the
docstring after the warning.</p>
</dd>
</dl>
<p>obj : object</p>
</dd></dl>

<dl class="py function">
<dt id="numpy.diag">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">diag</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.diag" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract a diagonal or construct a diagonal array.</p>
<p>See the more detailed documentation for <code class="docutils literal notranslate"><span class="pre">numpy.diagonal</span></code> if you use this
function to extract a diagonal and wish to write to the resulting array;
whether it returns a copy or a view depends on what version of numpy you
are using.</p>
<dl class="simple">
<dt>v<span class="classifier">array_like</span></dt><dd><p>If <cite>v</cite> is a 2-D array, return a copy of its <cite>k</cite>-th diagonal.
If <cite>v</cite> is a 1-D array, return a 2-D array with <cite>v</cite> on the <cite>k</cite>-th
diagonal.</p>
</dd>
<dt>k<span class="classifier">int, optional</span></dt><dd><p>Diagonal in question. The default is 0. Use <cite>k&gt;0</cite> for diagonals
above the main diagonal, and <cite>k&lt;0</cite> for diagonals below the main
diagonal.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>The extracted diagonal or constructed diagonal array.</p>
</dd>
</dl>
<p>diagonal : Return specified diagonals.
diagflat : Create a 2-D array with the flattened input as a diagonal.
trace : Sum along diagonals.
triu : Upper triangle of an array.
tril : Lower triangle of an array.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5],</span>
<span class="go">       [6, 7, 8]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([0, 4, 8])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([1, 5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([3, 7])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">array([[0, 0, 0],</span>
<span class="go">       [0, 4, 0],</span>
<span class="go">       [0, 0, 8]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.diag_indices">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">diag_indices</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ndim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.diag_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices to access the main diagonal of an array.</p>
<p>This returns a tuple of indices that can be used to access the main
diagonal of an array <cite>a</cite> with <code class="docutils literal notranslate"><span class="pre">a.ndim</span> <span class="pre">&gt;=</span> <span class="pre">2</span></code> dimensions and shape
(n, n, …, n). For <code class="docutils literal notranslate"><span class="pre">a.ndim</span> <span class="pre">=</span> <span class="pre">2</span></code> this is the usual diagonal, for
<code class="docutils literal notranslate"><span class="pre">a.ndim</span> <span class="pre">&gt;</span> <span class="pre">2</span></code> this is the set of indices to access <code class="docutils literal notranslate"><span class="pre">a[i,</span> <span class="pre">i,</span> <span class="pre">...,</span> <span class="pre">i]</span></code>
for <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">=</span> <span class="pre">[0..n-1]</span></code>.</p>
<dl class="simple">
<dt>n<span class="classifier">int</span></dt><dd><p>The size, along each dimension, of the arrays for which the returned
indices can be used.</p>
</dd>
<dt>ndim<span class="classifier">int, optional</span></dt><dd><p>The number of dimensions.</p>
</dd>
</dl>
<p>diag_indices_from</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.4.0.</span></p>
</div>
<p>Create a set of indices to access the diagonal of a (4, 4) array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">di</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag_indices</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">di</span>
<span class="go">(array([0, 1, 2, 3]), array([0, 1, 2, 3]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">di</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[100,   1,   2,   3],</span>
<span class="go">       [  4, 100,   6,   7],</span>
<span class="go">       [  8,   9, 100,  11],</span>
<span class="go">       [ 12,  13,  14, 100]])</span>
</pre></div>
</div>
<p>Now, we create indices to manipulate a 3-D array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag_indices</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d3</span>
<span class="go">(array([0, 1]), array([0, 1]), array([0, 1]))</span>
</pre></div>
</div>
<p>And use it to set the diagonal of an array of zeros to 1:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">d3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[[1, 0],</span>
<span class="go">        [0, 0]],</span>
<span class="go">       [[0, 0],</span>
<span class="go">        [0, 1]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.diag_indices_from">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">diag_indices_from</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.diag_indices_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices to access the main diagonal of an n-dimensional array.</p>
<p>See <cite>diag_indices</cite> for full details.</p>
<p>arr : array, at least 2-D</p>
<p>diag_indices</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.4.0.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.diagflat">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">diagflat</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.diagflat" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a two-dimensional array with the flattened input as a diagonal.</p>
<dl class="simple">
<dt>v<span class="classifier">array_like</span></dt><dd><p>Input data, which is flattened and set as the <cite>k</cite>-th
diagonal of the output.</p>
</dd>
<dt>k<span class="classifier">int, optional</span></dt><dd><p>Diagonal to set; 0, the default, corresponds to the “main” diagonal,
a positive (negative) <cite>k</cite> giving the number of the diagonal above
(below) the main.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>The 2-D output array.</p>
</dd>
</dl>
<p>diag : MATLAB work-alike for 1-D and 2-D arrays.
diagonal : Return specified diagonals.
trace : Sum along diagonals.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diagflat</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="go">array([[1, 0, 0, 0],</span>
<span class="go">       [0, 2, 0, 0],</span>
<span class="go">       [0, 0, 3, 0],</span>
<span class="go">       [0, 0, 0, 4]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diagflat</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">array([[0, 1, 0],</span>
<span class="go">       [0, 0, 2],</span>
<span class="go">       [0, 0, 0]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.diagonal">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">diagonal</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.diagonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return specified diagonals.</p>
<p>If <cite>a</cite> is 2-D, returns the diagonal of <cite>a</cite> with the given offset,
i.e., the collection of elements of the form <code class="docutils literal notranslate"><span class="pre">a[i,</span> <span class="pre">i+offset]</span></code>.  If
<cite>a</cite> has more than two dimensions, then the axes specified by <cite>axis1</cite>
and <cite>axis2</cite> are used to determine the 2-D sub-array whose diagonal is
returned.  The shape of the resulting array can be determined by
removing <cite>axis1</cite> and <cite>axis2</cite> and appending an index to the right equal
to the size of the resulting diagonals.</p>
<p>In versions of NumPy prior to 1.7, this function always returned a new,
independent array containing a copy of the values in the diagonal.</p>
<p>In NumPy 1.7 and 1.8, it continues to return a copy of the diagonal,
but depending on this fact is deprecated. Writing to the resulting
array continues to work as it used to, but a FutureWarning is issued.</p>
<p>Starting in NumPy 1.9 it returns a read-only view on the original array.
Attempting to write to the resulting array will produce an error.</p>
<p>In some future release, it will return a read/write view and writing to
the returned array will alter your original array.  The returned array
will have the same type as the input array.</p>
<p>If you don’t write to the array returned by this function, then you can
just ignore all of the above.</p>
<p>If you depend on the current behavior, then we suggest copying the
returned array explicitly, i.e., use <code class="docutils literal notranslate"><span class="pre">np.diagonal(a).copy()</span></code> instead
of just <code class="docutils literal notranslate"><span class="pre">np.diagonal(a)</span></code>. This will work with both past and future
versions of NumPy.</p>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>Array from which the diagonals are taken.</p>
</dd>
<dt>offset<span class="classifier">int, optional</span></dt><dd><p>Offset of the diagonal from the main diagonal.  Can be positive or
negative.  Defaults to main diagonal (0).</p>
</dd>
<dt>axis1<span class="classifier">int, optional</span></dt><dd><p>Axis to be used as the first axis of the 2-D sub-arrays from which
the diagonals should be taken.  Defaults to first axis (0).</p>
</dd>
<dt>axis2<span class="classifier">int, optional</span></dt><dd><p>Axis to be used as the second axis of the 2-D sub-arrays from
which the diagonals should be taken. Defaults to second axis (1).</p>
</dd>
</dl>
<dl>
<dt>array_of_diagonals<span class="classifier">ndarray</span></dt><dd><p>If <cite>a</cite> is 2-D, then a 1-D array containing the diagonal and of the
same type as <cite>a</cite> is returned unless <cite>a</cite> is a <cite>matrix</cite>, in which case
a 1-D array rather than a (2-D) <cite>matrix</cite> is returned in order to
maintain backward compatibility.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">a.ndim</span> <span class="pre">&gt;</span> <span class="pre">2</span></code>, then the dimensions specified by <cite>axis1</cite> and <cite>axis2</cite>
are removed, and a new axis inserted at the end corresponding to the
diagonal.</p>
</dd>
</dl>
<dl class="simple">
<dt>ValueError</dt><dd><p>If the dimension of <cite>a</cite> is less than 2.</p>
</dd>
</dl>
<p>diag : MATLAB work-a-like for 1-D and 2-D arrays.
diagflat : Create diagonal arrays.
trace : Sum along diagonals.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
<span class="go">array([0, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([1])</span>
</pre></div>
</div>
<p>A 3-D example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span> <span class="n">a</span>
<span class="go">array([[[0, 1],</span>
<span class="go">        [2, 3]],</span>
<span class="go">       [[4, 5],</span>
<span class="go">        [6, 7]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>  <span class="c1"># Main diagonals of two arrays created by skipping</span>
<span class="gp">... </span>           <span class="mi">0</span><span class="p">,</span>  <span class="c1"># across the outer(left)-most axis last and</span>
<span class="gp">... </span>           <span class="mi">1</span><span class="p">)</span>  <span class="c1"># the &quot;middle&quot; (row) axis first.</span>
<span class="go">array([[0, 6],</span>
<span class="go">       [1, 7]])</span>
</pre></div>
</div>
<p>The sub-arrays whose main diagonals we just obtained; note that each
corresponds to fixing the right-most (column) axis, and that the
diagonals are “packed” in rows.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># main diagonal is [0 6]</span>
<span class="go">array([[0, 2],</span>
<span class="go">       [4, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># main diagonal is [1 7]</span>
<span class="go">array([[1, 3],</span>
<span class="go">       [5, 7]])</span>
</pre></div>
</div>
<p>The anti-diagonal can be obtained by reversing the order of elements
using either <cite>numpy.flipud</cite> or <cite>numpy.fliplr</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5],</span>
<span class="go">       [6, 7, 8]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>  <span class="c1"># Horizontal flip</span>
<span class="go">array([2, 4, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>  <span class="c1"># Vertical flip</span>
<span class="go">array([6, 4, 2])</span>
</pre></div>
</div>
<p>Note that the order in which the diagonal is retrieved varies depending
on the flip function.</p>
</dd></dl>

<dl class="py function">
<dt id="numpy.diff">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">diff</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">a</span></em>, <em class="sig-param"><span class="pre">n=1</span></em>, <em class="sig-param"><span class="pre">axis=-1</span></em>, <em class="sig-param"><span class="pre">prepend=&lt;no</span> <span class="pre">value&gt;</span></em>, <em class="sig-param"><span class="pre">append=&lt;no</span> <span class="pre">value&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.diff" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the n-th discrete difference along the given axis.</p>
<p>The first difference is given by <code class="docutils literal notranslate"><span class="pre">out[i]</span> <span class="pre">=</span> <span class="pre">a[i+1]</span> <span class="pre">-</span> <span class="pre">a[i]</span></code> along
the given axis, higher differences are calculated by using <cite>diff</cite>
recursively.</p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input array</p>
</dd>
<dt>n<span class="classifier">int, optional</span></dt><dd><p>The number of times values are differenced. If zero, the input
is returned as-is.</p>
</dd>
<dt>axis<span class="classifier">int, optional</span></dt><dd><p>The axis along which the difference is taken, default is the
last axis.</p>
</dd>
<dt>prepend, append<span class="classifier">array_like, optional</span></dt><dd><p>Values to prepend or append to <cite>a</cite> along axis prior to
performing the difference.  Scalar values are expanded to
arrays with length 1 in the direction of axis and the shape
of the input array in along all other axes.  Otherwise the
dimension and shape must match <cite>a</cite> except along axis.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.16.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>diff<span class="classifier">ndarray</span></dt><dd><p>The n-th differences. The shape of the output is the same as <cite>a</cite>
except along <cite>axis</cite> where the dimension is smaller by <cite>n</cite>. The
type of the output is the same as the type of the difference
between any two elements of <cite>a</cite>. This is the same as the type of
<cite>a</cite> in most cases. A notable exception is <cite>datetime64</cite>, which
results in a <cite>timedelta64</cite> output array.</p>
</dd>
</dl>
<p>gradient, ediff1d, cumsum</p>
<p>Type is preserved for boolean arrays, so the result will contain
<cite>False</cite> when consecutive elements are the same and <cite>True</cite> when they
differ.</p>
<p>For unsigned integer arrays, the results will also be unsigned. This
should not be surprising, as the result is consistent with
calculating the difference directly:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u8_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u8_arr</span><span class="p">)</span>
<span class="go">array([255], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u8_arr</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="o">-</span> <span class="n">u8_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
<span class="go">255</span>
</pre></div>
</div>
<p>If this is not desirable, then the array should be cast to a larger
integer type first:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i16_arr</span> <span class="o">=</span> <span class="n">u8_arr</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">i16_arr</span><span class="p">)</span>
<span class="go">array([-1], dtype=int16)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([ 1,  2,  3, -7])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([  1,   1, -10])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([[2, 3, 4],</span>
<span class="go">       [5, 1, 2]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[-1,  2,  0, -2]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="s1">&#39;1066-10-13&#39;</span><span class="p">,</span> <span class="s1">&#39;1066-10-16&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([1, 1], dtype=&#39;timedelta64[D]&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.digitize">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">digitize</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">right</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.digitize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices of the bins to which each value in input array belongs.</p>
<table class="table">
<colgroup>
<col style="width: 18%" />
<col style="width: 26%" />
<col style="width: 56%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><cite>right</cite></p></th>
<th class="head"><p>order of bins</p></th>
<th class="head"><p>returned index <cite>i</cite> satisfies</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">False</span></code></p></td>
<td><p>increasing</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">bins[i-1]</span> <span class="pre">&lt;=</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">bins[i]</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">True</span></code></p></td>
<td><p>increasing</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">bins[i-1]</span> <span class="pre">&lt;</span> <span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">bins[i]</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">False</span></code></p></td>
<td><p>decreasing</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">bins[i-1]</span> <span class="pre">&gt;</span> <span class="pre">x</span> <span class="pre">&gt;=</span> <span class="pre">bins[i]</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">True</span></code></p></td>
<td><p>decreasing</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">bins[i-1]</span> <span class="pre">&gt;=</span> <span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">bins[i]</span></code></p></td>
</tr>
</tbody>
</table>
<p>If values in <cite>x</cite> are beyond the bounds of <cite>bins</cite>, 0 or <code class="docutils literal notranslate"><span class="pre">len(bins)</span></code> is
returned as appropriate.</p>
<dl class="simple">
<dt>x<span class="classifier">array_like</span></dt><dd><p>Input array to be binned. Prior to NumPy 1.10.0, this array had to
be 1-dimensional, but can now have any shape.</p>
</dd>
<dt>bins<span class="classifier">array_like</span></dt><dd><p>Array of bins. It has to be 1-dimensional and monotonic.</p>
</dd>
<dt>right<span class="classifier">bool, optional</span></dt><dd><p>Indicating whether the intervals include the right or the left bin
edge. Default behavior is (right==False) indicating that the interval
does not include the right edge. The left bin end is open in this
case, i.e., bins[i-1] &lt;= x &lt; bins[i] is the default behavior for
monotonically increasing bins.</p>
</dd>
</dl>
<dl class="simple">
<dt>indices<span class="classifier">ndarray of ints</span></dt><dd><p>Output array of indices, of same shape as <cite>x</cite>.</p>
</dd>
</dl>
<dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>bins</cite> is not monotonic.</p>
</dd>
<dt>TypeError</dt><dd><p>If the type of the input is complex.</p>
</dd>
</dl>
<p>bincount, histogram, unique, searchsorted</p>
<p>If values in <cite>x</cite> are such that they fall outside the bin range,
attempting to index <cite>bins</cite> with the indices that <cite>digitize</cite> returns
will result in an IndexError.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.0.</span></p>
</div>
<p><cite>np.digitize</cite> is  implemented in terms of <cite>np.searchsorted</cite>. This means
that a binary search is used to bin the values, which scales much better
for larger number of bins than the previous linear search. It also removes
the requirement for the input array to be 1-dimensional.</p>
<p>For monotonically _increasing_ <cite>bins</cite>, the following are equivalent:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that as the order of the arguments are reversed, the side must be too.
The <cite>searchsorted</cite> call is marginally faster, as it does not do any
monotonicity checks. Perhaps more importantly, it supports all dtypes.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">6.4</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">1.6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inds</span>
<span class="go">array([1, 4, 3, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
<span class="gp">... </span>  <span class="nb">print</span><span class="p">(</span><span class="n">bins</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;&lt;=&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="s2">&quot;&lt;&quot;</span><span class="p">,</span> <span class="n">bins</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">n</span><span class="p">]])</span>
<span class="gp">...</span>
<span class="go">0.0 &lt;= 0.2 &lt; 1.0</span>
<span class="go">4.0 &lt;= 6.4 &lt; 10.0</span>
<span class="go">2.5 &lt;= 3.0 &lt; 4.0</span>
<span class="go">1.0 &lt;= 1.6 &lt; 2.5</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">12.4</span><span class="p">,</span> <span class="mf">15.5</span><span class="p">,</span> <span class="mf">20.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">bins</span><span class="p">,</span><span class="n">right</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([1, 2, 3, 4, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">bins</span><span class="p">,</span><span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">array([1, 3, 3, 4, 5])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.disp">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">disp</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linefeed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.disp" title="Permalink to this definition">¶</a></dt>
<dd><p>Display a message on a device.</p>
<dl class="simple">
<dt>mesg<span class="classifier">str</span></dt><dd><p>Message to display.</p>
</dd>
<dt>device<span class="classifier">object</span></dt><dd><p>Device to write message. If None, defaults to <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code> which is
very similar to <code class="docutils literal notranslate"><span class="pre">print</span></code>. <cite>device</cite> needs to have <code class="docutils literal notranslate"><span class="pre">write()</span></code> and
<code class="docutils literal notranslate"><span class="pre">flush()</span></code> methods.</p>
</dd>
<dt>linefeed<span class="classifier">bool, optional</span></dt><dd><p>Option whether to print a line feed or not. Defaults to True.</p>
</dd>
</dl>
<dl class="simple">
<dt>AttributeError</dt><dd><p>If <cite>device</cite> does not have a <code class="docutils literal notranslate"><span class="pre">write()</span></code> or <code class="docutils literal notranslate"><span class="pre">flush()</span></code> method.</p>
</dd>
</dl>
<p>Besides <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code>, a file-like object can also be used as it has
both required methods:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">StringIO</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">disp</span><span class="p">(</span><span class="sa">u</span><span class="s1">&#39;&quot;Display&quot; in a file&#39;</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">buf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
<span class="go">&#39;&quot;Display&quot; in a file\n&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.dot">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">dot</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Dot product of two arrays. Specifically,</p>
<ul>
<li><p>If both <cite>a</cite> and <cite>b</cite> are 1-D arrays, it is inner product of vectors
(without complex conjugation).</p></li>
<li><p>If both <cite>a</cite> and <cite>b</cite> are 2-D arrays, it is matrix multiplication,
but using <code class="xref py py-func docutils literal notranslate"><span class="pre">matmul()</span></code> or <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&#64;</span> <span class="pre">b</span></code> is preferred.</p></li>
<li><p>If either <cite>a</cite> or <cite>b</cite> is 0-D (scalar), it is equivalent to <code class="xref py py-func docutils literal notranslate"><span class="pre">multiply()</span></code>
and using <code class="docutils literal notranslate"><span class="pre">numpy.multiply(a,</span> <span class="pre">b)</span></code> or <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">b</span></code> is preferred.</p></li>
<li><p>If <cite>a</cite> is an N-D array and <cite>b</cite> is a 1-D array, it is a sum product over
the last axis of <cite>a</cite> and <cite>b</cite>.</p></li>
<li><p>If <cite>a</cite> is an N-D array and <cite>b</cite> is an M-D array (where <code class="docutils literal notranslate"><span class="pre">M&gt;=2</span></code>), it is a
sum product over the last axis of <cite>a</cite> and the second-to-last axis of <cite>b</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="n">k</span><span class="p">,:,</span><span class="n">m</span><span class="p">])</span>
</pre></div>
</div>
</li>
</ul>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>First argument.</p>
</dd>
<dt>b<span class="classifier">array_like</span></dt><dd><p>Second argument.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Output argument. This must have the exact kind that would be returned
if it was not used. In particular, it must have the right type, must be
C-contiguous, and its dtype must be the dtype that would be returned
for <cite>dot(a,b)</cite>. This is a performance feature. Therefore, if these
conditions are not met, an exception is raised, instead of attempting
to be flexible.</p>
</dd>
</dl>
<dl class="simple">
<dt>output<span class="classifier">ndarray</span></dt><dd><p>Returns the dot product of <cite>a</cite> and <cite>b</cite>.  If <cite>a</cite> and <cite>b</cite> are both
scalars or both 1-D arrays then a scalar is returned; otherwise
an array is returned.
If <cite>out</cite> is given, then it is returned.</p>
</dd>
</dl>
<dl class="simple">
<dt>ValueError</dt><dd><p>If the last dimension of <cite>a</cite> is not the same size as
the second-to-last dimension of <cite>b</cite>.</p>
</dd>
</dl>
<p>vdot : Complex-conjugating dot product.
tensordot : Sum products over arbitrary axes.
einsum : Einstein summation convention.
matmul : ‘&#64;’ operator as method with out parameter.
linalg.multi_dot : Chained dot product.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">12</span>
</pre></div>
</div>
<p>Neither argument is complex-conjugated:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">([</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="n">j</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="n">j</span><span class="p">])</span>
<span class="go">(-13+0j)</span>
</pre></div>
</div>
<p>For 2-D arrays it is the matrix product:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[4, 1],</span>
<span class="go">       [2, 2]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="mi">5</span><span class="o">*</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="mi">5</span><span class="o">*</span><span class="mi">6</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="go">499128</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,:,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">499128</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.double">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">double</span></code><a class="headerlink" href="#numpy.double" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.float64" title="numpy.float64"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.float64</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="numpy.dsplit">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">dsplit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ary</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices_or_sections</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.dsplit" title="Permalink to this definition">¶</a></dt>
<dd><p>Split array into multiple sub-arrays along the 3rd axis (depth).</p>
<p>Please refer to the <cite>split</cite> documentation.  <cite>dsplit</cite> is equivalent
to <cite>split</cite> with <code class="docutils literal notranslate"><span class="pre">axis=2</span></code>, the array is always split along the third
axis provided the array dimension is greater than or equal to 3.</p>
<p>split : Split an array into multiple sub-arrays of equal size.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">16.0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[[ 0.,   1.,   2.,   3.],</span>
<span class="go">        [ 4.,   5.,   6.,   7.]],</span>
<span class="go">       [[ 8.,   9.,  10.,  11.],</span>
<span class="go">        [12.,  13.,  14.,  15.]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dsplit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">[array([[[ 0.,  1.],</span>
<span class="go">        [ 4.,  5.]],</span>
<span class="go">       [[ 8.,  9.],</span>
<span class="go">        [12., 13.]]]), array([[[ 2.,  3.],</span>
<span class="go">        [ 6.,  7.]],</span>
<span class="go">       [[10., 11.],</span>
<span class="go">        [14., 15.]]])]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dsplit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">]))</span>
<span class="go">[array([[[ 0.,   1.,   2.],</span>
<span class="go">        [ 4.,   5.,   6.]],</span>
<span class="go">       [[ 8.,   9.,  10.],</span>
<span class="go">        [12.,  13.,  14.]]]),</span>
<span class="go"> array([[[ 3.],</span>
<span class="go">        [ 7.]],</span>
<span class="go">       [[11.],</span>
<span class="go">        [15.]]]),</span>
<span class="go">array([], shape=(2, 2, 0), dtype=float64)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.dstack">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">dstack</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tup</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.dstack" title="Permalink to this definition">¶</a></dt>
<dd><p>Stack arrays in sequence depth wise (along third axis).</p>
<p>This is equivalent to concatenation along the third axis after 2-D arrays
of shape <cite>(M,N)</cite> have been reshaped to <cite>(M,N,1)</cite> and 1-D arrays of shape
<cite>(N,)</cite> have been reshaped to <cite>(1,N,1)</cite>. Rebuilds arrays divided by
<cite>dsplit</cite>.</p>
<p>This function makes most sense for arrays with up to 3 dimensions. For
instance, for pixel-data with a height (first axis), width (second axis),
and r/g/b channels (third axis). The functions <cite>concatenate</cite>, <cite>stack</cite> and
<cite>block</cite> provide more general stacking and concatenation operations.</p>
<dl class="simple">
<dt>tup<span class="classifier">sequence of arrays</span></dt><dd><p>The arrays must have the same shape along all but the third axis.
1-D or 2-D arrays must have the same shape.</p>
</dd>
</dl>
<dl class="simple">
<dt>stacked<span class="classifier">ndarray</span></dt><dd><p>The array formed by stacking the given arrays, will be at least 3-D.</p>
</dd>
</dl>
<p>concatenate : Join a sequence of arrays along an existing axis.
stack : Join a sequence of arrays along a new axis.
block : Assemble an nd-array from nested lists of blocks.
vstack : Stack arrays in sequence vertically (row wise).
hstack : Stack arrays in sequence horizontally (column wise).
column_stack : Stack 1-D arrays as columns into a 2-D array.
dsplit : Split array along third axis.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
<span class="go">array([[[1, 2],</span>
<span class="go">        [2, 3],</span>
<span class="go">        [3, 4]]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
<span class="go">array([[[1, 2]],</span>
<span class="go">       [[2, 3]],</span>
<span class="go">       [[3, 4]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.ediff1d">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">ediff1d</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ary</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_begin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ediff1d" title="Permalink to this definition">¶</a></dt>
<dd><p>The differences between consecutive elements of an array.</p>
<dl class="simple">
<dt>ary<span class="classifier">array_like</span></dt><dd><p>If necessary, will be flattened before the differences are taken.</p>
</dd>
<dt>to_end<span class="classifier">array_like, optional</span></dt><dd><p>Number(s) to append at the end of the returned differences.</p>
</dd>
<dt>to_begin<span class="classifier">array_like, optional</span></dt><dd><p>Number(s) to prepend at the beginning of the returned differences.</p>
</dd>
</dl>
<dl class="simple">
<dt>ediff1d<span class="classifier">ndarray</span></dt><dd><p>The differences. Loosely, this is <code class="docutils literal notranslate"><span class="pre">ary.flat[1:]</span> <span class="pre">-</span> <span class="pre">ary.flat[:-1]</span></code>.</p>
</dd>
</dl>
<p>diff, gradient</p>
<p>When applied to masked arrays, this function drops the mask information
if the <cite>to_begin</cite> and/or <cite>to_end</cite> parameters are used.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ediff1d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([ 1,  2,  3, -7])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ediff1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">to_begin</span><span class="o">=-</span><span class="mi">99</span><span class="p">,</span> <span class="n">to_end</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">88</span><span class="p">,</span> <span class="mi">99</span><span class="p">]))</span>
<span class="go">array([-99,   1,   2, ...,  -7,  88,  99])</span>
</pre></div>
</div>
<p>The returned array is always 1D.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">24</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ediff1d</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">array([ 1,  2, -3,  5, 18])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.einsum">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">einsum</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">operands</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.einsum" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>einsum(subscripts, <a href="#id18"><span class="problematic" id="id19">*</span></a>operands, out=None, dtype=None, order=’K’,</dt><dd><p>casting=’safe’, optimize=False)</p>
</dd>
</dl>
<p>Evaluates the Einstein summation convention on the operands.</p>
<p>Using the Einstein summation convention, many common multi-dimensional,
linear algebraic array operations can be represented in a simple fashion.
In <em>implicit</em> mode <cite>einsum</cite> computes these values.</p>
<p>In <em>explicit</em> mode, <cite>einsum</cite> provides further flexibility to compute
other array operations that might not be considered classical Einstein
summation operations, by disabling, or forcing summation over specified
subscript labels.</p>
<p>See the notes and examples for clarification.</p>
<dl>
<dt>subscripts<span class="classifier">str</span></dt><dd><p>Specifies the subscripts for summation as comma separated list of
subscript labels. An implicit (classical Einstein summation)
calculation is performed unless the explicit indicator ‘-&gt;’ is
included as well as subscript labels of the precise output form.</p>
</dd>
<dt>operands<span class="classifier">list of array_like</span></dt><dd><p>These are the arrays for the operation.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>If provided, the calculation is done into this array.</p>
</dd>
<dt>dtype<span class="classifier">{data-type, None}, optional</span></dt><dd><p>If provided, forces the calculation to use the data type specified.
Note that you may have to also give a more liberal <cite>casting</cite>
parameter to allow the conversions. Default is None.</p>
</dd>
<dt>order<span class="classifier">{‘C’, ‘F’, ‘A’, ‘K’}, optional</span></dt><dd><p>Controls the memory layout of the output. ‘C’ means it should
be C contiguous. ‘F’ means it should be Fortran contiguous,
‘A’ means it should be ‘F’ if the inputs are all ‘F’, ‘C’ otherwise.
‘K’ means it should be as close to the layout as the inputs as
is possible, including arbitrarily permuted axes.
Default is ‘K’.</p>
</dd>
<dt>casting<span class="classifier">{‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional</span></dt><dd><p>Controls what kind of data casting may occur.  Setting this to
‘unsafe’ is not recommended, as it can adversely affect accumulations.</p>
<blockquote>
<div><ul class="simple">
<li><p>‘no’ means the data types should not be cast at all.</p></li>
<li><p>‘equiv’ means only byte-order changes are allowed.</p></li>
<li><p>‘safe’ means only casts which can preserve values are allowed.</p></li>
<li><p>‘same_kind’ means only safe casts or casts within a kind,
like float64 to float32, are allowed.</p></li>
<li><p>‘unsafe’ means any data conversions may be done.</p></li>
</ul>
</div></blockquote>
<p>Default is ‘safe’.</p>
</dd>
<dt>optimize<span class="classifier">{False, True, ‘greedy’, ‘optimal’}, optional</span></dt><dd><p>Controls if intermediate optimization should occur. No optimization
will occur if False and True will default to the ‘greedy’ algorithm.
Also accepts an explicit contraction list from the <code class="docutils literal notranslate"><span class="pre">np.einsum_path</span></code>
function. See <code class="docutils literal notranslate"><span class="pre">np.einsum_path</span></code> for more details. Defaults to False.</p>
</dd>
</dl>
<dl class="simple">
<dt>output<span class="classifier">ndarray</span></dt><dd><p>The calculation based on the Einstein summation convention.</p>
</dd>
</dl>
<p>einsum_path, dot, inner, outer, tensordot, linalg.multi_dot
einops :</p>
<blockquote>
<div><p>similar verbose interface is provided by
<a class="reference external" href="https://github.com/arogozhnikov/einops">einops</a> package to cover
additional operations: transpose, reshape/flatten, repeat/tile,
squeeze/unsqueeze and reductions.</p>
</div></blockquote>
<dl class="simple">
<dt>opt_einsum :</dt><dd><p><a class="reference external" href="https://optimized-einsum.readthedocs.io/en/stable/">opt_einsum</a>
optimizes contraction order for einsum-like expressions
in backend-agnostic manner.</p>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.6.0.</span></p>
</div>
<p>The Einstein summation convention can be used to compute
many multi-dimensional, linear algebraic array operations. <cite>einsum</cite>
provides a succinct way of representing these.</p>
<p>A non-exhaustive list of these operations,
which can be computed by <cite>einsum</cite>, is shown below along with examples:</p>
<ul class="simple">
<li><p>Trace of an array, <a class="reference internal" href="#numpy.trace" title="numpy.trace"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.trace()</span></code></a>.</p></li>
<li><p>Return a diagonal, <a class="reference internal" href="#numpy.diag" title="numpy.diag"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.diag()</span></code></a>.</p></li>
<li><p>Array axis summations, <a class="reference internal" href="#id0" title="numpy.sum"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.sum()</span></code></a>.</p></li>
<li><p>Transpositions and permutations, <a class="reference internal" href="#numpy.transpose" title="numpy.transpose"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.transpose()</span></code></a>.</p></li>
<li><p>Matrix multiplication and dot product, <code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.matmul()</span></code> <a class="reference internal" href="#numpy.dot" title="numpy.dot"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.dot()</span></code></a>.</p></li>
<li><p>Vector inner and outer products, <a class="reference internal" href="#numpy.inner" title="numpy.inner"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.inner()</span></code></a> <a class="reference internal" href="#numpy.outer" title="numpy.outer"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.outer()</span></code></a>.</p></li>
<li><p>Broadcasting, element-wise and scalar multiplication, <code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.multiply()</span></code>.</p></li>
<li><p>Tensor contractions, <a class="reference internal" href="#numpy.tensordot" title="numpy.tensordot"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.tensordot()</span></code></a>.</p></li>
<li><p>Chained array operations, in efficient calculation order, <a class="reference internal" href="#numpy.einsum_path" title="numpy.einsum_path"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.einsum_path()</span></code></a>.</p></li>
</ul>
<p>The subscripts string is a comma-separated list of subscript labels,
where each label refers to a dimension of the corresponding operand.
Whenever a label is repeated it is summed, so <code class="docutils literal notranslate"><span class="pre">np.einsum('i,i',</span> <span class="pre">a,</span> <span class="pre">b)</span></code>
is equivalent to <a class="reference internal" href="#numpy.inner" title="numpy.inner"><code class="xref py py-func docutils literal notranslate"><span class="pre">np.inner(a,b)</span></code></a>. If a label
appears only once, it is not summed, so <code class="docutils literal notranslate"><span class="pre">np.einsum('i',</span> <span class="pre">a)</span></code> produces a
view of <code class="docutils literal notranslate"><span class="pre">a</span></code> with no changes. A further example <code class="docutils literal notranslate"><span class="pre">np.einsum('ij,jk',</span> <span class="pre">a,</span> <span class="pre">b)</span></code>
describes traditional matrix multiplication and is equivalent to
<code class="xref py py-func docutils literal notranslate"><span class="pre">np.matmul(a,b)</span></code>. Repeated subscript labels in one
operand take the diagonal. For example, <code class="docutils literal notranslate"><span class="pre">np.einsum('ii',</span> <span class="pre">a)</span></code> is equivalent
to <a class="reference internal" href="#numpy.trace" title="numpy.trace"><code class="xref py py-func docutils literal notranslate"><span class="pre">np.trace(a)</span></code></a>.</p>
<p>In <em>implicit mode</em>, the chosen subscripts are important
since the axes of the output are reordered alphabetically.  This
means that <code class="docutils literal notranslate"><span class="pre">np.einsum('ij',</span> <span class="pre">a)</span></code> doesn’t affect a 2D array, while
<code class="docutils literal notranslate"><span class="pre">np.einsum('ji',</span> <span class="pre">a)</span></code> takes its transpose. Additionally,
<code class="docutils literal notranslate"><span class="pre">np.einsum('ij,jk',</span> <span class="pre">a,</span> <span class="pre">b)</span></code> returns a matrix multiplication, while,
<code class="docutils literal notranslate"><span class="pre">np.einsum('ij,jh',</span> <span class="pre">a,</span> <span class="pre">b)</span></code> returns the transpose of the
multiplication since subscript ‘h’ precedes subscript ‘i’.</p>
<p>In <em>explicit mode</em> the output can be directly controlled by
specifying output subscript labels.  This requires the
identifier ‘-&gt;’ as well as the list of output subscript labels.
This feature increases the flexibility of the function since
summing can be disabled or forced when required. The call
<code class="docutils literal notranslate"><span class="pre">np.einsum('i-&gt;',</span> <span class="pre">a)</span></code> is like <a class="reference internal" href="#id0" title="numpy.sum"><code class="xref py py-func docutils literal notranslate"><span class="pre">np.sum(a,</span> <span class="pre">axis=-1)</span></code></a>,
and <code class="docutils literal notranslate"><span class="pre">np.einsum('ii-&gt;i',</span> <span class="pre">a)</span></code> is like <a class="reference internal" href="#numpy.diag" title="numpy.diag"><code class="xref py py-func docutils literal notranslate"><span class="pre">np.diag(a)</span></code></a>.
The difference is that <cite>einsum</cite> does not allow broadcasting by default.
Additionally <code class="docutils literal notranslate"><span class="pre">np.einsum('ij,jh-&gt;ih',</span> <span class="pre">a,</span> <span class="pre">b)</span></code> directly specifies the
order of the output subscript labels and therefore returns matrix
multiplication, unlike the example above in implicit mode.</p>
<p>To enable and control broadcasting, use an ellipsis.  Default
NumPy-style broadcasting is done by adding an ellipsis
to the left of each term, like <code class="docutils literal notranslate"><span class="pre">np.einsum('...ii-&gt;...i',</span> <span class="pre">a)</span></code>.
To take the trace along the first and last axes,
you can do <code class="docutils literal notranslate"><span class="pre">np.einsum('i...i',</span> <span class="pre">a)</span></code>, or to do a matrix-matrix
product with the left-most indices instead of rightmost, one can do
<code class="docutils literal notranslate"><span class="pre">np.einsum('ij...,jk...-&gt;ik...',</span> <span class="pre">a,</span> <span class="pre">b)</span></code>.</p>
<p>When there is only one operand, no axes are summed, and no output
parameter is provided, a view into the operand is returned instead
of a new array.  Thus, taking the diagonal as <code class="docutils literal notranslate"><span class="pre">np.einsum('ii-&gt;i',</span> <span class="pre">a)</span></code>
produces a view (changed in version 1.10.0).</p>
<p><cite>einsum</cite> also provides an alternative way to provide the subscripts
and operands as <code class="docutils literal notranslate"><span class="pre">einsum(op0,</span> <span class="pre">sublist0,</span> <span class="pre">op1,</span> <span class="pre">sublist1,</span> <span class="pre">...,</span> <span class="pre">[sublistout])</span></code>.
If the output shape is not provided in this format <cite>einsum</cite> will be
calculated in implicit mode, otherwise it will be performed explicitly.
The examples below have corresponding <cite>einsum</cite> calls with the two
parameter methods.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.0.</span></p>
</div>
<p>Views returned from einsum are now writeable whenever the input array
is writeable. For example, <code class="docutils literal notranslate"><span class="pre">np.einsum('ijk...-&gt;kji...',</span> <span class="pre">a)</span></code> will now
have the same effect as <a class="reference internal" href="#numpy.swapaxes" title="numpy.swapaxes"><code class="xref py py-func docutils literal notranslate"><span class="pre">np.swapaxes(a,</span> <span class="pre">0,</span> <span class="pre">2)</span></code></a>
and <code class="docutils literal notranslate"><span class="pre">np.einsum('ii-&gt;i',</span> <span class="pre">a)</span></code> will return a writeable view of the diagonal
of a 2D array.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.12.0.</span></p>
</div>
<p>Added the <code class="docutils literal notranslate"><span class="pre">optimize</span></code> argument which will optimize the contraction order
of an einsum expression. For a contraction with three or more operands this
can greatly increase the computational efficiency at the cost of a larger
memory footprint during computation.</p>
<p>Typically a ‘greedy’ algorithm is applied which empirical tests have shown
returns the optimal path in the majority of cases. In some cases ‘optimal’
will return the superlative path through a more expensive, exhaustive search.
For iterative calculations it may be advisable to calculate the optimal path
once and reuse that path by supplying it as an argument. An example is given
below.</p>
<p>See <a class="reference internal" href="#numpy.einsum_path" title="numpy.einsum_path"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.einsum_path()</span></code></a> for more details.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Trace of a matrix:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ii&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">60</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="go">60</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">60</span>
</pre></div>
</div>
<p>Extract the diagonal (requires explicit form):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ii-&gt;i&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">array([ 0,  6, 12, 18, 24])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">array([ 0,  6, 12, 18, 24])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([ 0,  6, 12, 18, 24])</span>
</pre></div>
</div>
<p>Sum over an axis (requires explicit form):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij-&gt;i&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">array([ 10,  35,  60,  85, 110])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">array([ 10,  35,  60,  85, 110])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 10,  35,  60,  85, 110])</span>
</pre></div>
</div>
<p>For higher dimensional arrays summing a single axis can be done with ellipsis:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;...j-&gt;...&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">array([ 10,  35,  60,  85, 110])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="bp">Ellipsis</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="bp">Ellipsis</span><span class="p">])</span>
<span class="go">array([ 10,  35,  60,  85, 110])</span>
</pre></div>
</div>
<p>Compute a matrix transpose, or reorder any number of axes:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ji&#39;</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="go">array([[0, 3],</span>
<span class="go">       [1, 4],</span>
<span class="go">       [2, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij-&gt;ji&#39;</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="go">array([[0, 3],</span>
<span class="go">       [1, 4],</span>
<span class="go">       [2, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="go">array([[0, 3],</span>
<span class="go">       [1, 4],</span>
<span class="go">       [2, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">array([[0, 3],</span>
<span class="go">       [1, 4],</span>
<span class="go">       [2, 5]])</span>
</pre></div>
</div>
<p>Vector inner products:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;i,i&#39;</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="go">30</span>
</pre></div>
</div>
<p>Matrix vector multiplication:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,j&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([ 30,  80, 130, 180, 230])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">array([ 30,  80, 130, 180, 230])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([ 30,  80, 130, 180, 230])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;...j,j&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([ 30,  80, 130, 180, 230])</span>
</pre></div>
</div>
<p>Broadcasting and scalar multiplication:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;..., ...&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="go">array([[ 0,  3,  6],</span>
<span class="go">       [ 9, 12, 15]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;,ij&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="go">array([[ 0,  3,  6],</span>
<span class="go">       [ 9, 12, 15]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="bp">Ellipsis</span><span class="p">],</span> <span class="n">c</span><span class="p">,</span> <span class="p">[</span><span class="bp">Ellipsis</span><span class="p">])</span>
<span class="go">array([[ 0,  3,  6],</span>
<span class="go">       [ 9, 12, 15]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="go">array([[ 0,  3,  6],</span>
<span class="go">       [ 9, 12, 15]])</span>
</pre></div>
</div>
<p>Vector outer product:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;i,j&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[0, 1, 2, 3, 4],</span>
<span class="go">       [0, 2, 4, 6, 8]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">array([[0, 1, 2, 3, 4],</span>
<span class="go">       [0, 2, 4, 6, 8]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[0, 1, 2, 3, 4],</span>
<span class="go">       [0, 2, 4, 6, 8]])</span>
</pre></div>
</div>
<p>Tensor contraction:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">60.</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">24.</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,jil-&gt;kl&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[4400., 4730.],</span>
<span class="go">       [4532., 4874.],</span>
<span class="go">       [4664., 5018.],</span>
<span class="go">       [4796., 5162.],</span>
<span class="go">       [4928., 5306.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">array([[4400., 4730.],</span>
<span class="go">       [4532., 4874.],</span>
<span class="go">       [4664., 5018.],</span>
<span class="go">       [4796., 5162.],</span>
<span class="go">       [4928., 5306.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">array([[4400., 4730.],</span>
<span class="go">       [4532., 4874.],</span>
<span class="go">       [4664., 5018.],</span>
<span class="go">       [4796., 5162.],</span>
<span class="go">       [4928., 5306.]])</span>
</pre></div>
</div>
<p>Writeable returned arrays (since version 1.10.0):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ii-&gt;i&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)[:]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[1., 0., 0.],</span>
<span class="go">       [0., 1., 0.],</span>
<span class="go">       [0., 0., 1.]])</span>
</pre></div>
</div>
<p>Example of ellipsis use:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ki,jk-&gt;ij&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[10, 28, 46, 64],</span>
<span class="go">       [13, 40, 67, 94]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ki,...k-&gt;i...&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[10, 28, 46, 64],</span>
<span class="go">       [13, 40, 67, 94]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;k...,jk&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[10, 28, 46, 64],</span>
<span class="go">       [13, 40, 67, 94]])</span>
</pre></div>
</div>
<p>Chained array operations. For more complicated contractions, speed ups
might be achieved by repeatedly computing a ‘greedy’ path or pre-computing the
‘optimal’ path and repeatedly applying it, using an
<cite>einsum_path</cite> insertion (since version 1.12.0). Performance improvements can be
particularly significant with larger arrays:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>
</pre></div>
</div>
<p>Basic <cite>einsum</cite>: ~1520ms  (benchmarked on 3.1GHz Intel i5.)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">500</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,ilm,njm,nlk,abc-&gt;&#39;</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>Sub-optimal <cite>einsum</cite> (due to repeated path calculation time): ~330ms</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">500</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,ilm,njm,nlk,abc-&gt;&#39;</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="s1">&#39;optimal&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Greedy <cite>einsum</cite> (faster optimal path approximation): ~160ms</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">500</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,ilm,njm,nlk,abc-&gt;&#39;</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="s1">&#39;greedy&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Optimal <cite>einsum</cite> (best usage pattern in some use cases): ~110ms</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum_path</span><span class="p">(</span><span class="s1">&#39;ijk,ilm,njm,nlk,abc-&gt;&#39;</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="s1">&#39;optimal&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">500</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,ilm,njm,nlk,abc-&gt;&#39;</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="n">path</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.einsum_path">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">einsum_path</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subscripts</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">operands</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'greedy'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.einsum_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the lowest cost contraction order for an einsum expression by
considering the creation of intermediate arrays.</p>
<dl>
<dt>subscripts<span class="classifier">str</span></dt><dd><p>Specifies the subscripts for summation.</p>
</dd>
<dt><a href="#id20"><span class="problematic" id="id21">*</span></a>operands<span class="classifier">list of array_like</span></dt><dd><p>These are the arrays for the operation.</p>
</dd>
<dt>optimize<span class="classifier">{bool, list, tuple, ‘greedy’, ‘optimal’}</span></dt><dd><p>Choose the type of path. If a tuple is provided, the second argument is
assumed to be the maximum intermediate size created. If only a single
argument is provided the largest input or output array size is used
as a maximum intermediate size.</p>
<ul class="simple">
<li><p>if a list is given that starts with <code class="docutils literal notranslate"><span class="pre">einsum_path</span></code>, uses this as the
contraction path</p></li>
<li><p>if False no optimization is taken</p></li>
<li><p>if True defaults to the ‘greedy’ algorithm</p></li>
<li><p>‘optimal’ An algorithm that combinatorially explores all possible
ways of contracting the listed tensors and choosest the least costly
path. Scales exponentially with the number of terms in the
contraction.</p></li>
<li><p>‘greedy’ An algorithm that chooses the best pair contraction
at each step. Effectively, this algorithm searches the largest inner,
Hadamard, and then outer products at each step. Scales cubically with
the number of terms in the contraction. Equivalent to the ‘optimal’
path for most contractions.</p></li>
</ul>
<p>Default is ‘greedy’.</p>
</dd>
</dl>
<dl class="simple">
<dt>path<span class="classifier">list of tuples</span></dt><dd><p>A list representation of the einsum path.</p>
</dd>
<dt>string_repr<span class="classifier">str</span></dt><dd><p>A printable representation of the einsum path.</p>
</dd>
</dl>
<p>The resulting path indicates which terms of the input contraction should be
contracted first, the result of this contraction is then appended to the
end of the contraction list. This list can then be iterated over until all
intermediate contractions are complete.</p>
<p>einsum, linalg.multi_dot</p>
<p>We can begin with a chain dot example. In this case, it is optimal to
contract the <code class="docutils literal notranslate"><span class="pre">b</span></code> and <code class="docutils literal notranslate"><span class="pre">c</span></code> tensors first as represented by the first
element of the path <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">2)</span></code>. The resulting tensor is added to the end
of the contraction and the remaining contraction <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">1)</span></code> is then
completed.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path_info</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum_path</span><span class="p">(</span><span class="s1">&#39;ij,jk,kl-&gt;il&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="s1">&#39;greedy&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">path_info</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[&#39;einsum_path&#39;, (1, 2), (0, 1)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">path_info</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">  Complete contraction:  ij,jk,kl-&gt;il # may vary</span>
<span class="go">         Naive scaling:  4</span>
<span class="go">     Optimized scaling:  3</span>
<span class="go">      Naive FLOP count:  1.600e+02</span>
<span class="go">  Optimized FLOP count:  5.600e+01</span>
<span class="go">   Theoretical speedup:  2.857</span>
<span class="go">  Largest intermediate:  4.000e+00 elements</span>
<span class="go">-------------------------------------------------------------------------</span>
<span class="go">scaling                  current                                remaining</span>
<span class="go">-------------------------------------------------------------------------</span>
<span class="go">   3                   kl,jk-&gt;jl                                ij,jl-&gt;il</span>
<span class="go">   3                   jl,ij-&gt;il                                   il-&gt;il</span>
</pre></div>
</div>
<p>A more complex index transformation example.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path_info</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum_path</span><span class="p">(</span><span class="s1">&#39;ea,fb,abcd,gc,hd-&gt;efgh&#39;</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span>
<span class="gp">... </span>                           <span class="n">optimize</span><span class="o">=</span><span class="s1">&#39;greedy&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">path_info</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[&#39;einsum_path&#39;, (0, 2), (0, 3), (0, 2), (0, 1)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">path_info</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> 
<span class="go">  Complete contraction:  ea,fb,abcd,gc,hd-&gt;efgh # may vary</span>
<span class="go">         Naive scaling:  8</span>
<span class="go">     Optimized scaling:  5</span>
<span class="go">      Naive FLOP count:  8.000e+08</span>
<span class="go">  Optimized FLOP count:  8.000e+05</span>
<span class="go">   Theoretical speedup:  1000.000</span>
<span class="go">  Largest intermediate:  1.000e+04 elements</span>
<span class="go">--------------------------------------------------------------------------</span>
<span class="go">scaling                  current                                remaining</span>
<span class="go">--------------------------------------------------------------------------</span>
<span class="go">   5               abcd,ea-&gt;bcde                      fb,gc,hd,bcde-&gt;efgh</span>
<span class="go">   5               bcde,fb-&gt;cdef                         gc,hd,cdef-&gt;efgh</span>
<span class="go">   5               cdef,gc-&gt;defg                            hd,defg-&gt;efgh</span>
<span class="go">   5               defg,hd-&gt;efgh                               efgh-&gt;efgh</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.empty">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">empty</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'C'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">like</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new array of given shape and type, without initializing entries.</p>
<dl>
<dt>shape<span class="classifier">int or tuple of int</span></dt><dd><p>Shape of the empty array, e.g., <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">3)</span></code> or <code class="docutils literal notranslate"><span class="pre">2</span></code>.</p>
</dd>
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>Desired output data-type for the array, e.g, <cite>numpy.int8</cite>. Default is
<cite>numpy.float64</cite>.</p>
</dd>
<dt>order<span class="classifier">{‘C’, ‘F’}, optional, default: ‘C’</span></dt><dd><p>Whether to store multi-dimensional data in row-major
(C-style) or column-major (Fortran-style) order in
memory.</p>
</dd>
<dt>like<span class="classifier">array_like</span></dt><dd><p>Reference object to allow the creation of arrays which are not
NumPy arrays. If an array-like passed in as <code class="docutils literal notranslate"><span class="pre">like</span></code> supports
the <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> protocol, the result will be defined
by it. In this case, it ensures the creation of an array object
compatible with that passed in via this argument.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.20.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>Array of uninitialized (arbitrary) data of the given shape, dtype, and
order.  Object arrays will be initialized to None.</p>
</dd>
</dl>
<p>empty_like : Return an empty array with shape and type of input.
ones : Return a new array setting values to one.
zeros : Return a new array setting values to zero.
full : Return a new array of given shape filled with value.</p>
<p><cite>empty</cite>, unlike <cite>zeros</cite>, does not set the array values to zero,
and may therefore be marginally faster.  On the other hand, it requires
the user to manually set all the values in the array, and should be
used with caution.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">array([[ -9.74499359e+001,   6.69583040e-309],</span>
<span class="go">       [  2.13182611e-314,   3.06959433e-309]])         #uninitialized</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([[-1073741821, -1067949133],</span>
<span class="go">       [  496041986,    19249760]])                     #uninitialized</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.empty_like">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">empty_like</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prototype</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'K'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subok</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.empty_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new array with the same shape and type as a given array.</p>
<dl>
<dt>prototype<span class="classifier">array_like</span></dt><dd><p>The shape and data-type of <cite>prototype</cite> define these same attributes
of the returned array.</p>
</dd>
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>Overrides the data type of the result.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.6.0.</span></p>
</div>
</dd>
<dt>order<span class="classifier">{‘C’, ‘F’, ‘A’, or ‘K’}, optional</span></dt><dd><p>Overrides the memory layout of the result. ‘C’ means C-order,
‘F’ means F-order, ‘A’ means ‘F’ if <cite>prototype</cite> is Fortran
contiguous, ‘C’ otherwise. ‘K’ means match the layout of <cite>prototype</cite>
as closely as possible.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.6.0.</span></p>
</div>
</dd>
<dt>subok<span class="classifier">bool, optional.</span></dt><dd><p>If True, then the newly created array will use the sub-class
type of <cite>prototype</cite>, otherwise it will be a base-class array. Defaults
to True.</p>
</dd>
<dt>shape<span class="classifier">int or sequence of ints, optional.</span></dt><dd><p>Overrides the shape of the result. If order=’K’ and the number of
dimensions is unchanged, will try to keep order, otherwise,
order=’C’ is implied.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.17.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>Array of uninitialized (arbitrary) data with the same
shape and type as <cite>prototype</cite>.</p>
</dd>
</dl>
<p>ones_like : Return an array of ones with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full_like : Return a new array with shape of input filled with value.
empty : Return a new uninitialized array.</p>
<p>This function does <em>not</em> initialize the returned array; to do that use
<cite>zeros_like</cite> or <cite>ones_like</cite> instead.  It may be marginally faster than
the functions that do set the array values.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>                         <span class="c1"># a is array-like</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([[-1073741821, -1073741821,           3],    # uninitialized</span>
<span class="go">       [          0,           0, -1073741821]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">],[</span><span class="mf">4.</span><span class="p">,</span><span class="mf">5.</span><span class="p">,</span><span class="mf">6.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([[ -2.00000715e+000,   1.48219694e-323,  -2.00000572e+000], # uninitialized</span>
<span class="go">       [  4.38791518e-305,  -2.00000715e+000,   4.17269252e-309]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt id="numpy.errstate">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">errstate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.errstate" title="Permalink to this definition">¶</a></dt>
<dd><p>Context manager for floating-point error handling.</p>
<p>Using an instance of <cite>errstate</cite> as a context manager allows statements in
that context to execute with a known error handling behavior. Upon entering
the context the error handling is set with <cite>seterr</cite> and <cite>seterrcall</cite>, and
upon exiting it is reset to what it was before.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.17.0: </span><cite>errstate</cite> is also usable as a function decorator, saving
a level of indentation if an entire function is wrapped.
See <code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.ContextDecorator</span></code> for more information.</p>
</div>
<dl class="simple">
<dt>kwargs<span class="classifier">{divide, over, under, invalid}</span></dt><dd><p>Keyword arguments. The valid keywords are the possible floating-point
exceptions. Each keyword should have a string value that defines the
treatment for the particular error. Possible values are
{‘ignore’, ‘warn’, ‘raise’, ‘call’, ‘print’, ‘log’}.</p>
</dd>
</dl>
<p>seterr, geterr, seterrcall, geterrcall</p>
<p>For complete documentation of the types of floating-point exceptions and
treatment options, see <cite>seterr</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">olderr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>  <span class="c1"># Set error handling to known state.</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="mf">0.</span>
<span class="go">array([nan, inf, inf])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;warn&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="mf">0.</span>
<span class="go">array([nan, inf, inf])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">nan</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">2</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">FloatingPointError</span>: <span class="n">invalid value encountered in sqrt</span>
</pre></div>
</div>
<p>Outside the context the error handling behavior has not changed:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geterr</span><span class="p">()</span>
<span class="go">{&#39;divide&#39;: &#39;ignore&#39;, &#39;over&#39;: &#39;ignore&#39;, &#39;under&#39;: &#39;ignore&#39;, &#39;invalid&#39;: &#39;ignore&#39;}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.expand_dims">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">expand_dims</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.expand_dims" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand the shape of an array.</p>
<p>Insert a new axis that will appear at the <cite>axis</cite> position in the expanded
array shape.</p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt>axis<span class="classifier">int or tuple of ints</span></dt><dd><p>Position in the expanded axes where the new axis (or axes) is placed.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 1.13.0: </span>Passing an axis where <code class="docutils literal notranslate"><span class="pre">axis</span> <span class="pre">&gt;</span> <span class="pre">a.ndim</span></code> will be treated as
<code class="docutils literal notranslate"><span class="pre">axis</span> <span class="pre">==</span> <span class="pre">a.ndim</span></code>, and passing <code class="docutils literal notranslate"><span class="pre">axis</span> <span class="pre">&lt;</span> <span class="pre">-a.ndim</span> <span class="pre">-</span> <span class="pre">1</span></code> will
be treated as <code class="docutils literal notranslate"><span class="pre">axis</span> <span class="pre">==</span> <span class="pre">0</span></code>. This behavior is deprecated.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.18.0: </span>A tuple of axes is now supported.  Out of range axes as
described above are now forbidden and raise an <cite>AxisError</cite>.</p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>result<span class="classifier">ndarray</span></dt><dd><p>View of <cite>a</cite> with the number of dimensions increased.</p>
</dd>
</dl>
<p>squeeze : The inverse operation, removing singleton dimensions
reshape : Insert, remove, and combine dimensions, and resize existing ones
doc.indexing, atleast_1d, atleast_2d, atleast_3d</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2,)</span>
</pre></div>
</div>
<p>The following is equivalent to <code class="docutils literal notranslate"><span class="pre">x[np.newaxis,</span> <span class="pre">:]</span></code> or <code class="docutils literal notranslate"><span class="pre">x[np.newaxis]</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([[1, 2]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 2)</span>
</pre></div>
</div>
<p>The following is equivalent to <code class="docutils literal notranslate"><span class="pre">x[:,</span> <span class="pre">np.newaxis]</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([[1],</span>
<span class="go">       [2]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 1)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">axis</span></code> may also be a tuple:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([[[1, 2]]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([[[1],</span>
<span class="go">        [2]]])</span>
</pre></div>
</div>
<p>Note that some examples may use <code class="docutils literal notranslate"><span class="pre">None</span></code> instead of <code class="docutils literal notranslate"><span class="pre">np.newaxis</span></code>.  These
are the same objects:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.extract">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">extract</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">condition</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.extract" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the elements of an array that satisfy some condition.</p>
<p>This is equivalent to <code class="docutils literal notranslate"><span class="pre">np.compress(ravel(condition),</span> <span class="pre">ravel(arr))</span></code>.  If
<cite>condition</cite> is boolean <code class="docutils literal notranslate"><span class="pre">np.extract</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">arr[condition]</span></code>.</p>
<p>Note that <cite>place</cite> does the exact opposite of <cite>extract</cite>.</p>
<dl class="simple">
<dt>condition<span class="classifier">array_like</span></dt><dd><p>An array whose nonzero or True entries indicate the elements of <cite>arr</cite>
to extract.</p>
</dd>
<dt>arr<span class="classifier">array_like</span></dt><dd><p>Input array of the same size as <cite>condition</cite>.</p>
</dd>
</dl>
<dl class="simple">
<dt>extract<span class="classifier">ndarray</span></dt><dd><p>Rank 1 array of values from <cite>arr</cite> where <cite>condition</cite> is True.</p>
</dd>
</dl>
<p>take, put, copyto, compress, place</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">condition</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">condition</span>
<span class="go">array([[ True, False, False,  True],</span>
<span class="go">       [False, False,  True, False],</span>
<span class="go">       [False,  True, False, False]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span>
<span class="go">array([0, 3, 6, 9])</span>
</pre></div>
</div>
<p>If <cite>condition</cite> is boolean:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="p">[</span><span class="n">condition</span><span class="p">]</span>
<span class="go">array([0, 3, 6, 9])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.eye">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">eye</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">N</span></em>, <em class="sig-param"><span class="pre">M=None</span></em>, <em class="sig-param"><span class="pre">k=0</span></em>, <em class="sig-param"><span class="pre">dtype=&lt;class</span> <span class="pre">'float'&gt;</span></em>, <em class="sig-param"><span class="pre">order='C'</span></em>, <em class="sig-param"><span class="pre">*</span></em>, <em class="sig-param"><span class="pre">like=None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.eye" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 2-D array with ones on the diagonal and zeros elsewhere.</p>
<dl>
<dt>N<span class="classifier">int</span></dt><dd><p>Number of rows in the output.</p>
</dd>
<dt>M<span class="classifier">int, optional</span></dt><dd><p>Number of columns in the output. If None, defaults to <cite>N</cite>.</p>
</dd>
<dt>k<span class="classifier">int, optional</span></dt><dd><p>Index of the diagonal: 0 (the default) refers to the main diagonal,
a positive value refers to an upper diagonal, and a negative value
to a lower diagonal.</p>
</dd>
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>Data-type of the returned array.</p>
</dd>
<dt>order<span class="classifier">{‘C’, ‘F’}, optional</span></dt><dd><p>Whether the output should be stored in row-major (C-style) or
column-major (Fortran-style) order in memory.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.14.0.</span></p>
</div>
</dd>
<dt>like<span class="classifier">array_like</span></dt><dd><p>Reference object to allow the creation of arrays which are not
NumPy arrays. If an array-like passed in as <code class="docutils literal notranslate"><span class="pre">like</span></code> supports
the <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> protocol, the result will be defined
by it. In this case, it ensures the creation of an array object
compatible with that passed in via this argument.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.20.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>I<span class="classifier">ndarray of shape (N,M)</span></dt><dd><p>An array where all elements are equal to zero, except for the <cite>k</cite>-th
diagonal, whose values are equal to one.</p>
</dd>
</dl>
<p>identity : (almost) equivalent function
diag : diagonal 2-D array from a 1-D array specified by the user.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([[1, 0],</span>
<span class="go">       [0, 1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[0.,  1.,  0.],</span>
<span class="go">       [0.,  0.,  1.],</span>
<span class="go">       [0.,  0.,  0.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.fastCopyAndTranspose">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">fastCopyAndTranspose</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.fastCopyAndTranspose" title="Permalink to this definition">¶</a></dt>
<dd><p>_fastCopyAndTranspose(a)</p>
</dd></dl>

<dl class="py function">
<dt id="numpy.fill_diagonal">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">fill_diagonal</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wrap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.fill_diagonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill the main diagonal of the given array of any dimensionality.</p>
<p>For an array <cite>a</cite> with <code class="docutils literal notranslate"><span class="pre">a.ndim</span> <span class="pre">&gt;=</span> <span class="pre">2</span></code>, the diagonal is the list of
locations with indices <code class="docutils literal notranslate"><span class="pre">a[i,</span> <span class="pre">...,</span> <span class="pre">i]</span></code> all identical. This function
modifies the input array in-place, it does not return a value.</p>
<dl class="simple">
<dt>a<span class="classifier">array, at least 2-D.</span></dt><dd><p>Array whose diagonal is to be filled, it gets modified in-place.</p>
</dd>
<dt>val<span class="classifier">scalar or array_like</span></dt><dd><p>Value(s) to write on the diagonal. If <cite>val</cite> is scalar, the value is
written along the diagonal. If array-like, the flattened <cite>val</cite> is
written along the diagonal, repeating if necessary to fill all
diagonal entries.</p>
</dd>
<dt>wrap<span class="classifier">bool</span></dt><dd><p>For tall matrices in NumPy version up to 1.6.2, the
diagonal “wrapped” after N columns. You can have this behavior
with this option. This affects only tall matrices.</p>
</dd>
</dl>
<p>diag_indices, diag_indices_from</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.4.0.</span></p>
</div>
<p>This functionality can be obtained via <cite>diag_indices</cite>, but internally
this version uses a much faster implementation that never constructs the
indices and uses simple slicing.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[5, 0, 0],</span>
<span class="go">       [0, 5, 0],</span>
<span class="go">       [0, 0, 5]])</span>
</pre></div>
</div>
<p>The same function can operate on a 4-D array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>We only show a few blocks for clarity:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">array([[4, 0, 0],</span>
<span class="go">       [0, 0, 0],</span>
<span class="go">       [0, 0, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="go">array([[0, 0, 0],</span>
<span class="go">       [0, 4, 0],</span>
<span class="go">       [0, 0, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="go">array([[0, 0, 0],</span>
<span class="go">       [0, 0, 0],</span>
<span class="go">       [0, 0, 4]])</span>
</pre></div>
</div>
<p>The wrap option affects only tall matrices:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># tall matrices no wrap</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[4, 0, 0],</span>
<span class="go">       [0, 4, 0],</span>
<span class="go">       [0, 0, 4],</span>
<span class="go">       [0, 0, 0],</span>
<span class="go">       [0, 0, 0]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># tall matrices wrap</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">wrap</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[4, 0, 0],</span>
<span class="go">       [0, 4, 0],</span>
<span class="go">       [0, 0, 4],</span>
<span class="go">       [0, 0, 0],</span>
<span class="go">       [4, 0, 0]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># wide matrices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">wrap</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[4, 0, 0, 0, 0],</span>
<span class="go">       [0, 4, 0, 0, 0],</span>
<span class="go">       [0, 0, 4, 0, 0]])</span>
</pre></div>
</div>
<p>The anti-diagonal can be filled by reversing the order of elements
using either <cite>numpy.flipud</cite> or <cite>numpy.fliplr</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="nb">int</span><span class="p">);</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>  <span class="c1"># Horizontal flip</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 0, 1],</span>
<span class="go">       [0, 2, 0],</span>
<span class="go">       [3, 0, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>  <span class="c1"># Vertical flip</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 0, 3],</span>
<span class="go">       [0, 2, 0],</span>
<span class="go">       [1, 0, 0]])</span>
</pre></div>
</div>
<p>Note that the order in which the diagonal is filled varies depending
on the flip function.</p>
</dd></dl>

<dl class="py function">
<dt id="numpy.find_common_type">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">find_common_type</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">array_types</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalar_types</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.find_common_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine common type following standard coercion rules.</p>
<dl class="simple">
<dt>array_types<span class="classifier">sequence</span></dt><dd><p>A list of dtypes or dtype convertible objects representing arrays.</p>
</dd>
<dt>scalar_types<span class="classifier">sequence</span></dt><dd><p>A list of dtypes or dtype convertible objects representing scalars.</p>
</dd>
</dl>
<dl class="simple">
<dt>datatype<span class="classifier">dtype</span></dt><dd><p>The common data type, which is the maximum of <cite>array_types</cite> ignoring
<cite>scalar_types</cite>, unless the maximum of <cite>scalar_types</cite> is of a
different kind (<cite>dtype.kind</cite>). If the kind is not understood, then
None is returned.</p>
</dd>
</dl>
<p>dtype, common_type, can_cast, mintypecode</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">find_common_type</span><span class="p">([],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="nb">complex</span><span class="p">])</span>
<span class="go">dtype(&#39;complex128&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">find_common_type</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">],</span> <span class="p">[])</span>
<span class="go">dtype(&#39;float64&#39;)</span>
</pre></div>
</div>
<p>The standard casting rules ensure that a scalar cannot up-cast an
array unless the scalar is of a fundamentally different kind of data
(i.e. under a different hierarchy in the data type hierarchy) then
the array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">find_common_type</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">])</span>
<span class="go">dtype(&#39;float32&#39;)</span>
</pre></div>
</div>
<p>Complex is of a different type, so it up-casts the float in the
<cite>array_types</cite> argument:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">find_common_type</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">],</span> <span class="p">[</span><span class="nb">complex</span><span class="p">])</span>
<span class="go">dtype(&#39;complex128&#39;)</span>
</pre></div>
</div>
<p>Type specifier strings are convertible to dtypes and can therefore
be used instead of dtypes:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">find_common_type</span><span class="p">([</span><span class="s1">&#39;f4&#39;</span><span class="p">,</span> <span class="s1">&#39;f4&#39;</span><span class="p">,</span> <span class="s1">&#39;i4&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;c8&#39;</span><span class="p">])</span>
<span class="go">dtype(&#39;complex128&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt id="numpy.finfo">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">finfo</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dtype</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.finfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Machine limits for floating point types.</p>
<dl class="simple">
<dt>bits<span class="classifier">int</span></dt><dd><p>The number of bits occupied by the type.</p>
</dd>
<dt>eps<span class="classifier">float</span></dt><dd><p>The difference between 1.0 and the next smallest representable float
larger than 1.0. For example, for 64-bit binary floats in the IEEE-754
standard, <code class="docutils literal notranslate"><span class="pre">eps</span> <span class="pre">=</span> <span class="pre">2**-52</span></code>, approximately 2.22e-16.</p>
</dd>
<dt>epsneg<span class="classifier">float</span></dt><dd><p>The difference between 1.0 and the next smallest representable float
less than 1.0. For example, for 64-bit binary floats in the IEEE-754
standard, <code class="docutils literal notranslate"><span class="pre">epsneg</span> <span class="pre">=</span> <span class="pre">2**-53</span></code>, approximately 1.11e-16.</p>
</dd>
<dt>iexp<span class="classifier">int</span></dt><dd><p>The number of bits in the exponent portion of the floating point
representation.</p>
</dd>
<dt>machar<span class="classifier">MachAr</span></dt><dd><p>The object which calculated these parameters and holds more
detailed information.</p>
</dd>
<dt>machep<span class="classifier">int</span></dt><dd><p>The exponent that yields <cite>eps</cite>.</p>
</dd>
<dt>max<span class="classifier">floating point number of the appropriate type</span></dt><dd><p>The largest representable number.</p>
</dd>
<dt>maxexp<span class="classifier">int</span></dt><dd><p>The smallest positive power of the base (2) that causes overflow.</p>
</dd>
<dt>min<span class="classifier">floating point number of the appropriate type</span></dt><dd><p>The smallest representable number, typically <code class="docutils literal notranslate"><span class="pre">-max</span></code>.</p>
</dd>
<dt>minexp<span class="classifier">int</span></dt><dd><p>The most negative power of the base (2) consistent with there
being no leading 0’s in the mantissa.</p>
</dd>
<dt>negep<span class="classifier">int</span></dt><dd><p>The exponent that yields <cite>epsneg</cite>.</p>
</dd>
<dt>nexp<span class="classifier">int</span></dt><dd><p>The number of bits in the exponent including its sign and bias.</p>
</dd>
<dt>nmant<span class="classifier">int</span></dt><dd><p>The number of bits in the mantissa.</p>
</dd>
<dt>precision<span class="classifier">int</span></dt><dd><p>The approximate number of decimal digits to which this kind of
float is precise.</p>
</dd>
<dt>resolution<span class="classifier">floating point number of the appropriate type</span></dt><dd><p>The approximate decimal resolution of this type, i.e.,
<code class="docutils literal notranslate"><span class="pre">10**-precision</span></code>.</p>
</dd>
<dt>tiny<span class="classifier">float</span></dt><dd><p>The smallest positive floating point number with full precision
(see Notes).</p>
</dd>
</dl>
<dl class="simple">
<dt>dtype<span class="classifier">float, dtype, or instance</span></dt><dd><p>Kind of floating point data-type about which to get information.</p>
</dd>
</dl>
<p>MachAr : The implementation of the tests that produce this information.
iinfo : The equivalent for integer data types.
spacing : The distance between a value and the nearest adjacent number
nextafter : The next floating point value after x1 towards x2</p>
<p>For developers of NumPy: do not instantiate this at the module level.
The initial calculation of these parameters is expensive and negatively
impacts import times.  These objects are cached, so calling <code class="docutils literal notranslate"><span class="pre">finfo()</span></code>
repeatedly inside your functions is not a problem.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">tiny</span></code> is not actually the smallest positive representable
value in a NumPy floating point type. As in the IEEE-754 standard <a href="#id81"><span class="problematic" id="id22">[1]_</span></a>,
NumPy floating point types make use of subnormal numbers to fill the
gap between 0 and <code class="docutils literal notranslate"><span class="pre">tiny</span></code>. However, subnormal numbers may have
significantly reduced precision <a href="#id82"><span class="problematic" id="id23">[2]_</span></a>.</p>
<dl class="footnote brackets">
<dt class="label" id="id24"><span class="brackets">1</span></dt>
<dd><p>IEEE Standard for Floating-Point Arithmetic, IEEE Std 754-2008,
pp.1-70, 2008, <a class="reference external" href="http://www.doi.org/10.1109/IEEESTD.2008.4610935">http://www.doi.org/10.1109/IEEESTD.2008.4610935</a></p>
</dd>
<dt class="label" id="id25"><span class="brackets">2</span></dt>
<dd><p>Wikipedia, “Denormal Numbers”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Denormal_number">https://en.wikipedia.org/wiki/Denormal_number</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="numpy.fix">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">fix</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.fix" title="Permalink to this definition">¶</a></dt>
<dd><p>Round to nearest integer towards zero.</p>
<p>Round an array of floats element-wise to nearest integer towards zero.
The rounded values are returned as floats.</p>
<dl class="simple">
<dt>x<span class="classifier">array_like</span></dt><dd><p>An array of floats to be rounded</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the input broadcasts to. If not provided or None, a
freshly-allocated array is returned.</p>
</dd>
</dl>
<dl>
<dt>out<span class="classifier">ndarray of floats</span></dt><dd><p>A float array with the same dimensions as the input.
If second argument is not supplied then a float array is returned
with the rounded values.</p>
<p>If a second argument is supplied the result is stored there.
The return value <cite>out</cite> is then a reference to that array.</p>
</dd>
</dl>
<p>rint, trunc, floor, ceil
around : Round to given number of decimals</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fix</span><span class="p">(</span><span class="mf">3.14</span><span class="p">)</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fix</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fix</span><span class="p">([</span><span class="mf">2.1</span><span class="p">,</span> <span class="mf">2.9</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.1</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.9</span><span class="p">])</span>
<span class="go">array([ 2.,  2., -2., -2.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt id="numpy.flatiter">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">flatiter</span></code><a class="headerlink" href="#numpy.flatiter" title="Permalink to this definition">¶</a></dt>
<dd><p>Flat iterator object to iterate over arrays.</p>
<p>A <cite>flatiter</cite> iterator is returned by <code class="docutils literal notranslate"><span class="pre">x.flat</span></code> for any array <cite>x</cite>.
It allows iterating over the array as if it were a 1-D array,
either in a for-loop or by calling its <cite>next</cite> method.</p>
<p>Iteration is done in row-major, C-style order (the last
index varying the fastest). The iterator can also be indexed using
basic slicing or advanced indexing.</p>
<p>ndarray.flat : Return a flat iterator over an array.
ndarray.flatten : Returns a flattened copy of an array.</p>
<p>A <cite>flatiter</cite> iterator can not be constructed directly from Python code
by calling the <cite>flatiter</cite> constructor.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fl</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">flat</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">fl</span><span class="p">)</span>
<span class="go">&lt;class &#39;numpy.flatiter&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">fl</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">0</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="go">4</span>
<span class="go">5</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fl</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="go">array([2, 3])</span>
</pre></div>
</div>
<dl class="py attribute">
<dt id="numpy.flatiter.base">
<code class="sig-name descname"><span class="pre">base</span></code><a class="headerlink" href="#numpy.flatiter.base" title="Permalink to this definition">¶</a></dt>
<dd><p>A reference to the array that is iterated over.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fl</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">flat</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fl</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="n">x</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.flatiter.coords">
<code class="sig-name descname"><span class="pre">coords</span></code><a class="headerlink" href="#numpy.flatiter.coords" title="Permalink to this definition">¶</a></dt>
<dd><p>An N-dimensional tuple of current coordinates.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fl</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">flat</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fl</span><span class="o">.</span><span class="n">coords</span>
<span class="go">(0, 0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">fl</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fl</span><span class="o">.</span><span class="n">coords</span>
<span class="go">(0, 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.flatiter.copy">
<code class="sig-name descname"><span class="pre">copy</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.flatiter.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a copy of the iterator as a 1-D array.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fl</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">flat</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fl</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="go">array([0, 1, 2, 3, 4, 5])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.flatiter.index">
<code class="sig-name descname"><span class="pre">index</span></code><a class="headerlink" href="#numpy.flatiter.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Current flat index into the array.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fl</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">flat</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fl</span><span class="o">.</span><span class="n">index</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">fl</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fl</span><span class="o">.</span><span class="n">index</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="numpy.flatnonzero">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">flatnonzero</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.flatnonzero" title="Permalink to this definition">¶</a></dt>
<dd><p>Return indices that are non-zero in the flattened version of a.</p>
<p>This is equivalent to np.nonzero(np.ravel(a))[0].</p>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input data.</p>
</dd>
</dl>
<dl class="simple">
<dt>res<span class="classifier">ndarray</span></dt><dd><p>Output array, containing the indices of the elements of <cite>a.ravel()</cite>
that are non-zero.</p>
</dd>
</dl>
<p>nonzero : Return the indices of the non-zero elements of the input array.
ravel : Return a 1-D array containing the elements of the input array.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([-2, -1,  0,  1,  2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([0, 1, 3, 4])</span>
</pre></div>
</div>
<p>Use the indices of the non-zero elements as an index array to extract
these elements:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
<span class="go">array([-2, -1,  1,  2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt id="numpy.flexible">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">flexible</span></code><a class="headerlink" href="#numpy.flexible" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class of all scalar types without predefined length.
The actual size of these types depends on the specific <cite>np.dtype</cite>
instantiation.</p>
</dd></dl>

<dl class="py function">
<dt id="numpy.flip">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">flip</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.flip" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse the order of elements in an array along the given axis.</p>
<p>The shape of the array is preserved, but the elements are reordered.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.12.0.</span></p>
</div>
<dl>
<dt>m<span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt>axis<span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Axis or axes along which to flip over. The default,
axis=None, will flip over all of the axes of the input array.
If axis is negative it counts from the last to the first axis.</p>
<p>If axis is a tuple of ints, flipping is performed on all of the axes
specified in the tuple.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.15.0: </span>None and tuples of axes are supported</p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">array_like</span></dt><dd><p>A view of <cite>m</cite> with the entries of axis reversed.  Since a view is
returned, this operation is done in constant time.</p>
</dd>
</dl>
<p>flipud : Flip an array vertically (axis=0).
fliplr : Flip an array horizontally (axis=1).</p>
<p>flip(m, 0) is equivalent to flipud(m).</p>
<p>flip(m, 1) is equivalent to fliplr(m).</p>
<p>flip(m, n) corresponds to <code class="docutils literal notranslate"><span class="pre">m[...,::-1,...]</span></code> with <code class="docutils literal notranslate"><span class="pre">::-1</span></code> at position n.</p>
<p>flip(m) corresponds to <code class="docutils literal notranslate"><span class="pre">m[::-1,::-1,...,::-1]</span></code> with <code class="docutils literal notranslate"><span class="pre">::-1</span></code> at all
positions.</p>
<p>flip(m, (0, 1)) corresponds to <code class="docutils literal notranslate"><span class="pre">m[::-1,::-1,...]</span></code> with <code class="docutils literal notranslate"><span class="pre">::-1</span></code> at
position 0 and position 1.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">array([[[0, 1],</span>
<span class="go">        [2, 3]],</span>
<span class="go">       [[4, 5],</span>
<span class="go">        [6, 7]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">array([[[4, 5],</span>
<span class="go">        [6, 7]],</span>
<span class="go">       [[0, 1],</span>
<span class="go">        [2, 3]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">array([[[2, 3],</span>
<span class="go">        [0, 1]],</span>
<span class="go">       [[6, 7],</span>
<span class="go">        [4, 5]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">array([[[7, 6],</span>
<span class="go">        [5, 4]],</span>
<span class="go">       [[3, 2],</span>
<span class="go">        [1, 0]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">array([[[5, 4],</span>
<span class="go">        [7, 6]],</span>
<span class="go">       [[1, 0],</span>
<span class="go">        [3, 2]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="n">A</span><span class="p">[:,:,::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.fliplr">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">fliplr</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.fliplr" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse the order of elements along axis 1 (left/right).</p>
<p>For a 2-D array, this flips the entries in each row in the left/right
direction. Columns are preserved, but appear in a different order than
before.</p>
<dl class="simple">
<dt>m<span class="classifier">array_like</span></dt><dd><p>Input array, must be at least 2-D.</p>
</dd>
</dl>
<dl class="simple">
<dt>f<span class="classifier">ndarray</span></dt><dd><p>A view of <cite>m</cite> with the columns reversed.  Since a view
is returned, this operation is <span class="math notranslate nohighlight">\(\mathcal O(1)\)</span>.</p>
</dd>
</dl>
<p>flipud : Flip array in the up/down direction.
flip : Flip array in one or more dimesions.
rot90 : Rotate array counterclockwise.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">m[:,::-1]</span></code> or <code class="docutils literal notranslate"><span class="pre">np.flip(m,</span> <span class="pre">axis=1)</span></code>.
Requires the array to be at least 2-D.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">,</span><span class="mf">3.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">array([[1.,  0.,  0.],</span>
<span class="go">       [0.,  2.,  0.],</span>
<span class="go">       [0.,  0.,  3.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">array([[0.,  0.,  1.],</span>
<span class="go">       [0.,  2.,  0.],</span>
<span class="go">       [3.,  0.,  0.]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">==</span> <span class="n">A</span><span class="p">[:,::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.flipud">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">flipud</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.flipud" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse the order of elements along axis 0 (up/down).</p>
<p>For a 2-D array, this flips the entries in each column in the up/down
direction. Rows are preserved, but appear in a different order than before.</p>
<dl class="simple">
<dt>m<span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">array_like</span></dt><dd><p>A view of <cite>m</cite> with the rows reversed.  Since a view is
returned, this operation is <span class="math notranslate nohighlight">\(\mathcal O(1)\)</span>.</p>
</dd>
</dl>
<p>fliplr : Flip array in the left/right direction.
flip : Flip array in one or more dimesions.
rot90 : Rotate array counterclockwise.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">m[::-1,</span> <span class="pre">...]</span></code> or <code class="docutils literal notranslate"><span class="pre">np.flip(m,</span> <span class="pre">axis=0)</span></code>.
Requires the array to be at least 1-D.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">array([[1.,  0.,  0.],</span>
<span class="go">       [0.,  2.,  0.],</span>
<span class="go">       [0.,  0.,  3.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">array([[0.,  0.,  3.],</span>
<span class="go">       [0.,  2.,  0.],</span>
<span class="go">       [1.,  0.,  0.]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">==</span> <span class="n">A</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">array([2, 1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt id="numpy.float128">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">float128</span></code><a class="headerlink" href="#numpy.float128" title="Permalink to this definition">¶</a></dt>
<dd><p>Extended-precision floating-point number type, compatible with C
<code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">double</span></code> but not necessarily with IEEE 754 quadruple-precision.</p>
<dl class="field-list simple">
<dt class="field-odd">Character code</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">'g'</span></code></p>
</dd>
<dt class="field-even">Canonical name</dt>
<dd class="field-even"><p><cite>numpy.longdouble</cite></p>
</dd>
<dt class="field-odd">Alias</dt>
<dd class="field-odd"><p><cite>numpy.longfloat</cite></p>
</dd>
<dt class="field-even">Alias on this platform (Linux x86_64)</dt>
<dd class="field-even"><p><cite>numpy.float128</cite>: 128-bit extended-precision floating-point number type.</p>
</dd>
</dl>
<dl class="py method">
<dt id="numpy.float128.as_integer_ratio">
<code class="sig-name descname"><span class="pre">as_integer_ratio</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.float128.as_integer_ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a pair of integers, whose ratio is exactly equal to the original
floating point number, and with a positive denominator.
Raise <cite>OverflowError</cite> on infinities and a <cite>ValueError</cite> on NaNs.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">longdouble</span><span class="p">(</span><span class="mf">10.0</span><span class="p">)</span><span class="o">.</span><span class="n">as_integer_ratio</span><span class="p">()</span>
<span class="go">(10, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">longdouble</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">as_integer_ratio</span><span class="p">()</span>
<span class="go">(0, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">longdouble</span><span class="p">(</span><span class="o">-</span><span class="mf">.25</span><span class="p">)</span><span class="o">.</span><span class="n">as_integer_ratio</span><span class="p">()</span>
<span class="go">(-1, 4)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="numpy.float16">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">float16</span></code><a class="headerlink" href="#numpy.float16" title="Permalink to this definition">¶</a></dt>
<dd><p>Half-precision floating-point number type.</p>
<dl class="field-list simple">
<dt class="field-odd">Character code</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">'e'</span></code></p>
</dd>
<dt class="field-even">Canonical name</dt>
<dd class="field-even"><p><cite>numpy.half</cite></p>
</dd>
<dt class="field-odd">Alias on this platform (Linux x86_64)</dt>
<dd class="field-odd"><p><cite>numpy.float16</cite>: 16-bit-precision floating-point number type: sign bit, 5 bits exponent, 10 bits mantissa.</p>
</dd>
</dl>
<dl class="py method">
<dt id="numpy.float16.as_integer_ratio">
<code class="sig-name descname"><span class="pre">as_integer_ratio</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.float16.as_integer_ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a pair of integers, whose ratio is exactly equal to the original
floating point number, and with a positive denominator.
Raise <cite>OverflowError</cite> on infinities and a <cite>ValueError</cite> on NaNs.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">half</span><span class="p">(</span><span class="mf">10.0</span><span class="p">)</span><span class="o">.</span><span class="n">as_integer_ratio</span><span class="p">()</span>
<span class="go">(10, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">half</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">as_integer_ratio</span><span class="p">()</span>
<span class="go">(0, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">half</span><span class="p">(</span><span class="o">-</span><span class="mf">.25</span><span class="p">)</span><span class="o">.</span><span class="n">as_integer_ratio</span><span class="p">()</span>
<span class="go">(-1, 4)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="numpy.float32">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">float32</span></code><a class="headerlink" href="#numpy.float32" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-precision floating-point number type, compatible with C <code class="docutils literal notranslate"><span class="pre">float</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Character code</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">'f'</span></code></p>
</dd>
<dt class="field-even">Canonical name</dt>
<dd class="field-even"><p><cite>numpy.single</cite></p>
</dd>
<dt class="field-odd">Alias on this platform (Linux x86_64)</dt>
<dd class="field-odd"><p><cite>numpy.float32</cite>: 32-bit-precision floating-point number type: sign bit, 8 bits exponent, 23 bits mantissa.</p>
</dd>
</dl>
<dl class="py method">
<dt id="numpy.float32.as_integer_ratio">
<code class="sig-name descname"><span class="pre">as_integer_ratio</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.float32.as_integer_ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a pair of integers, whose ratio is exactly equal to the original
floating point number, and with a positive denominator.
Raise <cite>OverflowError</cite> on infinities and a <cite>ValueError</cite> on NaNs.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">single</span><span class="p">(</span><span class="mf">10.0</span><span class="p">)</span><span class="o">.</span><span class="n">as_integer_ratio</span><span class="p">()</span>
<span class="go">(10, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">single</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">as_integer_ratio</span><span class="p">()</span>
<span class="go">(0, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">single</span><span class="p">(</span><span class="o">-</span><span class="mf">.25</span><span class="p">)</span><span class="o">.</span><span class="n">as_integer_ratio</span><span class="p">()</span>
<span class="go">(-1, 4)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="numpy.float64">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">float64</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.float64" title="Permalink to this definition">¶</a></dt>
<dd><p>Double-precision floating-point number type, compatible with Python <cite>float</cite>
and C <code class="docutils literal notranslate"><span class="pre">double</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Character code</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">'d'</span></code></p>
</dd>
<dt class="field-even">Canonical name</dt>
<dd class="field-even"><p><cite>numpy.double</cite></p>
</dd>
<dt class="field-odd">Alias</dt>
<dd class="field-odd"><p><cite>numpy.float_</cite></p>
</dd>
<dt class="field-even">Alias on this platform (Linux x86_64)</dt>
<dd class="field-even"><p><cite>numpy.float64</cite>: 64-bit precision floating-point number type: sign bit, 11 bits exponent, 52 bits mantissa.</p>
</dd>
</dl>
<dl class="py method">
<dt id="numpy.float64.as_integer_ratio">
<code class="sig-name descname"><span class="pre">as_integer_ratio</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.float64.as_integer_ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a pair of integers, whose ratio is exactly equal to the original
floating point number, and with a positive denominator.
Raise <cite>OverflowError</cite> on infinities and a <cite>ValueError</cite> on NaNs.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="mf">10.0</span><span class="p">)</span><span class="o">.</span><span class="n">as_integer_ratio</span><span class="p">()</span>
<span class="go">(10, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">as_integer_ratio</span><span class="p">()</span>
<span class="go">(0, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="o">-</span><span class="mf">.25</span><span class="p">)</span><span class="o">.</span><span class="n">as_integer_ratio</span><span class="p">()</span>
<span class="go">(-1, 4)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py attribute">
<dt id="numpy.float_">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">float_</span></code><a class="headerlink" href="#numpy.float_" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.float64" title="numpy.float64"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.float64</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt id="numpy.floating">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">floating</span></code><a class="headerlink" href="#numpy.floating" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class of all floating-point scalar types.</p>
</dd></dl>

<dl class="py function">
<dt id="numpy.format_float_positional">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">format_float_positional</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unique</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fractional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'k'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sign</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad_left</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad_right</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_digits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.format_float_positional" title="Permalink to this definition">¶</a></dt>
<dd><p>Format a floating-point scalar as a decimal string in positional notation.</p>
<p>Provides control over rounding, trimming and padding. Uses and assumes
IEEE unbiased rounding. Uses the “Dragon4” algorithm.</p>
<dl>
<dt>x<span class="classifier">python float or numpy floating scalar</span></dt><dd><p>Value to format.</p>
</dd>
<dt>precision<span class="classifier">non-negative integer or None, optional</span></dt><dd><p>Maximum number of digits to print. May be None if <cite>unique</cite> is
<cite>True</cite>, but must be an integer if unique is <cite>False</cite>.</p>
</dd>
<dt>unique<span class="classifier">boolean, optional</span></dt><dd><p>If <cite>True</cite>, use a digit-generation strategy which gives the shortest
representation which uniquely identifies the floating-point number from
other values of the same type, by judicious rounding. If <cite>precision</cite>
is given fewer digits than necessary can be printed, or if <cite>min_digits</cite>
is given more can be printed, in which cases the last digit is rounded
with unbiased rounding.
If <cite>False</cite>, digits are generated as if printing an infinite-precision
value and stopping after <cite>precision</cite> digits, rounding the remaining
value with unbiased rounding</p>
</dd>
<dt>fractional<span class="classifier">boolean, optional</span></dt><dd><p>If <cite>True</cite>, the cutoffs of <cite>precision</cite> and <cite>min_digits</cite> refer to the
total number of digits after the decimal point, including leading
zeros.
If <cite>False</cite>, <cite>precision</cite> and <cite>min_digits</cite> refer to the total number of
significant digits, before or after the decimal point, ignoring leading
zeros.</p>
</dd>
<dt>trim<span class="classifier">one of ‘k’, ‘.’, ‘0’, ‘-‘, optional</span></dt><dd><p>Controls post-processing trimming of trailing digits, as follows:</p>
<ul class="simple">
<li><p>‘k’ : keep trailing zeros, keep decimal point (no trimming)</p></li>
<li><p>‘.’ : trim all trailing zeros, leave decimal point</p></li>
<li><p>‘0’ : trim all but the zero before the decimal point. Insert the
zero if it is missing.</p></li>
<li><p>‘-‘ : trim trailing zeros and any trailing decimal point</p></li>
</ul>
</dd>
<dt>sign<span class="classifier">boolean, optional</span></dt><dd><p>Whether to show the sign for positive values.</p>
</dd>
<dt>pad_left<span class="classifier">non-negative integer, optional</span></dt><dd><p>Pad the left side of the string with whitespace until at least that
many characters are to the left of the decimal point.</p>
</dd>
<dt>pad_right<span class="classifier">non-negative integer, optional</span></dt><dd><p>Pad the right side of the string with whitespace until at least that
many characters are to the right of the decimal point.</p>
</dd>
<dt>min_digits<span class="classifier">non-negative integer or None, optional</span></dt><dd><p>Minimum number of digits to print. Only has an effect if <cite>unique=True</cite>
in which case additional digits past those necessary to uniquely
identify the value may be printed, rounding the last additional digit.</p>
<p>– versionadded:: 1.21.0</p>
</dd>
</dl>
<dl class="simple">
<dt>rep<span class="classifier">string</span></dt><dd><p>The string representation of the floating point value</p>
</dd>
</dl>
<p>format_float_scientific</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">format_float_positional</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
<span class="go">&#39;3.1415927&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">format_float_positional</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
<span class="go">&#39;3.14&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">format_float_positional</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">(</span><span class="mf">0.3</span><span class="p">))</span>
<span class="go">&#39;0.3&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">format_float_positional</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">(</span><span class="mf">0.3</span><span class="p">),</span> <span class="n">unique</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="go">&#39;0.3000488281&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.format_float_scientific">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">format_float_scientific</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unique</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'k'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sign</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad_left</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exp_digits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_digits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.format_float_scientific" title="Permalink to this definition">¶</a></dt>
<dd><p>Format a floating-point scalar as a decimal string in scientific notation.</p>
<p>Provides control over rounding, trimming and padding. Uses and assumes
IEEE unbiased rounding. Uses the “Dragon4” algorithm.</p>
<dl>
<dt>x<span class="classifier">python float or numpy floating scalar</span></dt><dd><p>Value to format.</p>
</dd>
<dt>precision<span class="classifier">non-negative integer or None, optional</span></dt><dd><p>Maximum number of digits to print. May be None if <cite>unique</cite> is
<cite>True</cite>, but must be an integer if unique is <cite>False</cite>.</p>
</dd>
<dt>unique<span class="classifier">boolean, optional</span></dt><dd><p>If <cite>True</cite>, use a digit-generation strategy which gives the shortest
representation which uniquely identifies the floating-point number from
other values of the same type, by judicious rounding. If <cite>precision</cite>
is given fewer digits than necessary can be printed. If <cite>min_digits</cite>
is given more can be printed, in which cases the last digit is rounded
with unbiased rounding.
If <cite>False</cite>, digits are generated as if printing an infinite-precision
value and stopping after <cite>precision</cite> digits, rounding the remaining
value with unbiased rounding</p>
</dd>
<dt>trim<span class="classifier">one of ‘k’, ‘.’, ‘0’, ‘-‘, optional</span></dt><dd><p>Controls post-processing trimming of trailing digits, as follows:</p>
<ul class="simple">
<li><p>‘k’ : keep trailing zeros, keep decimal point (no trimming)</p></li>
<li><p>‘.’ : trim all trailing zeros, leave decimal point</p></li>
<li><p>‘0’ : trim all but the zero before the decimal point. Insert the
zero if it is missing.</p></li>
<li><p>‘-‘ : trim trailing zeros and any trailing decimal point</p></li>
</ul>
</dd>
<dt>sign<span class="classifier">boolean, optional</span></dt><dd><p>Whether to show the sign for positive values.</p>
</dd>
<dt>pad_left<span class="classifier">non-negative integer, optional</span></dt><dd><p>Pad the left side of the string with whitespace until at least that
many characters are to the left of the decimal point.</p>
</dd>
<dt>exp_digits<span class="classifier">non-negative integer, optional</span></dt><dd><p>Pad the exponent with zeros until it contains at least this many digits.
If omitted, the exponent will be at least 2 digits.</p>
</dd>
<dt>min_digits<span class="classifier">non-negative integer or None, optional</span></dt><dd><p>Minimum number of digits to print. This only has an effect for
<cite>unique=True</cite>. In that case more digits than necessary to uniquely
identify the value may be printed and rounded unbiased.</p>
<p>– versionadded:: 1.21.0</p>
</dd>
</dl>
<dl class="simple">
<dt>rep<span class="classifier">string</span></dt><dd><p>The string representation of the floating point value</p>
</dd>
</dl>
<p>format_float_positional</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">format_float_scientific</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
<span class="go">&#39;3.1415927e+00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="mf">1.23e24</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">format_float_scientific</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="go">&#39;1.230000071797338e+24&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">format_float_scientific</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">exp_digits</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">&#39;1.23e+0024&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt id="numpy.format_parser">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">format_parser</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">formats</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">names</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">titles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aligned</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">byteorder</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.format_parser" title="Permalink to this definition">¶</a></dt>
<dd><p>Class to convert formats, names, titles description to a dtype.</p>
<p>After constructing the format_parser object, the dtype attribute is
the converted data-type:
<code class="docutils literal notranslate"><span class="pre">dtype</span> <span class="pre">=</span> <span class="pre">format_parser(formats,</span> <span class="pre">names,</span> <span class="pre">titles).dtype</span></code></p>
<dl class="simple">
<dt>dtype<span class="classifier">dtype</span></dt><dd><p>The converted data-type.</p>
</dd>
</dl>
<dl class="simple">
<dt>formats<span class="classifier">str or list of str</span></dt><dd><p>The format description, either specified as a string with
comma-separated format descriptions in the form <code class="docutils literal notranslate"><span class="pre">'f8,</span> <span class="pre">i4,</span> <span class="pre">a5'</span></code>, or
a list of format description strings  in the form
<code class="docutils literal notranslate"><span class="pre">['f8',</span> <span class="pre">'i4',</span> <span class="pre">'a5']</span></code>.</p>
</dd>
<dt>names<span class="classifier">str or list/tuple of str</span></dt><dd><p>The field names, either specified as a comma-separated string in the
form <code class="docutils literal notranslate"><span class="pre">'col1,</span> <span class="pre">col2,</span> <span class="pre">col3'</span></code>, or as a list or tuple of strings in the
form <code class="docutils literal notranslate"><span class="pre">['col1',</span> <span class="pre">'col2',</span> <span class="pre">'col3']</span></code>.
An empty list can be used, in that case default field names
(‘f0’, ‘f1’, …) are used.</p>
</dd>
<dt>titles<span class="classifier">sequence</span></dt><dd><p>Sequence of title strings. An empty list can be used to leave titles
out.</p>
</dd>
<dt>aligned<span class="classifier">bool, optional</span></dt><dd><p>If True, align the fields by padding as the C-compiler would.
Default is False.</p>
</dd>
<dt>byteorder<span class="classifier">str, optional</span></dt><dd><p>If specified, all the fields will be changed to the
provided byte-order.  Otherwise, the default byte-order is
used. For all available string specifiers, see <cite>dtype.newbyteorder</cite>.</p>
</dd>
</dl>
<p>dtype, typename, sctype2char</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">format_parser</span><span class="p">([</span><span class="s1">&#39;&lt;f8&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i4&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;a5&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;col1&#39;</span><span class="p">,</span> <span class="s1">&#39;col2&#39;</span><span class="p">,</span> <span class="s1">&#39;col3&#39;</span><span class="p">],</span>
<span class="gp">... </span>                 <span class="p">[</span><span class="s1">&#39;T1&#39;</span><span class="p">,</span> <span class="s1">&#39;T2&#39;</span><span class="p">,</span> <span class="s1">&#39;T3&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype([((&#39;T1&#39;, &#39;col1&#39;), &#39;&lt;f8&#39;), ((&#39;T2&#39;, &#39;col2&#39;), &#39;&lt;i4&#39;), ((&#39;T3&#39;, &#39;col3&#39;), &#39;S5&#39;)])</span>
</pre></div>
</div>
<p><cite>names</cite> and/or <cite>titles</cite> can be empty lists. If <cite>titles</cite> is an empty list,
titles will simply not appear. If <cite>names</cite> is empty, default field names
will be used.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">format_parser</span><span class="p">([</span><span class="s1">&#39;f8&#39;</span><span class="p">,</span> <span class="s1">&#39;i4&#39;</span><span class="p">,</span> <span class="s1">&#39;a5&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;col1&#39;</span><span class="p">,</span> <span class="s1">&#39;col2&#39;</span><span class="p">,</span> <span class="s1">&#39;col3&#39;</span><span class="p">],</span>
<span class="gp">... </span>                 <span class="p">[])</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype([(&#39;col1&#39;, &#39;&lt;f8&#39;), (&#39;col2&#39;, &#39;&lt;i4&#39;), (&#39;col3&#39;, &#39;&lt;S5&#39;)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">format_parser</span><span class="p">([</span><span class="s1">&#39;&lt;f8&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i4&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;a5&#39;</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[])</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype([(&#39;f0&#39;, &#39;&lt;f8&#39;), (&#39;f1&#39;, &#39;&lt;i4&#39;), (&#39;f2&#39;, &#39;S5&#39;)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.frombuffer">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">frombuffer</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buffer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">like</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.frombuffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret a buffer as a 1-dimensional array.</p>
<dl>
<dt>buffer<span class="classifier">buffer_like</span></dt><dd><p>An object that exposes the buffer interface.</p>
</dd>
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>Data-type of the returned array; default: float.</p>
</dd>
<dt>count<span class="classifier">int, optional</span></dt><dd><p>Number of items to read. <code class="docutils literal notranslate"><span class="pre">-1</span></code> means all data in the buffer.</p>
</dd>
<dt>offset<span class="classifier">int, optional</span></dt><dd><p>Start reading the buffer from this offset (in bytes); default: 0.</p>
</dd>
<dt>like<span class="classifier">array_like</span></dt><dd><p>Reference object to allow the creation of arrays which are not
NumPy arrays. If an array-like passed in as <code class="docutils literal notranslate"><span class="pre">like</span></code> supports
the <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> protocol, the result will be defined
by it. In this case, it ensures the creation of an array object
compatible with that passed in via this argument.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.20.0.</span></p>
</div>
</dd>
</dl>
<p>If the buffer has data that is not in machine byte-order, this should
be specified as part of the data-type, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">(</span><span class="s1">&#39;&gt;&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span> 
</pre></div>
</div>
<p>The data of the resulting array will not be byteswapped, but will be
interpreted correctly.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;hello world&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;S1&#39;</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="go">array([b&#39;w&#39;, b&#39;o&#39;, b&#39;r&#39;, b&#39;l&#39;, b&#39;d&#39;], dtype=&#39;|S1&#39;)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x01\x02</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="go">array([1, 2], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x01\x02\x03\x04\x05</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">array([1, 2, 3], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.fromfile">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">fromfile</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">like</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.fromfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct an array from data in a text or binary file.</p>
<p>A highly efficient way of reading binary data with a known data-type,
as well as parsing simply formatted text files.  Data written using the
<cite>tofile</cite> method can be read using this function.</p>
<dl>
<dt>file<span class="classifier">file or str or Path</span></dt><dd><p>Open file object or filename.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.17.0: </span><cite>pathlib.Path</cite> objects are now accepted.</p>
</div>
</dd>
<dt>dtype<span class="classifier">data-type</span></dt><dd><p>Data type of the returned array.
For binary files, it is used to determine the size and byte-order
of the items in the file.
Most builtin numeric types are supported and extension types may be supported.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.18.0: </span>Complex dtypes.</p>
</div>
</dd>
<dt>count<span class="classifier">int</span></dt><dd><p>Number of items to read. <code class="docutils literal notranslate"><span class="pre">-1</span></code> means all items (i.e., the complete
file).</p>
</dd>
<dt>sep<span class="classifier">str</span></dt><dd><p>Separator between items if file is a text file.
Empty (“”) separator means the file should be treated as binary.
Spaces (” “) in the separator match zero or more whitespace characters.
A separator consisting only of spaces must match at least one
whitespace.</p>
</dd>
<dt>offset<span class="classifier">int</span></dt><dd><p>The offset (in bytes) from the file’s current position. Defaults to 0.
Only permitted for binary files.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.17.0.</span></p>
</div>
</dd>
<dt>like<span class="classifier">array_like</span></dt><dd><p>Reference object to allow the creation of arrays which are not
NumPy arrays. If an array-like passed in as <code class="docutils literal notranslate"><span class="pre">like</span></code> supports
the <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> protocol, the result will be defined
by it. In this case, it ensures the creation of an array object
compatible with that passed in via this argument.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.20.0.</span></p>
</div>
</dd>
</dl>
<p>load, save
ndarray.tofile
loadtxt : More flexible way of loading data from a text file.</p>
<p>Do not rely on the combination of <cite>tofile</cite> and <cite>fromfile</cite> for
data storage, as the binary files generated are not platform
independent.  In particular, no byte-order or data-type information is
saved.  Data can be stored in the platform independent <code class="docutils literal notranslate"><span class="pre">.npy</span></code> format
using <cite>save</cite> and <cite>load</cite> instead.</p>
<p>Construct an ndarray:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">([(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;sec&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)]),</span>
<span class="gp">... </span>               <span class="p">(</span><span class="s1">&#39;temp&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">][</span><span class="s1">&#39;min&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;temp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">98.25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([((10, 0), 98.25)],</span>
<span class="go">      dtype=[(&#39;time&#39;, [(&#39;min&#39;, &#39;&lt;i8&#39;), (&#39;sec&#39;, &#39;&lt;i8&#39;)]), (&#39;temp&#39;, &#39;&lt;f8&#39;)])</span>
</pre></div>
</div>
<p>Save the raw data to disk:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">tempfile</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fname</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkstemp</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
</pre></div>
</div>
<p>Read the raw data from disk:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
<span class="go">array([((10, 0), 98.25)],</span>
<span class="go">      dtype=[(&#39;time&#39;, [(&#39;min&#39;, &#39;&lt;i8&#39;), (&#39;sec&#39;, &#39;&lt;i8&#39;)]), (&#39;temp&#39;, &#39;&lt;f8&#39;)])</span>
</pre></div>
</div>
<p>The recommended way to store and load data:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fname</span> <span class="o">+</span> <span class="s1">&#39;.npy&#39;</span><span class="p">)</span>
<span class="go">array([((10, 0), 98.25)],</span>
<span class="go">      dtype=[(&#39;time&#39;, [(&#39;min&#39;, &#39;&lt;i8&#39;), (&#39;sec&#39;, &#39;&lt;i8&#39;)]), (&#39;temp&#39;, &#39;&lt;f8&#39;)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.fromfunction">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">fromfunction</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">function</span></em>, <em class="sig-param"><span class="pre">shape</span></em>, <em class="sig-param"><span class="pre">*</span></em>, <em class="sig-param"><span class="pre">dtype=&lt;class</span> <span class="pre">'float'&gt;</span></em>, <em class="sig-param"><span class="pre">like=None</span></em>, <em class="sig-param"><span class="pre">**kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.fromfunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct an array by executing a function over each coordinate.</p>
<p>The resulting array therefore has a value <code class="docutils literal notranslate"><span class="pre">fn(x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code> at
coordinate <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code>.</p>
<dl>
<dt>function<span class="classifier">callable</span></dt><dd><p>The function is called with N parameters, where N is the rank of
<cite>shape</cite>.  Each parameter represents the coordinates of the array
varying along a specific axis.  For example, if <cite>shape</cite>
were <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">2)</span></code>, then the parameters would be
<code class="docutils literal notranslate"><span class="pre">array([[0,</span> <span class="pre">0],</span> <span class="pre">[1,</span> <span class="pre">1]])</span></code> and <code class="docutils literal notranslate"><span class="pre">array([[0,</span> <span class="pre">1],</span> <span class="pre">[0,</span> <span class="pre">1]])</span></code></p>
</dd>
<dt>shape<span class="classifier">(N,) tuple of ints</span></dt><dd><p>Shape of the output array, which also determines the shape of
the coordinate arrays passed to <cite>function</cite>.</p>
</dd>
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>Data-type of the coordinate arrays passed to <cite>function</cite>.
By default, <cite>dtype</cite> is float.</p>
</dd>
<dt>like<span class="classifier">array_like</span></dt><dd><p>Reference object to allow the creation of arrays which are not
NumPy arrays. If an array-like passed in as <code class="docutils literal notranslate"><span class="pre">like</span></code> supports
the <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> protocol, the result will be defined
by it. In this case, it ensures the creation of an array object
compatible with that passed in via this argument.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.20.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>fromfunction<span class="classifier">any</span></dt><dd><p>The result of the call to <cite>function</cite> is passed back directly.
Therefore the shape of <cite>fromfunction</cite> is completely determined by
<cite>function</cite>.  If <cite>function</cite> returns a scalar value, the shape of
<cite>fromfunction</cite> would not match the <cite>shape</cite> parameter.</p>
</dd>
</dl>
<p>indices, meshgrid</p>
<p>Keywords other than <cite>dtype</cite> are passed to <cite>function</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fromfunction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([[ True, False, False],</span>
<span class="go">       [False,  True, False],</span>
<span class="go">       [False, False,  True]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fromfunction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [1, 2, 3],</span>
<span class="go">       [2, 3, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.fromiter">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">fromiter</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">like</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.fromiter" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new 1-dimensional array from an iterable object.</p>
<dl>
<dt>iter<span class="classifier">iterable object</span></dt><dd><p>An iterable object providing data for the array.</p>
</dd>
<dt>dtype<span class="classifier">data-type</span></dt><dd><p>The data-type of the returned array.</p>
</dd>
<dt>count<span class="classifier">int, optional</span></dt><dd><p>The number of items to read from <em>iterable</em>.  The default is -1,
which means all data is read.</p>
</dd>
<dt>like<span class="classifier">array_like</span></dt><dd><p>Reference object to allow the creation of arrays which are not
NumPy arrays. If an array-like passed in as <code class="docutils literal notranslate"><span class="pre">like</span></code> supports
the <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> protocol, the result will be defined
by it. In this case, it ensures the creation of an array object
compatible with that passed in via this argument.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.20.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>The output array.</p>
</dd>
</dl>
<p>Specify <cite>count</cite> to improve performance.  It allows <code class="docutils literal notranslate"><span class="pre">fromiter</span></code> to
pre-allocate the output array, instead of resizing it on demand.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">iterable</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
<span class="go">array([  0.,   1.,   4.,   9.,  16.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.frompyfunc">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">frompyfunc</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">func</span></em>, <em class="sig-param"><span class="pre">nin</span></em>, <em class="sig-param"><span class="pre">nout</span></em>, <em class="sig-param"><span class="pre">*</span></em><span class="optional">[</span>, <em class="sig-param"><span class="pre">identity</span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.frompyfunc" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes an arbitrary Python function and returns a NumPy ufunc.</p>
<p>Can be used, for example, to add broadcasting to a built-in Python
function (see Examples section).</p>
<dl class="simple">
<dt>func<span class="classifier">Python function object</span></dt><dd><p>An arbitrary Python function.</p>
</dd>
<dt>nin<span class="classifier">int</span></dt><dd><p>The number of input arguments.</p>
</dd>
<dt>nout<span class="classifier">int</span></dt><dd><p>The number of objects returned by <cite>func</cite>.</p>
</dd>
<dt>identity<span class="classifier">object, optional</span></dt><dd><p>The value to use for the <cite>~numpy.ufunc.identity</cite> attribute of the resulting
object. If specified, this is equivalent to setting the underlying
C <code class="docutils literal notranslate"><span class="pre">identity</span></code> field to <code class="docutils literal notranslate"><span class="pre">PyUFunc_IdentityValue</span></code>.
If omitted, the identity is set to <code class="docutils literal notranslate"><span class="pre">PyUFunc_None</span></code>. Note that this is
_not_ equivalent to setting the identity to <code class="docutils literal notranslate"><span class="pre">None</span></code>, which implies the
operation is reorderable.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ufunc</span></dt><dd><p>Returns a NumPy universal function (<code class="docutils literal notranslate"><span class="pre">ufunc</span></code>) object.</p>
</dd>
</dl>
<p>vectorize : Evaluates pyfunc over input arrays using broadcasting rules of numpy.</p>
<p>The returned ufunc always returns PyObject arrays.</p>
<p>Use frompyfunc to add broadcasting to the Python function <code class="docutils literal notranslate"><span class="pre">oct</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">oct_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frompyfunc</span><span class="p">(</span><span class="nb">oct</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">oct_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">100</span><span class="p">)))</span>
<span class="go">array([&#39;0o12&#39;, &#39;0o36&#39;, &#39;0o144&#39;], dtype=object)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="nb">oct</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="nb">oct</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span> <span class="nb">oct</span><span class="p">(</span><span class="mi">100</span><span class="p">)))</span> <span class="c1"># for comparison</span>
<span class="go">array([&#39;0o12&#39;, &#39;0o36&#39;, &#39;0o144&#39;], dtype=&#39;&lt;U5&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.fromregex">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">fromregex</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">regexp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.fromregex" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct an array from a text file, using regular expression parsing.</p>
<p>The returned array is always a structured array, and is constructed from
all matches of the regular expression in the file. Groups in the regular
expression are converted to fields of the structured array.</p>
<dl>
<dt>file<span class="classifier">str or file</span></dt><dd><p>Filename or file object to read.</p>
</dd>
<dt>regexp<span class="classifier">str or regexp</span></dt><dd><p>Regular expression used to parse the file.
Groups in the regular expression correspond to fields in the dtype.</p>
</dd>
<dt>dtype<span class="classifier">dtype or list of dtypes</span></dt><dd><p>Dtype for the structured array.</p>
</dd>
<dt>encoding<span class="classifier">str, optional</span></dt><dd><p>Encoding used to decode the inputfile. Does not apply to input streams.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.14.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>output<span class="classifier">ndarray</span></dt><dd><p>The output array, containing the part of the content of <cite>file</cite> that
was matched by <cite>regexp</cite>. <cite>output</cite> is always a structured array.</p>
</dd>
</dl>
<dl class="simple">
<dt>TypeError</dt><dd><p>When <cite>dtype</cite> is not a valid dtype for a structured array.</p>
</dd>
</dl>
<p>fromstring, loadtxt</p>
<p>Dtypes for structured arrays can be specified in several forms, but all
forms specify at least the data type and field name. For details see
<cite>basics.rec</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;test.dat&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;1312 foo</span><span class="se">\n</span><span class="s2">1534  bar</span><span class="se">\n</span><span class="s2">444   qux&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">regexp</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;(\d+)\s+(...)&quot;</span>  <span class="c1"># match [digits, whitespace, anything]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromregex</span><span class="p">(</span><span class="s1">&#39;test.dat&#39;</span><span class="p">,</span> <span class="n">regexp</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="p">[(</span><span class="s1">&#39;num&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;key&#39;</span><span class="p">,</span> <span class="s1">&#39;S3&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">output</span>
<span class="go">array([(1312, b&#39;foo&#39;), (1534, b&#39;bar&#39;), ( 444, b&#39;qux&#39;)],</span>
<span class="go">      dtype=[(&#39;num&#39;, &#39;&lt;i8&#39;), (&#39;key&#39;, &#39;S3&#39;)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">output</span><span class="p">[</span><span class="s1">&#39;num&#39;</span><span class="p">]</span>
<span class="go">array([1312, 1534,  444])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.fromstring">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">fromstring</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">like</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.fromstring" title="Permalink to this definition">¶</a></dt>
<dd><p>A new 1-D array initialized from text data in a string.</p>
<dl>
<dt>string<span class="classifier">str</span></dt><dd><p>A string containing the data.</p>
</dd>
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>The data type of the array; default: float.  For binary input data,
the data must be in exactly this format. Most builtin numeric types are
supported and extension types may be supported.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.18.0: </span>Complex dtypes.</p>
</div>
</dd>
<dt>count<span class="classifier">int, optional</span></dt><dd><p>Read this number of <cite>dtype</cite> elements from the data.  If this is
negative (the default), the count will be determined from the
length of the data.</p>
</dd>
<dt>sep<span class="classifier">str, optional</span></dt><dd><p>The string separating numbers in the data; extra whitespace between
elements is also ignored.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 1.14: </span>Passing <code class="docutils literal notranslate"><span class="pre">sep=''</span></code>, the default, is deprecated since it will
trigger the deprecated binary mode of this function. This mode
interprets <cite>string</cite> as binary bytes, rather than ASCII text with
decimal numbers, an operation which is better spelt
<code class="docutils literal notranslate"><span class="pre">frombuffer(string,</span> <span class="pre">dtype,</span> <span class="pre">count)</span></code>. If <cite>string</cite> contains unicode
text, the binary mode of <cite>fromstring</cite> will first encode it into
bytes using either utf-8 (python 3) or the default encoding
(python 2), neither of which produce sane results.</p>
</div>
</dd>
<dt>like<span class="classifier">array_like</span></dt><dd><p>Reference object to allow the creation of arrays which are not
NumPy arrays. If an array-like passed in as <code class="docutils literal notranslate"><span class="pre">like</span></code> supports
the <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> protocol, the result will be defined
by it. In this case, it ensures the creation of an array object
compatible with that passed in via this argument.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.20.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>arr<span class="classifier">ndarray</span></dt><dd><p>The constructed array.</p>
</dd>
</dl>
<dl class="simple">
<dt>ValueError</dt><dd><p>If the string is not the correct size to satisfy the requested
<cite>dtype</cite> and <cite>count</cite>.</p>
</dd>
</dl>
<p>frombuffer, fromfile, fromiter</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="s1">&#39;1 2&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
<span class="go">array([1, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="s1">&#39;1, 2&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
<span class="go">array([1, 2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.full">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">full</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'C'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">like</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.full" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new array of given shape and type, filled with <cite>fill_value</cite>.</p>
<dl>
<dt>shape<span class="classifier">int or sequence of ints</span></dt><dd><p>Shape of the new array, e.g., <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">3)</span></code> or <code class="docutils literal notranslate"><span class="pre">2</span></code>.</p>
</dd>
<dt>fill_value<span class="classifier">scalar or array_like</span></dt><dd><p>Fill value.</p>
</dd>
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><dl class="simple">
<dt>The desired data-type for the array  The default, None, means</dt><dd><p><code class="docutils literal notranslate"><span class="pre">np.array(fill_value).dtype</span></code>.</p>
</dd>
</dl>
</dd>
<dt>order<span class="classifier">{‘C’, ‘F’}, optional</span></dt><dd><p>Whether to store multidimensional data in C- or Fortran-contiguous
(row- or column-wise) order in memory.</p>
</dd>
<dt>like<span class="classifier">array_like</span></dt><dd><p>Reference object to allow the creation of arrays which are not
NumPy arrays. If an array-like passed in as <code class="docutils literal notranslate"><span class="pre">like</span></code> supports
the <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> protocol, the result will be defined
by it. In this case, it ensures the creation of an array object
compatible with that passed in via this argument.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.20.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>Array of <cite>fill_value</cite> with the given shape, dtype, and order.</p>
</dd>
</dl>
<p>full_like : Return a new array with shape of input filled with value.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
zeros : Return a new array setting values to zero.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="go">array([[inf, inf],</span>
<span class="go">       [inf, inf]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">10</span><span class="p">)</span>
<span class="go">array([[10, 10],</span>
<span class="go">       [10, 10]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [1, 2]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.full_like">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">full_like</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'K'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subok</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.full_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a full array with the same shape and type as a given array.</p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>The shape and data-type of <cite>a</cite> define these same attributes of
the returned array.</p>
</dd>
<dt>fill_value<span class="classifier">scalar</span></dt><dd><p>Fill value.</p>
</dd>
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>Overrides the data type of the result.</p>
</dd>
<dt>order<span class="classifier">{‘C’, ‘F’, ‘A’, or ‘K’}, optional</span></dt><dd><p>Overrides the memory layout of the result. ‘C’ means C-order,
‘F’ means F-order, ‘A’ means ‘F’ if <cite>a</cite> is Fortran contiguous,
‘C’ otherwise. ‘K’ means match the layout of <cite>a</cite> as closely
as possible.</p>
</dd>
<dt>subok<span class="classifier">bool, optional.</span></dt><dd><p>If True, then the newly created array will use the sub-class
type of <cite>a</cite>, otherwise it will be a base-class array. Defaults
to True.</p>
</dd>
<dt>shape<span class="classifier">int or sequence of ints, optional.</span></dt><dd><p>Overrides the shape of the result. If order=’K’ and the number of
dimensions is unchanged, will try to keep order, otherwise,
order=’C’ is implied.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.17.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>Array of <cite>fill_value</cite> with the same shape and type as <cite>a</cite>.</p>
</dd>
</dl>
<p>empty_like : Return an empty array with shape and type of input.
ones_like : Return an array of ones with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full : Return a new array of given shape filled with value.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">array([1, 1, 1, 1, 1, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="go">array([0, 0, 0, 0, 0, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
<span class="go">array([0.1, 0.1, 0.1, 0.1, 0.1, 0.1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
<span class="go">array([nan, nan, nan, nan, nan, nan])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="go">array([0.1, 0.1, 0.1, 0.1, 0.1, 0.1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt id="numpy.generic">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">generic</span></code><a class="headerlink" href="#numpy.generic" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for numpy scalar types.</p>
<p>Class from which most (all?) numpy scalar types are derived.  For
consistency, exposes the same API as <cite>ndarray</cite>, despite many
consequent attributes being either “get-only,” or completely irrelevant.
This is the class from which it is strongly suggested users should derive
custom scalar types.</p>
<dl class="py attribute">
<dt id="numpy.generic.T">
<code class="sig-name descname"><span class="pre">T</span></code><a class="headerlink" href="#numpy.generic.T" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar attribute identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.T</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.all">
<code class="sig-name descname"><span class="pre">all</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.all" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.all</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.any">
<code class="sig-name descname"><span class="pre">any</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.any" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.any</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.argmax">
<code class="sig-name descname"><span class="pre">argmax</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.argmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.argmax</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.argmin">
<code class="sig-name descname"><span class="pre">argmin</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.argmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.argmin</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.argsort">
<code class="sig-name descname"><span class="pre">argsort</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.argsort" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.argsort</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.astype">
<code class="sig-name descname"><span class="pre">astype</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.astype" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.astype</cite>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.generic.base">
<code class="sig-name descname"><span class="pre">base</span></code><a class="headerlink" href="#numpy.generic.base" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar attribute identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.base</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.byteswap">
<code class="sig-name descname"><span class="pre">byteswap</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.byteswap" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.byteswap</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.choose">
<code class="sig-name descname"><span class="pre">choose</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.choose" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.choose</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.clip">
<code class="sig-name descname"><span class="pre">clip</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.clip" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.clip</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.compress">
<code class="sig-name descname"><span class="pre">compress</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.compress" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.compress</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.conjugate">
<code class="sig-name descname"><span class="pre">conjugate</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.conjugate</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.copy">
<code class="sig-name descname"><span class="pre">copy</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.copy</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.cumprod">
<code class="sig-name descname"><span class="pre">cumprod</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.cumprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.cumprod</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.cumsum">
<code class="sig-name descname"><span class="pre">cumsum</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.cumsum" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.cumsum</cite>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.generic.data">
<code class="sig-name descname"><span class="pre">data</span></code><a class="headerlink" href="#numpy.generic.data" title="Permalink to this definition">¶</a></dt>
<dd><p>Pointer to start of data.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.diagonal">
<code class="sig-name descname"><span class="pre">diagonal</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.diagonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.diagonal</cite>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.generic.dtype">
<code class="sig-name descname"><span class="pre">dtype</span></code><a class="headerlink" href="#numpy.generic.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Get array data-descriptor.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.dump">
<code class="sig-name descname"><span class="pre">dump</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.dump</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.dumps">
<code class="sig-name descname"><span class="pre">dumps</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.dumps" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.dumps</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.fill">
<code class="sig-name descname"><span class="pre">fill</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.fill" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.fill</cite>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.generic.flags">
<code class="sig-name descname"><span class="pre">flags</span></code><a class="headerlink" href="#numpy.generic.flags" title="Permalink to this definition">¶</a></dt>
<dd><p>The integer value of flags.</p>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.generic.flat">
<code class="sig-name descname"><span class="pre">flat</span></code><a class="headerlink" href="#numpy.generic.flat" title="Permalink to this definition">¶</a></dt>
<dd><p>A 1-D view of the scalar.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.flatten">
<code class="sig-name descname"><span class="pre">flatten</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.flatten" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.flatten</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.getfield">
<code class="sig-name descname"><span class="pre">getfield</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.getfield" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.getfield</cite>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.generic.imag">
<code class="sig-name descname"><span class="pre">imag</span></code><a class="headerlink" href="#numpy.generic.imag" title="Permalink to this definition">¶</a></dt>
<dd><p>The imaginary part of the scalar.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.item">
<code class="sig-name descname"><span class="pre">item</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.item" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.item</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.itemset">
<code class="sig-name descname"><span class="pre">itemset</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.itemset" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.itemset</cite>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.generic.itemsize">
<code class="sig-name descname"><span class="pre">itemsize</span></code><a class="headerlink" href="#numpy.generic.itemsize" title="Permalink to this definition">¶</a></dt>
<dd><p>The length of one element in bytes.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.max">
<code class="sig-name descname"><span class="pre">max</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.max</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.mean">
<code class="sig-name descname"><span class="pre">mean</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.mean</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.min">
<code class="sig-name descname"><span class="pre">min</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.min</cite>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.generic.nbytes">
<code class="sig-name descname"><span class="pre">nbytes</span></code><a class="headerlink" href="#numpy.generic.nbytes" title="Permalink to this definition">¶</a></dt>
<dd><p>The length of the scalar in bytes.</p>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.generic.ndim">
<code class="sig-name descname"><span class="pre">ndim</span></code><a class="headerlink" href="#numpy.generic.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of array dimensions.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.newbyteorder">
<code class="sig-name descname"><span class="pre">newbyteorder</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'S'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.newbyteorder" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new <cite>dtype</cite> with a different byte order.</p>
<p>Changes are also made in all fields and sub-arrays of the data type.</p>
<p>The <cite>new_order</cite> code can be any from the following:</p>
<ul class="simple">
<li><p>‘S’ - swap dtype from current to opposite endian</p></li>
<li><p>{‘&lt;’, ‘little’} - little endian</p></li>
<li><p>{‘&gt;’, ‘big’} - big endian</p></li>
<li><p>‘=’ - native order</p></li>
<li><p>{‘|’, ‘I’} - ignore (no change to byte order)</p></li>
</ul>
<dl class="simple">
<dt>new_order<span class="classifier">str, optional</span></dt><dd><p>Byte order to force; a value from the byte order specifications
above.  The default value (‘S’) results in swapping the current
byte order.</p>
</dd>
</dl>
<dl class="simple">
<dt>new_dtype<span class="classifier">dtype</span></dt><dd><p>New <cite>dtype</cite> object with the given change to the byte order.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.nonzero">
<code class="sig-name descname"><span class="pre">nonzero</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.nonzero" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.nonzero</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.prod">
<code class="sig-name descname"><span class="pre">prod</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.prod" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.prod</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.ptp">
<code class="sig-name descname"><span class="pre">ptp</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.ptp" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.ptp</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.put">
<code class="sig-name descname"><span class="pre">put</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.put" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.put</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.ravel">
<code class="sig-name descname"><span class="pre">ravel</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.ravel" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.ravel</cite>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.generic.real">
<code class="sig-name descname"><span class="pre">real</span></code><a class="headerlink" href="#numpy.generic.real" title="Permalink to this definition">¶</a></dt>
<dd><p>The real part of the scalar.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.repeat">
<code class="sig-name descname"><span class="pre">repeat</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.repeat" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.repeat</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.reshape">
<code class="sig-name descname"><span class="pre">reshape</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.reshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.reshape</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.resize">
<code class="sig-name descname"><span class="pre">resize</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.resize" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.resize</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.round">
<code class="sig-name descname"><span class="pre">round</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.round" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.round</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.searchsorted">
<code class="sig-name descname"><span class="pre">searchsorted</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.searchsorted" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.searchsorted</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.setfield">
<code class="sig-name descname"><span class="pre">setfield</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.setfield" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.setfield</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.setflags">
<code class="sig-name descname"><span class="pre">setflags</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.setflags" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.setflags</cite>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.generic.shape">
<code class="sig-name descname"><span class="pre">shape</span></code><a class="headerlink" href="#numpy.generic.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Tuple of array dimensions.</p>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.generic.size">
<code class="sig-name descname"><span class="pre">size</span></code><a class="headerlink" href="#numpy.generic.size" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of elements in the gentype.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.sort">
<code class="sig-name descname"><span class="pre">sort</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.sort</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.squeeze">
<code class="sig-name descname"><span class="pre">squeeze</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.squeeze</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.std">
<code class="sig-name descname"><span class="pre">std</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.std" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.std</cite>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.generic.strides">
<code class="sig-name descname"><span class="pre">strides</span></code><a class="headerlink" href="#numpy.generic.strides" title="Permalink to this definition">¶</a></dt>
<dd><p>Tuple of bytes steps in each dimension.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.sum">
<code class="sig-name descname"><span class="pre">sum</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.sum</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.swapaxes">
<code class="sig-name descname"><span class="pre">swapaxes</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.swapaxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.swapaxes</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.take">
<code class="sig-name descname"><span class="pre">take</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.take" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.take</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.tofile">
<code class="sig-name descname"><span class="pre">tofile</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.tofile" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.tofile</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.tolist">
<code class="sig-name descname"><span class="pre">tolist</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.tolist" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.tolist</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.tostring">
<code class="sig-name descname"><span class="pre">tostring</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.tostring" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.tostring</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.trace">
<code class="sig-name descname"><span class="pre">trace</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.trace</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.transpose">
<code class="sig-name descname"><span class="pre">transpose</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.transpose</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.var">
<code class="sig-name descname"><span class="pre">var</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.var" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.var</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.generic.view">
<code class="sig-name descname"><span class="pre">view</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.view" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.view</cite>.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="numpy.genfromtxt">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">genfromtxt</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">fname</span></em>, <em class="sig-param"><span class="pre">dtype=&lt;class</span> <span class="pre">'float'&gt;</span></em>, <em class="sig-param"><span class="pre">comments='#'</span></em>, <em class="sig-param"><span class="pre">delimiter=None</span></em>, <em class="sig-param"><span class="pre">skip_header=0</span></em>, <em class="sig-param"><span class="pre">skip_footer=0</span></em>, <em class="sig-param"><span class="pre">converters=None</span></em>, <em class="sig-param"><span class="pre">missing_values=None</span></em>, <em class="sig-param"><span class="pre">filling_values=None</span></em>, <em class="sig-param"><span class="pre">usecols=None</span></em>, <em class="sig-param"><span class="pre">names=None</span></em>, <em class="sig-param"><span class="pre">excludelist=None</span></em>, <em class="sig-param"><span class="pre">deletechars=&quot;</span> <span class="pre">!#$%&amp;'()*+</span></em>, <em class="sig-param"><span class="pre">-./:;&lt;=&gt;?&#64;[\\]^{|}~&quot;</span></em>, <em class="sig-param"><span class="pre">replace_space='_'</span></em>, <em class="sig-param"><span class="pre">autostrip=False</span></em>, <em class="sig-param"><span class="pre">case_sensitive=True</span></em>, <em class="sig-param"><span class="pre">defaultfmt='f%i'</span></em>, <em class="sig-param"><span class="pre">unpack=None</span></em>, <em class="sig-param"><span class="pre">usemask=False</span></em>, <em class="sig-param"><span class="pre">loose=True</span></em>, <em class="sig-param"><span class="pre">invalid_raise=True</span></em>, <em class="sig-param"><span class="pre">max_rows=None</span></em>, <em class="sig-param"><span class="pre">encoding='bytes'</span></em>, <em class="sig-param"><span class="pre">*</span></em>, <em class="sig-param"><span class="pre">like=None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.genfromtxt" title="Permalink to this definition">¶</a></dt>
<dd><p>Load data from a text file, with missing values handled as specified.</p>
<p>Each line past the first <cite>skip_header</cite> lines is split at the <cite>delimiter</cite>
character, and characters following the <cite>comments</cite> character are discarded.</p>
<dl>
<dt>fname<span class="classifier">file, str, pathlib.Path, list of str, generator</span></dt><dd><p>File, filename, list, or generator to read.  If the filename
extension is <cite>.gz</cite> or <cite>.bz2</cite>, the file is first decompressed. Note
that generators must return byte strings. The strings
in a list or produced by a generator are treated as lines.</p>
</dd>
<dt>dtype<span class="classifier">dtype, optional</span></dt><dd><p>Data type of the resulting array.
If None, the dtypes will be determined by the contents of each
column, individually.</p>
</dd>
<dt>comments<span class="classifier">str, optional</span></dt><dd><p>The character used to indicate the start of a comment.
All the characters occurring on a line after a comment are discarded.</p>
</dd>
<dt>delimiter<span class="classifier">str, int, or sequence, optional</span></dt><dd><p>The string used to separate values.  By default, any consecutive
whitespaces act as delimiter.  An integer or sequence of integers
can also be provided as width(s) of each field.</p>
</dd>
<dt>skiprows<span class="classifier">int, optional</span></dt><dd><p><cite>skiprows</cite> was removed in numpy 1.10. Please use <cite>skip_header</cite> instead.</p>
</dd>
<dt>skip_header<span class="classifier">int, optional</span></dt><dd><p>The number of lines to skip at the beginning of the file.</p>
</dd>
<dt>skip_footer<span class="classifier">int, optional</span></dt><dd><p>The number of lines to skip at the end of the file.</p>
</dd>
<dt>converters<span class="classifier">variable, optional</span></dt><dd><p>The set of functions that convert the data of a column to a value.
The converters can also be used to provide a default value
for missing data: <code class="docutils literal notranslate"><span class="pre">converters</span> <span class="pre">=</span> <span class="pre">{3:</span> <span class="pre">lambda</span> <span class="pre">s:</span> <span class="pre">float(s</span> <span class="pre">or</span> <span class="pre">0)}</span></code>.</p>
</dd>
<dt>missing<span class="classifier">variable, optional</span></dt><dd><p><cite>missing</cite> was removed in numpy 1.10. Please use <cite>missing_values</cite>
instead.</p>
</dd>
<dt>missing_values<span class="classifier">variable, optional</span></dt><dd><p>The set of strings corresponding to missing data.</p>
</dd>
<dt>filling_values<span class="classifier">variable, optional</span></dt><dd><p>The set of values to be used as default when the data are missing.</p>
</dd>
<dt>usecols<span class="classifier">sequence, optional</span></dt><dd><p>Which columns to read, with 0 being the first.  For example,
<code class="docutils literal notranslate"><span class="pre">usecols</span> <span class="pre">=</span> <span class="pre">(1,</span> <span class="pre">4,</span> <span class="pre">5)</span></code> will extract the 2nd, 5th and 6th columns.</p>
</dd>
<dt>names<span class="classifier">{None, True, str, sequence}, optional</span></dt><dd><p>If <cite>names</cite> is True, the field names are read from the first line after
the first <cite>skip_header</cite> lines. This line can optionally be preceeded
by a comment delimiter. If <cite>names</cite> is a sequence or a single-string of
comma-separated names, the names will be used to define the field names
in a structured dtype. If <cite>names</cite> is None, the names of the dtype
fields will be used, if any.</p>
</dd>
<dt>excludelist<span class="classifier">sequence, optional</span></dt><dd><p>A list of names to exclude. This list is appended to the default list
[‘return’,’file’,’print’]. Excluded names are appended with an
underscore: for example, <cite>file</cite> would become <cite>file_</cite>.</p>
</dd>
<dt>deletechars<span class="classifier">str, optional</span></dt><dd><p>A string combining invalid characters that must be deleted from the
names.</p>
</dd>
<dt>defaultfmt<span class="classifier">str, optional</span></dt><dd><p>A format used to define default field names, such as “f%i” or “f_%02i”.</p>
</dd>
<dt>autostrip<span class="classifier">bool, optional</span></dt><dd><p>Whether to automatically strip white spaces from the variables.</p>
</dd>
<dt>replace_space<span class="classifier">char, optional</span></dt><dd><p>Character(s) used in replacement of white spaces in the variable
names. By default, use a ‘_’.</p>
</dd>
<dt>case_sensitive<span class="classifier">{True, False, ‘upper’, ‘lower’}, optional</span></dt><dd><p>If True, field names are case sensitive.
If False or ‘upper’, field names are converted to upper case.
If ‘lower’, field names are converted to lower case.</p>
</dd>
<dt>unpack<span class="classifier">bool, optional</span></dt><dd><p>If True, the returned array is transposed, so that arguments may be
unpacked using <code class="docutils literal notranslate"><span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">z</span> <span class="pre">=</span> <span class="pre">genfromtxt(...)</span></code>.  When used with a
structured data-type, arrays are returned for each field.
Default is False.</p>
</dd>
<dt>usemask<span class="classifier">bool, optional</span></dt><dd><p>If True, return a masked array.
If False, return a regular array.</p>
</dd>
<dt>loose<span class="classifier">bool, optional</span></dt><dd><p>If True, do not raise errors for invalid values.</p>
</dd>
<dt>invalid_raise<span class="classifier">bool, optional</span></dt><dd><p>If True, an exception is raised if an inconsistency is detected in the
number of columns.
If False, a warning is emitted and the offending lines are skipped.</p>
</dd>
<dt>max_rows<span class="classifier">int,  optional</span></dt><dd><p>The maximum number of rows to read. Must not be used with skip_footer
at the same time.  If given, the value must be at least 1. Default is
to read the entire file.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.0.</span></p>
</div>
</dd>
<dt>encoding<span class="classifier">str, optional</span></dt><dd><p>Encoding used to decode the inputfile. Does not apply when <cite>fname</cite> is
a file object.  The special value ‘bytes’ enables backward compatibility
workarounds that ensure that you receive byte arrays when possible
and passes latin1 encoded strings to converters. Override this value to
receive unicode arrays and pass strings as input to converters.  If set
to None the system default is used. The default value is ‘bytes’.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.14.0.</span></p>
</div>
</dd>
<dt>like<span class="classifier">array_like</span></dt><dd><p>Reference object to allow the creation of arrays which are not
NumPy arrays. If an array-like passed in as <code class="docutils literal notranslate"><span class="pre">like</span></code> supports
the <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> protocol, the result will be defined
by it. In this case, it ensures the creation of an array object
compatible with that passed in via this argument.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.20.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>Data read from the text file. If <cite>usemask</cite> is True, this is a
masked array.</p>
</dd>
</dl>
<p>numpy.loadtxt : equivalent function when no data is missing.</p>
<ul class="simple">
<li><p>When spaces are used as delimiters, or when no delimiter has been given
as input, there should not be any missing data between two fields.</p></li>
<li><p>When the variables are named (either by a flexible dtype or with <cite>names</cite>),
there must not be any header in the file (else a ValueError
exception is raised).</p></li>
<li><p>Individual values are not stripped of spaces by default.
When using a custom converter, make sure the function does remove spaces.</p></li>
</ul>
<dl class="footnote brackets">
<dt class="label" id="id26"><span class="brackets">1</span></dt>
<dd><p>NumPy User Guide, section <a class="reference external" href="https://docs.scipy.org/doc/numpy/user/basics.io.genfromtxt.html">I/O with NumPy</a>.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">StringIO</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
<p>Comma delimited file with mixed dtype</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">(</span><span class="sa">u</span><span class="s2">&quot;1,1.3,abcde&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;myint&#39;</span><span class="p">,</span><span class="s1">&#39;i8&#39;</span><span class="p">),(</span><span class="s1">&#39;myfloat&#39;</span><span class="p">,</span><span class="s1">&#39;f8&#39;</span><span class="p">),</span>
<span class="gp">... </span><span class="p">(</span><span class="s1">&#39;mystring&#39;</span><span class="p">,</span><span class="s1">&#39;S5&#39;</span><span class="p">)],</span> <span class="n">delimiter</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">array((1, 1.3, b&#39;abcde&#39;),</span>
<span class="go">      dtype=[(&#39;myint&#39;, &#39;&lt;i8&#39;), (&#39;myfloat&#39;, &#39;&lt;f8&#39;), (&#39;mystring&#39;, &#39;S5&#39;)])</span>
</pre></div>
</div>
<p>Using dtype = None</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># needed for StringIO example only</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="gp">... </span><span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;myint&#39;</span><span class="p">,</span><span class="s1">&#39;myfloat&#39;</span><span class="p">,</span><span class="s1">&#39;mystring&#39;</span><span class="p">],</span> <span class="n">delimiter</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">array((1, 1.3, b&#39;abcde&#39;),</span>
<span class="go">      dtype=[(&#39;myint&#39;, &#39;&lt;i8&#39;), (&#39;myfloat&#39;, &#39;&lt;f8&#39;), (&#39;mystring&#39;, &#39;S5&#39;)])</span>
</pre></div>
</div>
<p>Specifying dtype and names</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;i8,f8,S5&quot;</span><span class="p">,</span>
<span class="gp">... </span><span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;myint&#39;</span><span class="p">,</span><span class="s1">&#39;myfloat&#39;</span><span class="p">,</span><span class="s1">&#39;mystring&#39;</span><span class="p">],</span> <span class="n">delimiter</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">array((1, 1.3, b&#39;abcde&#39;),</span>
<span class="go">      dtype=[(&#39;myint&#39;, &#39;&lt;i8&#39;), (&#39;myfloat&#39;, &#39;&lt;f8&#39;), (&#39;mystring&#39;, &#39;S5&#39;)])</span>
</pre></div>
</div>
<p>An example with fixed-width columns</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">(</span><span class="sa">u</span><span class="s2">&quot;11.3abcde&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;intvar&#39;</span><span class="p">,</span><span class="s1">&#39;fltvar&#39;</span><span class="p">,</span><span class="s1">&#39;strvar&#39;</span><span class="p">],</span>
<span class="gp">... </span>    <span class="n">delimiter</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">array((1, 1.3, b&#39;abcde&#39;),</span>
<span class="go">      dtype=[(&#39;intvar&#39;, &#39;&lt;i8&#39;), (&#39;fltvar&#39;, &#39;&lt;f8&#39;), (&#39;strvar&#39;, &#39;S5&#39;)])</span>
</pre></div>
</div>
<p>An example to show comments</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="gp">... </span><span class="s1">text,# of chars</span>
<span class="gp">... </span><span class="s1">hello world,11</span>
<span class="gp">... </span><span class="s1">numpy,5&#39;&#39;&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;S12,S12&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
<span class="go">array([(b&#39;text&#39;, b&#39;&#39;), (b&#39;hello world&#39;, b&#39;11&#39;), (b&#39;numpy&#39;, b&#39;5&#39;)],</span>
<span class="go">  dtype=[(&#39;f0&#39;, &#39;S12&#39;), (&#39;f1&#39;, &#39;S12&#39;)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.geomspace">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">geomspace</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stop</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endpoint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.geomspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Return numbers spaced evenly on a log scale (a geometric progression).</p>
<p>This is similar to <cite>logspace</cite>, but with endpoints specified directly.
Each output sample is a constant multiple of the previous.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.16.0: </span>Non-scalar <cite>start</cite> and <cite>stop</cite> are now supported.</p>
</div>
<dl>
<dt>start<span class="classifier">array_like</span></dt><dd><p>The starting value of the sequence.</p>
</dd>
<dt>stop<span class="classifier">array_like</span></dt><dd><p>The final value of the sequence, unless <cite>endpoint</cite> is False.
In that case, <code class="docutils literal notranslate"><span class="pre">num</span> <span class="pre">+</span> <span class="pre">1</span></code> values are spaced over the
interval in log-space, of which all but the last (a sequence of
length <cite>num</cite>) are returned.</p>
</dd>
<dt>num<span class="classifier">integer, optional</span></dt><dd><p>Number of samples to generate.  Default is 50.</p>
</dd>
<dt>endpoint<span class="classifier">boolean, optional</span></dt><dd><p>If true, <cite>stop</cite> is the last sample. Otherwise, it is not included.
Default is True.</p>
</dd>
<dt>dtype<span class="classifier">dtype</span></dt><dd><p>The type of the output array.  If <cite>dtype</cite> is not given, the data type
is inferred from <cite>start</cite> and <cite>stop</cite>. The inferred dtype will never be
an integer; <cite>float</cite> is chosen even if the arguments would produce an
array of integers.</p>
</dd>
<dt>axis<span class="classifier">int, optional</span></dt><dd><p>The axis in the result to store the samples.  Relevant only if start
or stop are array-like.  By default (0), the samples will be along a
new axis inserted at the beginning. Use -1 to get an axis at the end.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.16.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>samples<span class="classifier">ndarray</span></dt><dd><p><cite>num</cite> samples, equally spaced on a log scale.</p>
</dd>
</dl>
<dl class="simple">
<dt>logspace<span class="classifier">Similar to geomspace, but with endpoints specified using log</span></dt><dd><p>and base.</p>
</dd>
<dt>linspace<span class="classifier">Similar to geomspace, but with arithmetic instead of geometric</span></dt><dd><p>progression.</p>
</dd>
<dt>arange<span class="classifier">Similar to linspace, with the step size specified instead of the</span></dt><dd><p>number of samples.</p>
</dd>
</dl>
<p>If the inputs or dtype are complex, the output will follow a logarithmic
spiral in the complex plane.  (There are an infinite number of spirals
passing through two points; the output will follow the shortest such path.)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">array([    1.,    10.,   100.,  1000.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">array([   1.,   10.,  100.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">array([   1.        ,    5.62341325,   31.6227766 ,  177.827941  ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>
<span class="go">array([   1.,    2.,    4.,    8.,   16.,   32.,   64.,  128.,  256.])</span>
</pre></div>
</div>
<p>Note that the above may not produce exact integers:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([  1,   2,   4,   7,  16,  32,  63, 127, 256])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">9</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([  1,   2,   4,   8,  16,  32,  64, 128, 256])</span>
</pre></div>
</div>
<p>Negative, decreasing, and complex inputs are allowed:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">array([1000.,  100.,   10.,    1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1000</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">array([-1000.,  -100.,   -10.,    -1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">1000</span><span class="n">j</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># Straight line</span>
<span class="go">array([0.   +1.j, 0.  +10.j, 0. +100.j, 0.+1000.j])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>  <span class="c1"># Circle</span>
<span class="go">array([-1.00000000e+00+1.22464680e-16j, -7.07106781e-01+7.07106781e-01j,</span>
<span class="go">        6.12323400e-17+1.00000000e+00j,  7.07106781e-01+7.07106781e-01j,</span>
<span class="go">        1.00000000e+00+0.00000000e+00j])</span>
</pre></div>
</div>
<p>Graphical illustration of <cite>endpoint</cite> parameter:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">semilogx</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">semilogx</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">[0.5, 2000, 0, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;0.7&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.get_array_wrap">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">get_array_wrap</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.get_array_wrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the wrapper for the array with the highest priority.</p>
<p>In case of ties, leftmost wins. If no wrapper is found, return None</p>
</dd></dl>

<dl class="py function">
<dt id="numpy.get_include">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">get_include</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.get_include" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the directory that contains the NumPy *.h header files.</p>
<p>Extension modules that need to compile against NumPy should use this
function to locate the appropriate include directory.</p>
<p>When using <code class="docutils literal notranslate"><span class="pre">distutils</span></code>, for example in <code class="docutils literal notranslate"><span class="pre">setup.py</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="o">...</span>
<span class="n">Extension</span><span class="p">(</span><span class="s1">&#39;extension_name&#39;</span><span class="p">,</span> <span class="o">...</span>
        <span class="n">include_dirs</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">get_include</span><span class="p">()])</span>
<span class="o">...</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.get_printoptions">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">get_printoptions</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.get_printoptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current print options.</p>
<dl>
<dt>print_opts<span class="classifier">dict</span></dt><dd><p>Dictionary of current print options with keys</p>
<blockquote>
<div><ul class="simple">
<li><p>precision : int</p></li>
<li><p>threshold : int</p></li>
<li><p>edgeitems : int</p></li>
<li><p>linewidth : int</p></li>
<li><p>suppress : bool</p></li>
<li><p>nanstr : str</p></li>
<li><p>infstr : str</p></li>
<li><p>formatter : dict of callables</p></li>
<li><p>sign : str</p></li>
</ul>
</div></blockquote>
<p>For a full description of these options, see <cite>set_printoptions</cite>.</p>
</dd>
</dl>
<p>set_printoptions, printoptions, set_string_function</p>
</dd></dl>

<dl class="py function">
<dt id="numpy.getbufsize">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">getbufsize</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.getbufsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the size of the buffer used in ufuncs.</p>
<dl class="simple">
<dt>getbufsize<span class="classifier">int</span></dt><dd><p>Size of ufunc buffer in bytes.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="numpy.geterr">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">geterr</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.geterr" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the current way of handling floating-point errors.</p>
<dl class="simple">
<dt>res<span class="classifier">dict</span></dt><dd><p>A dictionary with keys “divide”, “over”, “under”, and “invalid”,
whose values are from the strings “ignore”, “print”, “log”, “warn”,
“raise”, and “call”. The keys represent possible floating-point
exceptions, and the values define how these exceptions are handled.</p>
</dd>
</dl>
<p>geterrcall, seterr, seterrcall</p>
<p>For complete documentation of the types of floating-point exceptions and
treatment options, see <cite>seterr</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geterr</span><span class="p">()</span>
<span class="go">{&#39;divide&#39;: &#39;warn&#39;, &#39;over&#39;: &#39;warn&#39;, &#39;under&#39;: &#39;ignore&#39;, &#39;invalid&#39;: &#39;warn&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">3.</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">3.</span><span class="p">)</span>
<span class="go">array([nan,  1.,  1.])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">oldsettings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;warn&#39;</span><span class="p">,</span> <span class="n">over</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geterr</span><span class="p">()</span>
<span class="go">{&#39;divide&#39;: &#39;warn&#39;, &#39;over&#39;: &#39;raise&#39;, &#39;under&#39;: &#39;warn&#39;, &#39;invalid&#39;: &#39;warn&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">3.</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">3.</span><span class="p">)</span>
<span class="go">array([nan,  1.,  1.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.geterrcall">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">geterrcall</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.geterrcall" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current callback function used on floating-point errors.</p>
<p>When the error handling for a floating-point error (one of “divide”,
“over”, “under”, or “invalid”) is set to ‘call’ or ‘log’, the function
that is called or the log instance that is written to is returned by
<cite>geterrcall</cite>. This function or log instance has been set with
<cite>seterrcall</cite>.</p>
<dl class="simple">
<dt>errobj<span class="classifier">callable, log instance or None</span></dt><dd><p>The current error handler. If no handler was set through <cite>seterrcall</cite>,
<code class="docutils literal notranslate"><span class="pre">None</span></code> is returned.</p>
</dd>
</dl>
<p>seterrcall, seterr, geterr</p>
<p>For complete documentation of the types of floating-point exceptions and
treatment options, see <cite>seterr</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geterrcall</span><span class="p">()</span>  <span class="c1"># we did not yet set a handler, returns None</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">oldsettings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;call&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">err_handler</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">flag</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Floating point error (</span><span class="si">%s</span><span class="s2">), with flag </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">flag</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">oldhandler</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterrcall</span><span class="p">(</span><span class="n">err_handler</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="mf">0.0</span>
<span class="go">Floating point error (divide by zero), with flag 1</span>
<span class="go">array([inf, inf, inf])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cur_handler</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">geterrcall</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cur_handler</span> <span class="ow">is</span> <span class="n">err_handler</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.geterrobj">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">geterrobj</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.geterrobj" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current object that defines floating-point error handling.</p>
<p>The error object contains all information that defines the error handling
behavior in NumPy. <cite>geterrobj</cite> is used internally by the other
functions that get and set error handling behavior (<cite>geterr</cite>, <cite>seterr</cite>,
<cite>geterrcall</cite>, <cite>seterrcall</cite>).</p>
<dl>
<dt>errobj<span class="classifier">list</span></dt><dd><p>The error object, a list containing three elements:
[internal numpy buffer size, error mask, error callback function].</p>
<p>The error mask is a single integer that holds the treatment information
on all four floating point errors. The information for each error type
is contained in three bits of the integer. If we print it in base 8, we
can see what treatment is set for “invalid”, “under”, “over”, and
“divide” (in that order). The printed string can be interpreted with</p>
<ul class="simple">
<li><p>0 : ‘ignore’</p></li>
<li><p>1 : ‘warn’</p></li>
<li><p>2 : ‘raise’</p></li>
<li><p>3 : ‘call’</p></li>
<li><p>4 : ‘print’</p></li>
<li><p>5 : ‘log’</p></li>
</ul>
</dd>
</dl>
<p>seterrobj, seterr, geterr, seterrcall, geterrcall
getbufsize, setbufsize</p>
<p>For complete documentation of the types of floating-point exceptions and
treatment options, see <cite>seterr</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geterrobj</span><span class="p">()</span>  <span class="c1"># first get the defaults</span>
<span class="go">[8192, 521, None]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">err_handler</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">flag</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Floating point error (</span><span class="si">%s</span><span class="s2">), with flag </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">flag</span><span class="p">))</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">old_bufsize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setbufsize</span><span class="p">(</span><span class="mi">20000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">old_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">old_handler</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterrcall</span><span class="p">(</span><span class="n">err_handler</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geterrobj</span><span class="p">()</span>
<span class="go">[8192, 521, &lt;function err_handler at 0x91dcaac&gt;]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">old_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">base_repr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">geterrobj</span><span class="p">()[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">&#39;0&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">old_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;warn&#39;</span><span class="p">,</span> <span class="n">over</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="n">under</span><span class="o">=</span><span class="s1">&#39;call&#39;</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;print&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">base_repr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">geterrobj</span><span class="p">()[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">&#39;4351&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.gradient">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">gradient</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">varargs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the gradient of an N-dimensional array.</p>
<p>The gradient is computed using second order accurate central differences
in the interior points and either first or second order accurate one-sides
(forward or backwards) differences at the boundaries.
The returned gradient hence has the same shape as the input array.</p>
<dl>
<dt>f<span class="classifier">array_like</span></dt><dd><p>An N-dimensional array containing samples of a scalar function.</p>
</dd>
<dt>varargs<span class="classifier">list of scalar or array, optional</span></dt><dd><p>Spacing between f values. Default unitary spacing for all dimensions.
Spacing can be specified using:</p>
<ol class="arabic simple">
<li><p>single scalar to specify a sample distance for all dimensions.</p></li>
<li><p>N scalars to specify a constant sample distance for each dimension.
i.e. <cite>dx</cite>, <cite>dy</cite>, <cite>dz</cite>, …</p></li>
<li><p>N arrays to specify the coordinates of the values along each
dimension of F. The length of the array must match the size of
the corresponding dimension</p></li>
<li><p>Any combination of N scalars/arrays with the meaning of 2. and 3.</p></li>
</ol>
<p>If <cite>axis</cite> is given, the number of varargs must equal the number of axes.
Default: 1.</p>
</dd>
<dt>edge_order<span class="classifier">{1, 2}, optional</span></dt><dd><p>Gradient is calculated using N-th order accurate differences
at the boundaries. Default: 1.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.9.1.</span></p>
</div>
</dd>
<dt>axis<span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Gradient is calculated only along the given axis or axes
The default (axis = None) is to calculate the gradient for all the axes
of the input array. axis may be negative, in which case it counts from
the last to the first axis.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.11.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>gradient<span class="classifier">ndarray or list of ndarray</span></dt><dd><p>A list of ndarrays (or a single ndarray if there is only one dimension)
corresponding to the derivatives of f with respect to each dimension.
Each derivative has the same shape as f.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">16</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">array([1. , 1.5, 2.5, 3.5, 4.5, 5. ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([0.5 ,  0.75,  1.25,  1.75,  2.25,  2.5 ])</span>
</pre></div>
</div>
<p>Spacing can be also specified with an array that represents the coordinates
of the values F along the dimensions.
For instance a uniform spacing:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">array([1. ,  1.5,  2.5,  3.5,  4.5,  5. ])</span>
</pre></div>
</div>
<p>Or a non uniform one:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">,</span> <span class="mf">4.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">array([1. ,  3. ,  3.5,  6.7,  6.9,  2.5])</span>
</pre></div>
</div>
<p>For two dimensional arrays, the return will be two arrays ordered by
axis. In this example the first array stands for the gradient in
rows and the second one in columns direction:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">))</span>
<span class="go">[array([[ 2.,  2., -1.],</span>
<span class="go">       [ 2.,  2., -1.]]), array([[1. , 2.5, 4. ],</span>
<span class="go">       [1. , 1. , 1. ]])]</span>
</pre></div>
</div>
<p>In this example the spacing is also specified:
uniform for axis=0 and non uniform for axis=1</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dx</span> <span class="o">=</span> <span class="mf">2.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span> <span class="n">dx</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">[array([[ 1. ,  1. , -0.5],</span>
<span class="go">       [ 1. ,  1. , -0.5]]), array([[2. , 2. , 2. ],</span>
<span class="go">       [2. , 1.7, 0.5]])]</span>
</pre></div>
</div>
<p>It is possible to specify how boundaries are treated using <cite>edge_order</cite></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">edge_order</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([1.,  2.,  4.,  6.,  7.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">edge_order</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([0., 2., 4., 6., 8.])</span>
</pre></div>
</div>
<p>The <cite>axis</cite> keyword can be used to specify a subset of axes of which the
gradient is calculated</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[ 2.,  2., -1.],</span>
<span class="go">       [ 2.,  2., -1.]])</span>
</pre></div>
</div>
<p>Assuming that <span class="math notranslate nohighlight">\(f\in C^{3}\)</span> (i.e., <span class="math notranslate nohighlight">\(f\)</span> has at least 3 continuous
derivatives) and let <span class="math notranslate nohighlight">\(h_{*}\)</span> be a non-homogeneous stepsize, we
minimize the “consistency error” <span class="math notranslate nohighlight">\(\eta_{i}\)</span> between the true gradient
and its estimate from a linear combination of the neighboring grid-points:</p>
<div class="math notranslate nohighlight">
\[\eta_{i} = f_{i}^{\left(1\right)} -
            \left[ \alpha f\left(x_{i}\right) +
                    \beta f\left(x_{i} + h_{d}\right) +
                    \gamma f\left(x_{i}-h_{s}\right)
            \right]\]</div>
<p>By substituting <span class="math notranslate nohighlight">\(f(x_{i} + h_{d})\)</span> and <span class="math notranslate nohighlight">\(f(x_{i} - h_{s})\)</span>
with their Taylor series expansion, this translates into solving
the following the linear system:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left\{
    \begin{array}{r}
        \alpha+\beta+\gamma=0 \\
        \beta h_{d}-\gamma h_{s}=1 \\
        \beta h_{d}^{2}+\gamma h_{s}^{2}=0
    \end{array}
\right.\end{split}\]</div>
<p>The resulting approximation of <span class="math notranslate nohighlight">\(f_{i}^{(1)}\)</span> is the following:</p>
<div class="math notranslate nohighlight">
\[\hat f_{i}^{(1)} =
    \frac{
        h_{s}^{2}f\left(x_{i} + h_{d}\right)
        + \left(h_{d}^{2} - h_{s}^{2}\right)f\left(x_{i}\right)
        - h_{d}^{2}f\left(x_{i}-h_{s}\right)}
        { h_{s}h_{d}\left(h_{d} + h_{s}\right)}
    + \mathcal{O}\left(\frac{h_{d}h_{s}^{2}
                        + h_{s}h_{d}^{2}}{h_{d}
                        + h_{s}}\right)\]</div>
<p>It is worth noting that if <span class="math notranslate nohighlight">\(h_{s}=h_{d}\)</span>
(i.e., data are evenly spaced)
we find the standard second order approximation:</p>
<div class="math notranslate nohighlight">
\[\hat f_{i}^{(1)}=
    \frac{f\left(x_{i+1}\right) - f\left(x_{i-1}\right)}{2h}
    + \mathcal{O}\left(h^{2}\right)\]</div>
<p>With a similar procedure the forward/backward approximations used for
boundaries can be derived.</p>
<dl class="footnote brackets">
<dt class="label" id="id27"><span class="brackets">1</span></dt>
<dd><p>Quarteroni A., Sacco R., Saleri F. (2007) Numerical Mathematics
(Texts in Applied Mathematics). New York: Springer.</p>
</dd>
<dt class="label" id="id28"><span class="brackets">2</span></dt>
<dd><p>Durran D. R. (1999) Numerical Methods for Wave Equations
in Geophysical Fluid Dynamics. New York: Springer.</p>
</dd>
<dt class="label" id="id29"><span class="brackets">3</span></dt>
<dd><p>Fornberg B. (1988) Generation of Finite Difference Formulas on
Arbitrarily Spaced Grids,
Mathematics of Computation 51, no. 184 : 699-706.
<a class="reference external" href="http://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf">PDF</a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.half">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">half</span></code><a class="headerlink" href="#numpy.half" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.float16" title="numpy.float16"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.float16</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="numpy.hamming">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">hamming</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.hamming" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Hamming window.</p>
<p>The Hamming window is a taper formed by using a weighted cosine.</p>
<dl class="simple">
<dt>M<span class="classifier">int</span></dt><dd><p>Number of points in the output window. If zero or less, an
empty array is returned.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>The window, with the maximum value normalized to one (the value
one appears only if the number of samples is odd).</p>
</dd>
</dl>
<p>bartlett, blackman, hanning, kaiser</p>
<p>The Hamming window is defined as</p>
<div class="math notranslate nohighlight">
\[w(n) = 0.54 - 0.46cos\left(\frac{2\pi{n}}{M-1}\right)
\qquad 0 \leq n \leq M-1\]</div>
<p>The Hamming was named for R. W. Hamming, an associate of J. W. Tukey
and is described in Blackman and Tukey. It was recommended for
smoothing the truncated autocovariance function in the time domain.
Most references to the Hamming window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
“removing the foot”, i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function.</p>
<dl class="footnote brackets">
<dt class="label" id="id30"><span class="brackets">1</span></dt>
<dd><p>Blackman, R.B. and Tukey, J.W., (1958) The measurement of power
spectra, Dover Publications, New York.</p>
</dd>
<dt class="label" id="id31"><span class="brackets">2</span></dt>
<dd><p>E.R. Kanasewich, “Time Sequence Analysis in Geophysics”, The
University of Alberta Press, 1975, pp. 109-110.</p>
</dd>
<dt class="label" id="id32"><span class="brackets">3</span></dt>
<dd><p>Wikipedia, “Window function”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Window_function">https://en.wikipedia.org/wiki/Window_function</a></p>
</dd>
<dt class="label" id="id33"><span class="brackets">4</span></dt>
<dd><p>W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
“Numerical Recipes”, Cambridge University Press, 1986, page 425.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">hamming</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="go">array([ 0.08      ,  0.15302337,  0.34890909,  0.60546483,  0.84123594, # may vary</span>
<span class="go">        0.98136677,  0.98136677,  0.84123594,  0.60546483,  0.34890909,</span>
<span class="go">        0.15302337,  0.08      ])</span>
</pre></div>
</div>
<p>Plot the window and the frequency response:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy.fft</span> <span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">fftshift</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hamming</span><span class="p">(</span><span class="mi">51</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Hamming window&quot;</span><span class="p">)</span>
<span class="go">Text(0.5, 1.0, &#39;Hamming window&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Amplitude&quot;</span><span class="p">)</span>
<span class="go">Text(0, 0.5, &#39;Amplitude&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Sample&quot;</span><span class="p">)</span>
<span class="go">Text(0.5, 0, &#39;Sample&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="go">&lt;Figure size 640x480 with 0 Axes&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span> <span class="o">/</span> <span class="mf">25.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fftshift</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">mag</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">response</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Frequency response of Hamming window&quot;</span><span class="p">)</span>
<span class="go">Text(0.5, 1.0, &#39;Frequency response of Hamming window&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Magnitude [dB]&quot;</span><span class="p">)</span>
<span class="go">Text(0, 0.5, &#39;Magnitude [dB]&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Normalized frequency [cycles per sample]&quot;</span><span class="p">)</span>
<span class="go">Text(0.5, 0, &#39;Normalized frequency [cycles per sample]&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.hanning">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">hanning</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.hanning" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Hanning window.</p>
<p>The Hanning window is a taper formed by using a weighted cosine.</p>
<dl class="simple">
<dt>M<span class="classifier">int</span></dt><dd><p>Number of points in the output window. If zero or less, an
empty array is returned.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray, shape(M,)</span></dt><dd><p>The window, with the maximum value normalized to one (the value
one appears only if <cite>M</cite> is odd).</p>
</dd>
</dl>
<p>bartlett, blackman, hamming, kaiser</p>
<p>The Hanning window is defined as</p>
<div class="math notranslate nohighlight">
\[w(n) = 0.5 - 0.5cos\left(\frac{2\pi{n}}{M-1}\right)
\qquad 0 \leq n \leq M-1\]</div>
<p>The Hanning was named for Julius von Hann, an Austrian meteorologist.
It is also known as the Cosine Bell. Some authors prefer that it be
called a Hann window, to help avoid confusion with the very similar
Hamming window.</p>
<p>Most references to the Hanning window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
“removing the foot”, i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function.</p>
<dl class="footnote brackets">
<dt class="label" id="id34"><span class="brackets">1</span></dt>
<dd><p>Blackman, R.B. and Tukey, J.W., (1958) The measurement of power
spectra, Dover Publications, New York.</p>
</dd>
<dt class="label" id="id35"><span class="brackets">2</span></dt>
<dd><p>E.R. Kanasewich, “Time Sequence Analysis in Geophysics”,
The University of Alberta Press, 1975, pp. 106-108.</p>
</dd>
<dt class="label" id="id36"><span class="brackets">3</span></dt>
<dd><p>Wikipedia, “Window function”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Window_function">https://en.wikipedia.org/wiki/Window_function</a></p>
</dd>
<dt class="label" id="id37"><span class="brackets">4</span></dt>
<dd><p>W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
“Numerical Recipes”, Cambridge University Press, 1986, page 425.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="go">array([0.        , 0.07937323, 0.29229249, 0.57115742, 0.82743037,</span>
<span class="go">       0.97974649, 0.97974649, 0.82743037, 0.57115742, 0.29229249,</span>
<span class="go">       0.07937323, 0.        ])</span>
</pre></div>
</div>
<p>Plot the window and its frequency response:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy.fft</span> <span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">fftshift</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="mi">51</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Hann window&quot;</span><span class="p">)</span>
<span class="go">Text(0.5, 1.0, &#39;Hann window&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Amplitude&quot;</span><span class="p">)</span>
<span class="go">Text(0, 0.5, &#39;Amplitude&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Sample&quot;</span><span class="p">)</span>
<span class="go">Text(0.5, 0, &#39;Sample&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="go">&lt;Figure size 640x480 with 0 Axes&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span> <span class="o">/</span> <span class="mf">25.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fftshift</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">response</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">mag</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">response</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Frequency response of the Hann window&quot;</span><span class="p">)</span>
<span class="go">Text(0.5, 1.0, &#39;Frequency response of the Hann window&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Magnitude [dB]&quot;</span><span class="p">)</span>
<span class="go">Text(0, 0.5, &#39;Magnitude [dB]&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Normalized frequency [cycles per sample]&quot;</span><span class="p">)</span>
<span class="go">Text(0.5, 0, &#39;Normalized frequency [cycles per sample]&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.histogram">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">histogram</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">density</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the histogram of a dataset.</p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input data. The histogram is computed over the flattened array.</p>
</dd>
<dt>bins<span class="classifier">int or sequence of scalars or str, optional</span></dt><dd><p>If <cite>bins</cite> is an int, it defines the number of equal-width
bins in the given range (10, by default). If <cite>bins</cite> is a
sequence, it defines a monotonically increasing array of bin edges,
including the rightmost edge, allowing for non-uniform bin widths.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.11.0.</span></p>
</div>
<p>If <cite>bins</cite> is a string, it defines the method used to calculate the
optimal bin width, as defined by <cite>histogram_bin_edges</cite>.</p>
</dd>
<dt>range<span class="classifier">(float, float), optional</span></dt><dd><p>The lower and upper range of the bins.  If not provided, range
is simply <code class="docutils literal notranslate"><span class="pre">(a.min(),</span> <span class="pre">a.max())</span></code>.  Values outside the range are
ignored. The first element of the range must be less than or
equal to the second. <cite>range</cite> affects the automatic bin
computation as well. While bin width is computed to be optimal
based on the actual data within <cite>range</cite>, the bin count will fill
the entire range including portions containing no data.</p>
</dd>
</dl>
<p>normed : bool, optional</p>
<blockquote>
<div><div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 1.6.0.</span></p>
</div>
<p>This is equivalent to the <cite>density</cite> argument, but produces incorrect
results for unequal bin widths. It should not be used.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.15.0: </span>DeprecationWarnings are actually emitted.</p>
</div>
</div></blockquote>
<dl>
<dt>weights<span class="classifier">array_like, optional</span></dt><dd><p>An array of weights, of the same shape as <cite>a</cite>.  Each value in
<cite>a</cite> only contributes its associated weight towards the bin count
(instead of 1). If <cite>density</cite> is True, the weights are
normalized, so that the integral of the density over the range
remains 1.</p>
</dd>
<dt>density<span class="classifier">bool, optional</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">False</span></code>, the result will contain the number of samples in
each bin. If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the result is the value of the
probability <em>density</em> function at the bin, normalized such that
the <em>integral</em> over the range is 1. Note that the sum of the
histogram values will not be equal to 1 unless bins of unity
width are chosen; it is not a probability <em>mass</em> function.</p>
<p>Overrides the <code class="docutils literal notranslate"><span class="pre">normed</span></code> keyword if given.</p>
</dd>
</dl>
<dl class="simple">
<dt>hist<span class="classifier">array</span></dt><dd><p>The values of the histogram. See <cite>density</cite> and <cite>weights</cite> for a
description of the possible semantics.</p>
</dd>
<dt>bin_edges<span class="classifier">array of dtype float</span></dt><dd><p>Return the bin edges <code class="docutils literal notranslate"><span class="pre">(length(hist)+1)</span></code>.</p>
</dd>
</dl>
<p>histogramdd, bincount, searchsorted, digitize, histogram_bin_edges</p>
<p>All but the last (righthand-most) bin is half-open.  In other words,
if <cite>bins</cite> is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
</pre></div>
</div>
<p>then the first bin is <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2)</span></code> (including 1, but excluding 2) and
the second <code class="docutils literal notranslate"><span class="pre">[2,</span> <span class="pre">3)</span></code>.  The last bin, however, is <code class="docutils literal notranslate"><span class="pre">[3,</span> <span class="pre">4]</span></code>, which
<em>includes</em> 4.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">(array([0, 2, 1]), array([0, 1, 2, 3]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">bins</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(array([0.25, 0.25, 0.25, 0.25]), array([0, 1, 2, 3, 4]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">bins</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">(array([1, 4, 1]), array([0, 1, 2, 3]))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hist</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hist</span>
<span class="go">array([0.5, 0. , 0.5, 0. , 0. , 0.5, 0. , 0.5, 0. , 0.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hist</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="go">2.4999999999999996</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">hist</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">))</span>
<span class="go">1.0</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.11.0.</span></p>
</div>
<p>Automated Bin Selection Methods example, using 2 peak random data
with 2000 points:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  <span class="c1"># deterministic random data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">rng</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">1000</span><span class="p">),</span>
<span class="gp">... </span>               <span class="n">rng</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1000</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>  <span class="c1"># arguments are passed to np.histogram</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Histogram with &#39;auto&#39; bins&quot;</span><span class="p">)</span>
<span class="go">Text(0.5, 1.0, &quot;Histogram with &#39;auto&#39; bins&quot;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.histogram2d">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">histogram2d</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">density</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.histogram2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the bi-dimensional histogram of two data samples.</p>
<dl>
<dt>x<span class="classifier">array_like, shape (N,)</span></dt><dd><p>An array containing the x coordinates of the points to be
histogrammed.</p>
</dd>
<dt>y<span class="classifier">array_like, shape (N,)</span></dt><dd><p>An array containing the y coordinates of the points to be
histogrammed.</p>
</dd>
<dt>bins<span class="classifier">int or array_like or [int, int] or [array, array], optional</span></dt><dd><p>The bin specification:</p>
<blockquote>
<div><ul class="simple">
<li><p>If int, the number of bins for the two dimensions (nx=ny=bins).</p></li>
<li><p>If array_like, the bin edges for the two dimensions
(x_edges=y_edges=bins).</p></li>
<li><p>If [int, int], the number of bins in each dimension
(nx, ny = bins).</p></li>
<li><p>If [array, array], the bin edges in each dimension
(x_edges, y_edges = bins).</p></li>
<li><p>A combination [int, array] or [array, int], where int
is the number of bins and array is the bin edges.</p></li>
</ul>
</div></blockquote>
</dd>
<dt>range<span class="classifier">array_like, shape(2,2), optional</span></dt><dd><p>The leftmost and rightmost edges of the bins along each dimension
(if not specified explicitly in the <cite>bins</cite> parameters):
<code class="docutils literal notranslate"><span class="pre">[[xmin,</span> <span class="pre">xmax],</span> <span class="pre">[ymin,</span> <span class="pre">ymax]]</span></code>. All values outside of this range
will be considered outliers and not tallied in the histogram.</p>
</dd>
<dt>density<span class="classifier">bool, optional</span></dt><dd><p>If False, the default, returns the number of samples in each bin.
If True, returns the probability <em>density</em> function at the bin,
<code class="docutils literal notranslate"><span class="pre">bin_count</span> <span class="pre">/</span> <span class="pre">sample_count</span> <span class="pre">/</span> <span class="pre">bin_area</span></code>.</p>
</dd>
<dt>normed<span class="classifier">bool, optional</span></dt><dd><p>An alias for the density argument that behaves identically. To avoid
confusion with the broken normed argument to <cite>histogram</cite>, <cite>density</cite>
should be preferred.</p>
</dd>
<dt>weights<span class="classifier">array_like, shape(N,), optional</span></dt><dd><p>An array of values <code class="docutils literal notranslate"><span class="pre">w_i</span></code> weighing each sample <code class="docutils literal notranslate"><span class="pre">(x_i,</span> <span class="pre">y_i)</span></code>.
Weights are normalized to 1 if <cite>normed</cite> is True. If <cite>normed</cite> is
False, the values of the returned histogram are equal to the sum of
the weights belonging to the samples falling into each bin.</p>
</dd>
</dl>
<dl class="simple">
<dt>H<span class="classifier">ndarray, shape(nx, ny)</span></dt><dd><p>The bi-dimensional histogram of samples <cite>x</cite> and <cite>y</cite>. Values in <cite>x</cite>
are histogrammed along the first dimension and values in <cite>y</cite> are
histogrammed along the second dimension.</p>
</dd>
<dt>xedges<span class="classifier">ndarray, shape(nx+1,)</span></dt><dd><p>The bin edges along the first dimension.</p>
</dd>
<dt>yedges<span class="classifier">ndarray, shape(ny+1,)</span></dt><dd><p>The bin edges along the second dimension.</p>
</dd>
</dl>
<p>histogram : 1D histogram
histogramdd : Multidimensional histogram</p>
<p>When <cite>normed</cite> is True, then the returned histogram is the sample
density, defined such that the sum over bins of the product
<code class="docutils literal notranslate"><span class="pre">bin_value</span> <span class="pre">*</span> <span class="pre">bin_area</span></code> is 1.</p>
<p>Please note that the histogram does not follow the Cartesian convention
where <cite>x</cite> values are on the abscissa and <cite>y</cite> values on the ordinate
axis.  Rather, <cite>x</cite> is histogrammed along the first dimension of the
array (vertical), and <cite>y</cite> along the second dimension of the array
(horizontal).  This ensures compatibility with <cite>histogramdd</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">matplotlib.image</span> <span class="kn">import</span> <span class="n">NonUniformImage</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
<p>Construct a 2-D histogram with variable bin width. First define the bin
edges:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xedges</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yedges</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
</pre></div>
</div>
<p>Next we create a histogram H with random bin content:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span><span class="p">,</span> <span class="n">xedges</span><span class="p">,</span> <span class="n">yedges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram2d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="p">(</span><span class="n">xedges</span><span class="p">,</span> <span class="n">yedges</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Histogram does not follow Cartesian convention (see Notes),</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># therefore transpose H for visualization purposes.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">T</span>
</pre></div>
</div>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">imshow</span></code> can only display square bins:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">131</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;imshow: square bins&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span>
<span class="gp">... </span>        <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="n">xedges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xedges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">yedges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">yedges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
<span class="go">&lt;matplotlib.image.AxesImage object at 0x...&gt;</span>
</pre></div>
</div>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">pcolormesh</span></code> can display actual edges:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">132</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;pcolormesh: actual edges&#39;</span><span class="p">,</span>
<span class="gp">... </span>        <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xedges</span><span class="p">,</span> <span class="n">yedges</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span>
<span class="go">&lt;matplotlib.collections.QuadMesh object at 0x...&gt;</span>
</pre></div>
</div>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">NonUniformImage</span></code> can be used to
display actual bin edges with interpolation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">133</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;NonUniformImage: interpolated&#39;</span><span class="p">,</span>
<span class="gp">... </span>        <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;equal&#39;</span><span class="p">,</span> <span class="n">xlim</span><span class="o">=</span><span class="n">xedges</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">ylim</span><span class="o">=</span><span class="n">yedges</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span> <span class="o">=</span> <span class="n">NonUniformImage</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;bilinear&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xcenters</span> <span class="o">=</span> <span class="p">(</span><span class="n">xedges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">xedges</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">/</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ycenters</span> <span class="o">=</span> <span class="p">(</span><span class="n">yedges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">yedges</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">/</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">xcenters</span><span class="p">,</span> <span class="n">ycenters</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span><span class="o">.</span><span class="n">images</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.histogram_bin_edges">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">histogram_bin_edges</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.histogram_bin_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to calculate only the edges of the bins used by the <cite>histogram</cite>
function.</p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input data. The histogram is computed over the flattened array.</p>
</dd>
<dt>bins<span class="classifier">int or sequence of scalars or str, optional</span></dt><dd><p>If <cite>bins</cite> is an int, it defines the number of equal-width
bins in the given range (10, by default). If <cite>bins</cite> is a
sequence, it defines the bin edges, including the rightmost
edge, allowing for non-uniform bin widths.</p>
<p>If <cite>bins</cite> is a string from the list below, <cite>histogram_bin_edges</cite> will use
the method chosen to calculate the optimal bin width and
consequently the number of bins (see <cite>Notes</cite> for more detail on
the estimators) from the data that falls within the requested
range. While the bin width will be optimal for the actual data
in the range, the number of bins will be computed to fill the
entire range, including the empty portions. For visualisation,
using the ‘auto’ option is suggested. Weighted data is not
supported for automated bin size selection.</p>
<dl class="simple">
<dt>‘auto’</dt><dd><p>Maximum of the ‘sturges’ and ‘fd’ estimators. Provides good
all around performance.</p>
</dd>
<dt>‘fd’ (Freedman Diaconis Estimator)</dt><dd><p>Robust (resilient to outliers) estimator that takes into
account data variability and data size.</p>
</dd>
<dt>‘doane’</dt><dd><p>An improved version of Sturges’ estimator that works better
with non-normal datasets.</p>
</dd>
<dt>‘scott’</dt><dd><p>Less robust estimator that that takes into account data
variability and data size.</p>
</dd>
<dt>‘stone’</dt><dd><p>Estimator based on leave-one-out cross-validation estimate of
the integrated squared error. Can be regarded as a generalization
of Scott’s rule.</p>
</dd>
<dt>‘rice’</dt><dd><p>Estimator does not take variability into account, only data
size. Commonly overestimates number of bins required.</p>
</dd>
<dt>‘sturges’</dt><dd><p>R’s default method, only accounts for data size. Only
optimal for gaussian data and underestimates number of bins
for large non-gaussian datasets.</p>
</dd>
<dt>‘sqrt’</dt><dd><p>Square root (of data size) estimator, used by Excel and
other programs for its speed and simplicity.</p>
</dd>
</dl>
</dd>
<dt>range<span class="classifier">(float, float), optional</span></dt><dd><p>The lower and upper range of the bins.  If not provided, range
is simply <code class="docutils literal notranslate"><span class="pre">(a.min(),</span> <span class="pre">a.max())</span></code>.  Values outside the range are
ignored. The first element of the range must be less than or
equal to the second. <cite>range</cite> affects the automatic bin
computation as well. While bin width is computed to be optimal
based on the actual data within <cite>range</cite>, the bin count will fill
the entire range including portions containing no data.</p>
</dd>
<dt>weights<span class="classifier">array_like, optional</span></dt><dd><p>An array of weights, of the same shape as <cite>a</cite>.  Each value in
<cite>a</cite> only contributes its associated weight towards the bin count
(instead of 1). This is currently not used by any of the bin estimators,
but may be in the future.</p>
</dd>
</dl>
<dl class="simple">
<dt>bin_edges<span class="classifier">array of dtype float</span></dt><dd><p>The edges to pass into <cite>histogram</cite></p>
</dd>
</dl>
<p>histogram</p>
<p>The methods to estimate the optimal number of bins are well founded
in literature, and are inspired by the choices R provides for
histogram visualisation. Note that having the number of bins
proportional to <span class="math notranslate nohighlight">\(n^{1/3}\)</span> is asymptotically optimal, which is
why it appears in most estimators. These are simply plug-in methods
that give good starting points for number of bins. In the equations
below, <span class="math notranslate nohighlight">\(h\)</span> is the binwidth and <span class="math notranslate nohighlight">\(n_h\)</span> is the number of
bins. All estimators that compute bin counts are recast to bin width
using the <cite>ptp</cite> of the data. The final bin count is obtained from
<code class="docutils literal notranslate"><span class="pre">np.round(np.ceil(range</span> <span class="pre">/</span> <span class="pre">h))</span></code>. The final bin width is often less 
than what is returned by the estimators below.</p>
<dl>
<dt>‘auto’ (maximum of the ‘sturges’ and ‘fd’ estimators)</dt><dd><p>A compromise to get a good value. For small datasets the Sturges
value will usually be chosen, while larger datasets will usually
default to FD.  Avoids the overly conservative behaviour of FD
and Sturges for small and large datasets respectively.
Switchover point is usually <span class="math notranslate nohighlight">\(a.size \approx 1000\)</span>.</p>
</dd>
<dt>‘fd’ (Freedman Diaconis Estimator)</dt><dd><div class="math notranslate nohighlight">
\[h = 2 \frac{IQR}{n^{1/3}}\]</div>
<p>The binwidth is proportional to the interquartile range (IQR)
and inversely proportional to cube root of a.size. Can be too
conservative for small datasets, but is quite good for large
datasets. The IQR is very robust to outliers.</p>
</dd>
<dt>‘scott’</dt><dd><div class="math notranslate nohighlight">
\[h = \sigma \sqrt[3]{\frac{24 * \sqrt{\pi}}{n}}\]</div>
<p>The binwidth is proportional to the standard deviation of the
data and inversely proportional to cube root of <code class="docutils literal notranslate"><span class="pre">x.size</span></code>. Can
be too conservative for small datasets, but is quite good for
large datasets. The standard deviation is not very robust to
outliers. Values are very similar to the Freedman-Diaconis
estimator in the absence of outliers.</p>
</dd>
<dt>‘rice’</dt><dd><div class="math notranslate nohighlight">
\[n_h = 2n^{1/3}\]</div>
<p>The number of bins is only proportional to cube root of
<code class="docutils literal notranslate"><span class="pre">a.size</span></code>. It tends to overestimate the number of bins and it
does not take into account data variability.</p>
</dd>
<dt>‘sturges’</dt><dd><div class="math notranslate nohighlight">
\[n_h = \log _{2}n+1\]</div>
<p>The number of bins is the base 2 log of <code class="docutils literal notranslate"><span class="pre">a.size</span></code>.  This
estimator assumes normality of data and is too conservative for
larger, non-normal datasets. This is the default method in R’s
<code class="docutils literal notranslate"><span class="pre">hist</span></code> method.</p>
</dd>
<dt>‘doane’</dt><dd><div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}n_h = 1 + \log_{2}(n) +
            \log_{2}(1 + \frac{|g_1|}{\sigma_{g_1}})\\g_1 = mean[(\frac{x - \mu}{\sigma})^3]\\\sigma_{g_1} = \sqrt{\frac{6(n - 2)}{(n + 1)(n + 3)}}\end{aligned}\end{align} \]</div>
<p>An improved version of Sturges’ formula that produces better
estimates for non-normal datasets. This estimator attempts to
account for the skew of the data.</p>
</dd>
<dt>‘sqrt’</dt><dd><div class="math notranslate nohighlight">
\[n_h = \sqrt n\]</div>
<p>The simplest and fastest estimator. Only takes into account the
data size.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">histogram_bin_edges</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">array([0.  , 0.25, 0.5 , 0.75, 1.  ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">histogram_bin_edges</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([0. , 2.5, 5. ])</span>
</pre></div>
</div>
<p>For consistency with histogram, an array of pre-computed bins is
passed through unmodified:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">histogram_bin_edges</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">array([1, 2])</span>
</pre></div>
</div>
<p>This function allows one set of bins to be computed, and reused across
multiple histograms:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">shared_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram_bin_edges</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shared_bins</span>
<span class="go">array([0., 1., 2., 3., 4., 5.])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">group_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hist_0</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">group_id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="n">shared_bins</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hist_1</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">group_id</span> <span class="o">==</span> <span class="mi">1</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="n">shared_bins</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hist_0</span><span class="p">;</span> <span class="n">hist_1</span>
<span class="go">array([1, 1, 0, 1, 0])</span>
<span class="go">array([2, 0, 1, 1, 2])</span>
</pre></div>
</div>
<p>Which gives more easily comparable results than using separate bins for
each histogram:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hist_0</span><span class="p">,</span> <span class="n">bins_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">group_id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hist_1</span><span class="p">,</span> <span class="n">bins_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">group_id</span> <span class="o">==</span> <span class="mi">1</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hist_0</span><span class="p">;</span> <span class="n">hist_1</span>
<span class="go">array([1, 1, 1])</span>
<span class="go">array([2, 1, 1, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bins_0</span><span class="p">;</span> <span class="n">bins_1</span>
<span class="go">array([0., 1., 2., 3.])</span>
<span class="go">array([0.  , 1.25, 2.5 , 3.75, 5.  ])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.histogramdd">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">histogramdd</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">density</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.histogramdd" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the multidimensional histogram of some data.</p>
<dl>
<dt>sample<span class="classifier">(N, D) array, or (D, N) array_like</span></dt><dd><p>The data to be histogrammed.</p>
<p>Note the unusual interpretation of sample when an array_like:</p>
<ul class="simple">
<li><p>When an array, each row is a coordinate in a D-dimensional space -
such as <code class="docutils literal notranslate"><span class="pre">histogramdd(np.array([p1,</span> <span class="pre">p2,</span> <span class="pre">p3]))</span></code>.</p></li>
<li><p>When an array_like, each element is the list of values for single
coordinate - such as <code class="docutils literal notranslate"><span class="pre">histogramdd((X,</span> <span class="pre">Y,</span> <span class="pre">Z))</span></code>.</p></li>
</ul>
<p>The first form should be preferred.</p>
</dd>
<dt>bins<span class="classifier">sequence or int, optional</span></dt><dd><p>The bin specification:</p>
<ul class="simple">
<li><p>A sequence of arrays describing the monotonically increasing bin
edges along each dimension.</p></li>
<li><p>The number of bins for each dimension (nx, ny, … =bins)</p></li>
<li><p>The number of bins for all dimensions (nx=ny=…=bins).</p></li>
</ul>
</dd>
<dt>range<span class="classifier">sequence, optional</span></dt><dd><p>A sequence of length D, each an optional (lower, upper) tuple giving
the outer bin edges to be used if the edges are not given explicitly in
<cite>bins</cite>.
An entry of None in the sequence results in the minimum and maximum
values being used for the corresponding dimension.
The default, None, is equivalent to passing a tuple of D None values.</p>
</dd>
<dt>density<span class="classifier">bool, optional</span></dt><dd><p>If False, the default, returns the number of samples in each bin.
If True, returns the probability <em>density</em> function at the bin,
<code class="docutils literal notranslate"><span class="pre">bin_count</span> <span class="pre">/</span> <span class="pre">sample_count</span> <span class="pre">/</span> <span class="pre">bin_volume</span></code>.</p>
</dd>
<dt>normed<span class="classifier">bool, optional</span></dt><dd><p>An alias for the density argument that behaves identically. To avoid
confusion with the broken normed argument to <cite>histogram</cite>, <cite>density</cite>
should be preferred.</p>
</dd>
<dt>weights<span class="classifier">(N,) array_like, optional</span></dt><dd><p>An array of values <cite>w_i</cite> weighing each sample <cite>(x_i, y_i, z_i, …)</cite>.
Weights are normalized to 1 if normed is True. If normed is False,
the values of the returned histogram are equal to the sum of the
weights belonging to the samples falling into each bin.</p>
</dd>
</dl>
<dl class="simple">
<dt>H<span class="classifier">ndarray</span></dt><dd><p>The multidimensional histogram of sample x. See normed and weights
for the different possible semantics.</p>
</dd>
<dt>edges<span class="classifier">list</span></dt><dd><p>A list of D arrays describing the bin edges for each dimension.</p>
</dd>
</dl>
<p>histogram: 1-D histogram
histogram2d: 2-D histogram</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogramdd</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">edges</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
<span class="go">((5, 8, 4), 6, 9, 5)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.hsplit">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">hsplit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ary</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices_or_sections</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.hsplit" title="Permalink to this definition">¶</a></dt>
<dd><p>Split an array into multiple sub-arrays horizontally (column-wise).</p>
<p>Please refer to the <cite>split</cite> documentation.  <cite>hsplit</cite> is equivalent
to <cite>split</cite> with <code class="docutils literal notranslate"><span class="pre">axis=1</span></code>, the array is always split along the second
axis regardless of the array dimension.</p>
<p>split : Split an array into multiple sub-arrays of equal size.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">16.0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[ 0.,   1.,   2.,   3.],</span>
<span class="go">       [ 4.,   5.,   6.,   7.],</span>
<span class="go">       [ 8.,   9.,  10.,  11.],</span>
<span class="go">       [12.,  13.,  14.,  15.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">hsplit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">[array([[  0.,   1.],</span>
<span class="go">       [  4.,   5.],</span>
<span class="go">       [  8.,   9.],</span>
<span class="go">       [12.,  13.]]),</span>
<span class="go"> array([[  2.,   3.],</span>
<span class="go">       [  6.,   7.],</span>
<span class="go">       [10.,  11.],</span>
<span class="go">       [14.,  15.]])]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">hsplit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">]))</span>
<span class="go">[array([[ 0.,   1.,   2.],</span>
<span class="go">       [ 4.,   5.,   6.],</span>
<span class="go">       [ 8.,   9.,  10.],</span>
<span class="go">       [12.,  13.,  14.]]),</span>
<span class="go"> array([[ 3.],</span>
<span class="go">       [ 7.],</span>
<span class="go">       [11.],</span>
<span class="go">       [15.]]),</span>
<span class="go"> array([], shape=(4, 0), dtype=float64)]</span>
</pre></div>
</div>
<p>With a higher dimensional array the split is still along the second axis.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">8.0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[[0.,  1.],</span>
<span class="go">        [2.,  3.]],</span>
<span class="go">       [[4.,  5.],</span>
<span class="go">        [6.,  7.]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">hsplit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">[array([[[0.,  1.]],</span>
<span class="go">       [[4.,  5.]]]),</span>
<span class="go"> array([[[2.,  3.]],</span>
<span class="go">       [[6.,  7.]]])]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.hstack">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">hstack</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tup</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.hstack" title="Permalink to this definition">¶</a></dt>
<dd><p>Stack arrays in sequence horizontally (column wise).</p>
<p>This is equivalent to concatenation along the second axis, except for 1-D
arrays where it concatenates along the first axis. Rebuilds arrays divided
by <cite>hsplit</cite>.</p>
<p>This function makes most sense for arrays with up to 3 dimensions. For
instance, for pixel-data with a height (first axis), width (second axis),
and r/g/b channels (third axis). The functions <cite>concatenate</cite>, <cite>stack</cite> and
<cite>block</cite> provide more general stacking and concatenation operations.</p>
<dl class="simple">
<dt>tup<span class="classifier">sequence of ndarrays</span></dt><dd><p>The arrays must have the same shape along all but the second axis,
except 1-D arrays which can be any length.</p>
</dd>
</dl>
<dl class="simple">
<dt>stacked<span class="classifier">ndarray</span></dt><dd><p>The array formed by stacking the given arrays.</p>
</dd>
</dl>
<p>concatenate : Join a sequence of arrays along an existing axis.
stack : Join a sequence of arrays along a new axis.
block : Assemble an nd-array from nested lists of blocks.
vstack : Stack arrays in sequence vertically (row wise).
dstack : Stack arrays in sequence depth wise (along third axis).
column_stack : Stack 1-D arrays as columns into a 2-D array.
hsplit : Split an array into multiple sub-arrays horizontally (column-wise).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
<span class="go">array([1, 2, 3, 4, 5, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">],[</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
<span class="go">array([[1, 4],</span>
<span class="go">       [2, 5],</span>
<span class="go">       [3, 6]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.i0">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">i0</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.i0" title="Permalink to this definition">¶</a></dt>
<dd><p>Modified Bessel function of the first kind, order 0.</p>
<p>Usually denoted <span class="math notranslate nohighlight">\(I_0\)</span>.</p>
<dl class="simple">
<dt>x<span class="classifier">array_like of float</span></dt><dd><p>Argument of the Bessel function.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray, shape = x.shape, dtype = float</span></dt><dd><p>The modified Bessel function evaluated at each of the elements of <cite>x</cite>.</p>
</dd>
</dl>
<p>scipy.special.i0, scipy.special.iv, scipy.special.ive</p>
<p>The scipy implementation is recommended over this function: it is a
proper ufunc written in C, and more than an order of magnitude faster.</p>
<p>We use the algorithm published by Clenshaw <a href="#id83"><span class="problematic" id="id38">[1]_</span></a> and referenced by
Abramowitz and Stegun <a href="#id84"><span class="problematic" id="id39">[2]_</span></a>, for which the function domain is
partitioned into the two intervals [0,8] and (8,inf), and Chebyshev
polynomial expansions are employed in each interval. Relative error on
the domain [0,30] using IEEE arithmetic is documented <a href="#id85"><span class="problematic" id="id40">[3]_</span></a> as having a
peak of 5.8e-16 with an rms of 1.4e-16 (n = 30000).</p>
<dl class="footnote brackets">
<dt class="label" id="id41"><span class="brackets">1</span></dt>
<dd><p>C. W. Clenshaw, “Chebyshev series for mathematical functions”, in
<em>National Physical Laboratory Mathematical Tables</em>, vol. 5, London:
Her Majesty’s Stationery Office, 1962.</p>
</dd>
<dt class="label" id="id42"><span class="brackets">2</span></dt>
<dd><p>M. Abramowitz and I. A. Stegun, <em>Handbook of Mathematical
Functions</em>, 10th printing, New York: Dover, 1964, pp. 379.
<a class="reference external" href="http://www.math.sfu.ca/~cbm/aands/page_379.htm">http://www.math.sfu.ca/~cbm/aands/page_379.htm</a></p>
</dd>
<dt class="label" id="id43"><span class="brackets">3</span></dt>
<dd><p><a class="reference external" href="https://metacpan.org/pod/distribution/Math-Cephes/lib/Math/Cephes.pod#i0:-Modified-Bessel-function-of-order-zero">https://metacpan.org/pod/distribution/Math-Cephes/lib/Math/Cephes.pod#i0:-Modified-Bessel-function-of-order-zero</a></p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">i0</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
<span class="go">array(1.0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">i0</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">array([1.        , 1.26606588, 2.2795853 , 4.88079259])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.identity">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">identity</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">like</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.identity" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the identity array.</p>
<p>The identity array is a square array with ones on
the main diagonal.</p>
<dl>
<dt>n<span class="classifier">int</span></dt><dd><p>Number of rows (and columns) in <cite>n</cite> x <cite>n</cite> output.</p>
</dd>
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>Data-type of the output.  Defaults to <code class="docutils literal notranslate"><span class="pre">float</span></code>.</p>
</dd>
<dt>like<span class="classifier">array_like</span></dt><dd><p>Reference object to allow the creation of arrays which are not
NumPy arrays. If an array-like passed in as <code class="docutils literal notranslate"><span class="pre">like</span></code> supports
the <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> protocol, the result will be defined
by it. In this case, it ensures the creation of an array object
compatible with that passed in via this argument.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.20.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p><cite>n</cite> x <cite>n</cite> array with its main diagonal set to one,
and all other elements 0.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">array([[1.,  0.,  0.],</span>
<span class="go">       [0.,  1.,  0.],</span>
<span class="go">       [0.,  0.,  1.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt id="numpy.iinfo">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">iinfo</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.iinfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Machine limits for integer types.</p>
<dl class="simple">
<dt>bits<span class="classifier">int</span></dt><dd><p>The number of bits occupied by the type.</p>
</dd>
<dt>min<span class="classifier">int</span></dt><dd><p>The smallest integer expressible by the type.</p>
</dd>
<dt>max<span class="classifier">int</span></dt><dd><p>The largest integer expressible by the type.</p>
</dd>
</dl>
<dl class="simple">
<dt>int_type<span class="classifier">integer type, dtype, or instance</span></dt><dd><p>The kind of integer data type to get information about.</p>
</dd>
</dl>
<p>finfo : The equivalent for floating point data types.</p>
<p>With types:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ii16</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ii16</span><span class="o">.</span><span class="n">min</span>
<span class="go">-32768</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ii16</span><span class="o">.</span><span class="n">max</span>
<span class="go">32767</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ii32</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ii32</span><span class="o">.</span><span class="n">min</span>
<span class="go">-2147483648</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ii32</span><span class="o">.</span><span class="n">max</span>
<span class="go">2147483647</span>
</pre></div>
</div>
<p>With instances:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ii32</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ii32</span><span class="o">.</span><span class="n">min</span>
<span class="go">-2147483648</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ii32</span><span class="o">.</span><span class="n">max</span>
<span class="go">2147483647</span>
</pre></div>
</div>
<dl class="py method">
<dt id="numpy.iinfo.max">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">max</span></code><a class="headerlink" href="#numpy.iinfo.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum value of given dtype.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.iinfo.min">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">min</span></code><a class="headerlink" href="#numpy.iinfo.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimum value of given dtype.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="numpy.imag">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">imag</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">val</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.imag" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the imaginary part of the complex argument.</p>
<dl class="simple">
<dt>val<span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray or scalar</span></dt><dd><p>The imaginary component of the complex argument. If <cite>val</cite> is real,
the type of <cite>val</cite> is used for the output.  If <cite>val</cite> has complex
elements, the returned type is float.</p>
</dd>
</dl>
<p>real, angle, real_if_close</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="o">+</span><span class="mi">4</span><span class="n">j</span><span class="p">,</span> <span class="mi">5</span><span class="o">+</span><span class="mi">6</span><span class="n">j</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">imag</span>
<span class="go">array([2.,  4.,  6.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([1. +8.j,  3.+10.j,  5.+12.j])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.in1d">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">in1d</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ar1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ar2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">assume_unique</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invert</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.in1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether each element of a 1-D array is also present in a second array.</p>
<p>Returns a boolean array the same length as <cite>ar1</cite> that is True
where an element of <cite>ar1</cite> is in <cite>ar2</cite> and False otherwise.</p>
<p>We recommend using <a class="reference internal" href="#numpy.isin" title="numpy.isin"><code class="xref py py-func docutils literal notranslate"><span class="pre">isin()</span></code></a> instead of <cite>in1d</cite> for new code.</p>
<dl>
<dt>ar1<span class="classifier">(M,) array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt>ar2<span class="classifier">array_like</span></dt><dd><p>The values against which to test each value of <cite>ar1</cite>.</p>
</dd>
<dt>assume_unique<span class="classifier">bool, optional</span></dt><dd><p>If True, the input arrays are both assumed to be unique, which
can speed up the calculation.  Default is False.</p>
</dd>
<dt>invert<span class="classifier">bool, optional</span></dt><dd><p>If True, the values in the returned array are inverted (that is,
False where an element of <cite>ar1</cite> is in <cite>ar2</cite> and True otherwise).
Default is False. <code class="docutils literal notranslate"><span class="pre">np.in1d(a,</span> <span class="pre">b,</span> <span class="pre">invert=True)</span></code> is equivalent
to (but is faster than) <code class="docutils literal notranslate"><span class="pre">np.invert(in1d(a,</span> <span class="pre">b))</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>in1d<span class="classifier">(M,) ndarray, bool</span></dt><dd><p>The values <cite>ar1[in1d]</cite> are in <cite>ar2</cite>.</p>
</dd>
</dl>
<dl class="simple">
<dt>isin<span class="classifier">Version of this function that preserves the</span></dt><dd><p>shape of ar1.</p>
</dd>
<dt>numpy.lib.arraysetops<span class="classifier">Module with a number of other functions for</span></dt><dd><p>performing set operations on arrays.</p>
</dd>
</dl>
<p><cite>in1d</cite> can be considered as an element-wise function version of the
python keyword <cite>in</cite>, for 1-D sequences. <code class="docutils literal notranslate"><span class="pre">in1d(a,</span> <span class="pre">b)</span></code> is roughly
equivalent to <code class="docutils literal notranslate"><span class="pre">np.array([item</span> <span class="pre">in</span> <span class="pre">b</span> <span class="pre">for</span> <span class="pre">item</span> <span class="pre">in</span> <span class="pre">a])</span></code>.
However, this idea fails if <cite>ar2</cite> is a set, or similar (non-sequence)
container:  As <code class="docutils literal notranslate"><span class="pre">ar2</span></code> is converted to an array, in those cases
<code class="docutils literal notranslate"><span class="pre">asarray(ar2)</span></code> is an object array rather than the expected array of
contained values.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.4.0.</span></p>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">states</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">states</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span>
<span class="go">array([ True, False,  True, False,  True])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
<span class="go">array([0, 2, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span>
<span class="go">array([False,  True, False,  True, False])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
<span class="go">array([1, 5])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.indices">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">indices</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">dimensions</span></em>, <em class="sig-param"><span class="pre">dtype=&lt;class</span> <span class="pre">'int'&gt;</span></em>, <em class="sig-param"><span class="pre">sparse=False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array representing the indices of a grid.</p>
<p>Compute an array where the subarrays contain index values 0, 1, …
varying only along the corresponding axis.</p>
<dl>
<dt>dimensions<span class="classifier">sequence of ints</span></dt><dd><p>The shape of the grid.</p>
</dd>
<dt>dtype<span class="classifier">dtype, optional</span></dt><dd><p>Data type of the result.</p>
</dd>
<dt>sparse<span class="classifier">boolean, optional</span></dt><dd><p>Return a sparse representation of the grid instead of a dense
representation. Default is False.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.17.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>grid<span class="classifier">one ndarray or tuple of ndarrays</span></dt><dd><dl class="simple">
<dt>If sparse is False:</dt><dd><p>Returns one array of grid indices,
<code class="docutils literal notranslate"><span class="pre">grid.shape</span> <span class="pre">=</span> <span class="pre">(len(dimensions),)</span> <span class="pre">+</span> <span class="pre">tuple(dimensions)</span></code>.</p>
</dd>
<dt>If sparse is True:</dt><dd><p>Returns a tuple of arrays, with
<code class="docutils literal notranslate"><span class="pre">grid[i].shape</span> <span class="pre">=</span> <span class="pre">(1,</span> <span class="pre">...,</span> <span class="pre">1,</span> <span class="pre">dimensions[i],</span> <span class="pre">1,</span> <span class="pre">...,</span> <span class="pre">1)</span></code> with
dimensions[i] in the ith place</p>
</dd>
</dl>
</dd>
</dl>
<p>mgrid, ogrid, meshgrid</p>
<p>The output shape in the dense case is obtained by prepending the number
of dimensions in front of the tuple of dimensions, i.e. if <cite>dimensions</cite>
is a tuple <code class="docutils literal notranslate"><span class="pre">(r0,</span> <span class="pre">...,</span> <span class="pre">rN-1)</span></code> of length <code class="docutils literal notranslate"><span class="pre">N</span></code>, the output shape is
<code class="docutils literal notranslate"><span class="pre">(N,</span> <span class="pre">r0,</span> <span class="pre">...,</span> <span class="pre">rN-1)</span></code>.</p>
<p>The subarrays <code class="docutils literal notranslate"><span class="pre">grid[k]</span></code> contains the N-D array of indices along the
<code class="docutils literal notranslate"><span class="pre">k-th</span></code> axis. Explicitly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">grid</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i0</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">iN</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ik</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 2, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>        <span class="c1"># row indices</span>
<span class="go">array([[0, 0, 0],</span>
<span class="go">       [1, 1, 1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>        <span class="c1"># column indices</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [0, 1, 2]])</span>
</pre></div>
</div>
<p>The indices can be used as an index into an array.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [4, 5, 6]])</span>
</pre></div>
</div>
<p>Note that it would be more straightforward in the above example to
extract the required elements directly with <code class="docutils literal notranslate"><span class="pre">x[:2,</span> <span class="pre">:3]</span></code>.</p>
<p>If sparse is set to true, the grid will be returned in a sparse
representation.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span>        <span class="c1"># row indices</span>
<span class="go">array([[0],</span>
<span class="go">       [1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j</span>        <span class="c1"># column indices</span>
<span class="go">array([[0, 1, 2]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt id="numpy.inexact">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">inexact</span></code><a class="headerlink" href="#numpy.inexact" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class of all numeric scalar types with a (potentially)
inexact representation of the values in its range, such as
floating-point numbers.</p>
</dd></dl>

<dl class="py function">
<dt id="numpy.info">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">info</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">object=None</span></em>, <em class="sig-param"><span class="pre">maxwidth=76</span></em>, <em class="sig-param"><span class="pre">output=&lt;_io.TextIOWrapper</span> <span class="pre">name='&lt;stdout&gt;'</span> <span class="pre">mode='w'</span> <span class="pre">encoding='utf-8'&gt;</span></em>, <em class="sig-param"><span class="pre">toplevel='numpy'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.info" title="Permalink to this definition">¶</a></dt>
<dd><p>Get help information for a function, class, or module.</p>
<dl class="simple">
<dt>object<span class="classifier">object or str, optional</span></dt><dd><p>Input object or name to get information about. If <cite>object</cite> is a
numpy object, its docstring is given. If it is a string, available
modules are searched for matching objects.  If None, information
about <cite>info</cite> itself is returned.</p>
</dd>
<dt>maxwidth<span class="classifier">int, optional</span></dt><dd><p>Printing width.</p>
</dd>
<dt>output<span class="classifier">file like object, optional</span></dt><dd><p>File like object that the output is written to, default is
<code class="docutils literal notranslate"><span class="pre">stdout</span></code>.  The object has to be opened in ‘w’ or ‘a’ mode.</p>
</dd>
<dt>toplevel<span class="classifier">str, optional</span></dt><dd><p>Start search at this level.</p>
</dd>
</dl>
<p>source, lookfor</p>
<p>When used interactively with an object, <code class="docutils literal notranslate"><span class="pre">np.info(obj)</span></code> is equivalent
to <code class="docutils literal notranslate"><span class="pre">help(obj)</span></code> on the Python prompt or <code class="docutils literal notranslate"><span class="pre">obj?</span></code> on the IPython
prompt.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">)</span> 
<span class="go">   polyval(p, x)</span>
<span class="go">     Evaluate the polynomial p at x.</span>
<span class="go">     ...</span>
</pre></div>
</div>
<p>When using a string for <cite>object</cite> it is possible to get multiple results.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;fft&#39;</span><span class="p">)</span> 
<span class="go">     *** Found in numpy ***</span>
<span class="go">Core FFT routines</span>
<span class="gp">...</span>
<span class="go">     *** Found in numpy.fft ***</span>
<span class="go"> fft(a, n=None, axis=-1)</span>
<span class="gp">...</span>
<span class="go">     *** Repeat reference found in numpy.fft.fftpack ***</span>
<span class="go">     *** Total of 3 references found. ***</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.inner">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">inner</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.inner" title="Permalink to this definition">¶</a></dt>
<dd><p>Inner product of two arrays.</p>
<p>Ordinary inner product of vectors for 1-D arrays (without complex
conjugation), in higher dimensions a sum product over the last axes.</p>
<dl class="simple">
<dt>a, b<span class="classifier">array_like</span></dt><dd><p>If <cite>a</cite> and <cite>b</cite> are nonscalar, their last dimensions must match.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>If <cite>a</cite> and <cite>b</cite> are both
scalars or both 1-D arrays then a scalar is returned; otherwise
an array is returned.
<code class="docutils literal notranslate"><span class="pre">out.shape</span> <span class="pre">=</span> <span class="pre">(*a.shape[:-1],</span> <span class="pre">*b.shape[:-1])</span></code></p>
</dd>
</dl>
<dl class="simple">
<dt>ValueError</dt><dd><p>If both <cite>a</cite> and <cite>b</cite> are nonscalar and their last dimensions have
different sizes.</p>
</dd>
</dl>
<p>tensordot : Sum products over arbitrary axes.
dot : Generalised matrix product, using second last dimension of <cite>b</cite>.
einsum : Einstein summation convention.</p>
<p>For vectors (1-D arrays) it computes the ordinary inner-product:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="p">[:]</span><span class="o">*</span><span class="n">b</span><span class="p">[:])</span>
</pre></div>
</div>
<p>More generally, if <cite>ndim(a) = r &gt; 0</cite> and <cite>ndim(b) = s &gt; 0</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>or explicitly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)[</span><span class="n">i0</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="n">ir</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="n">j0</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="n">js</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
     <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i0</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="n">ir</span><span class="o">-</span><span class="mi">2</span><span class="p">,:]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="n">j0</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="n">js</span><span class="o">-</span><span class="mi">2</span><span class="p">,:])</span>
</pre></div>
</div>
<p>In addition <cite>a</cite> or <cite>b</cite> may be scalars, in which case:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span>
</pre></div>
</div>
<p>Ordinary inner product for vectors:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>Some multidimensional examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">array([[ 14,  38,  62],</span>
<span class="go">       [ 86, 110, 134]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 1, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">array([[[1, 3, 5]]])</span>
</pre></div>
</div>
<p>An example where <cite>b</cite> is a scalar:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="mi">7</span><span class="p">)</span>
<span class="go">array([[7., 0.],</span>
<span class="go">       [0., 7.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.insert">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">insert</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert values along the given axis before the given indices.</p>
<dl>
<dt>arr<span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt>obj<span class="classifier">int, slice or sequence of ints</span></dt><dd><p>Object that defines the index or indices before which <cite>values</cite> is
inserted.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
<p>Support for multiple insertions when <cite>obj</cite> is a single scalar or a
sequence with one element (similar to calling insert multiple
times).</p>
</dd>
<dt>values<span class="classifier">array_like</span></dt><dd><p>Values to insert into <cite>arr</cite>. If the type of <cite>values</cite> is different
from that of <cite>arr</cite>, <cite>values</cite> is converted to the type of <cite>arr</cite>.
<cite>values</cite> should be shaped so that <code class="docutils literal notranslate"><span class="pre">arr[...,obj,...]</span> <span class="pre">=</span> <span class="pre">values</span></code>
is legal.</p>
</dd>
<dt>axis<span class="classifier">int, optional</span></dt><dd><p>Axis along which to insert <cite>values</cite>.  If <cite>axis</cite> is None then <cite>arr</cite>
is flattened first.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>A copy of <cite>arr</cite> with <cite>values</cite> inserted.  Note that <cite>insert</cite>
does not occur in-place: a new array is returned. If
<cite>axis</cite> is None, <cite>out</cite> is a flattened array.</p>
</dd>
</dl>
<p>append : Append elements at the end of an array.
concatenate : Join a sequence of arrays along an existing axis.
delete : Delete elements from an array.</p>
<p>Note that for higher dimensional inserts <cite>obj=0</cite> behaves very different
from <cite>obj=[0]</cite> just like <cite>arr[:,0,:] = values</cite> is different from
<cite>arr[:,[0],:] = values</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[1, 1],</span>
<span class="go">       [2, 2],</span>
<span class="go">       [3, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">array([1, 5, 1, ..., 2, 3, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[1, 5, 1],</span>
<span class="go">       [2, 5, 2],</span>
<span class="go">       [3, 5, 3]])</span>
</pre></div>
</div>
<p>Difference between sequence and scalars:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[1, 1, 1],</span>
<span class="go">       [2, 2, 2],</span>
<span class="go">       [3, 3, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
<span class="gp">... </span>               <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([1, 1, 2, 2, 3, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="go">array([1, 1, 5, ..., 2, 3, 3])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="go">array([1, 1, 5, ..., 2, 3, 3])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mf">7.13</span><span class="p">,</span> <span class="kc">False</span><span class="p">])</span> <span class="c1"># type casting</span>
<span class="go">array([1, 1, 7, ..., 2, 3, 3])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="mi">999</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[  0, 999,   1,   2, 999,   3],</span>
<span class="go">       [  4, 999,   5,   6, 999,   7]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.int0">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">int0</span></code><a class="headerlink" href="#numpy.int0" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.int64" title="numpy.int64"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.int64</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt id="numpy.int16">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">int16</span></code><a class="headerlink" href="#numpy.int16" title="Permalink to this definition">¶</a></dt>
<dd><p>Signed integer type, compatible with C <code class="docutils literal notranslate"><span class="pre">short</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Character code</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">'h'</span></code></p>
</dd>
<dt class="field-even">Canonical name</dt>
<dd class="field-even"><p><cite>numpy.short</cite></p>
</dd>
<dt class="field-odd">Alias on this platform (Linux x86_64)</dt>
<dd class="field-odd"><p><cite>numpy.int16</cite>: 16-bit signed integer (<code class="docutils literal notranslate"><span class="pre">-32_768</span></code> to <code class="docutils literal notranslate"><span class="pre">32_767</span></code>).</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="numpy.int32">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">int32</span></code><a class="headerlink" href="#numpy.int32" title="Permalink to this definition">¶</a></dt>
<dd><p>Signed integer type, compatible with C <code class="docutils literal notranslate"><span class="pre">int</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Character code</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">'i'</span></code></p>
</dd>
<dt class="field-even">Canonical name</dt>
<dd class="field-even"><p><cite>numpy.intc</cite></p>
</dd>
<dt class="field-odd">Alias on this platform (Linux x86_64)</dt>
<dd class="field-odd"><p><cite>numpy.int32</cite>: 32-bit signed integer (<code class="docutils literal notranslate"><span class="pre">-2_147_483_648</span></code> to <code class="docutils literal notranslate"><span class="pre">2_147_483_647</span></code>).</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="numpy.int64">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">int64</span></code><a class="headerlink" href="#numpy.int64" title="Permalink to this definition">¶</a></dt>
<dd><p>Signed integer type, compatible with Python <cite>int</cite> and C <code class="docutils literal notranslate"><span class="pre">long</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Character code</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">'l'</span></code></p>
</dd>
<dt class="field-even">Canonical name</dt>
<dd class="field-even"><p><cite>numpy.int_</cite></p>
</dd>
<dt class="field-odd">Alias on this platform (Linux x86_64)</dt>
<dd class="field-odd"><p><cite>numpy.int64</cite>: 64-bit signed integer (<code class="docutils literal notranslate"><span class="pre">-9_223_372_036_854_775_808</span></code> to <code class="docutils literal notranslate"><span class="pre">9_223_372_036_854_775_807</span></code>).</p>
</dd>
<dt class="field-even">Alias on this platform (Linux x86_64)</dt>
<dd class="field-even"><p><cite>numpy.intp</cite>: Signed integer large enough to fit pointer, compatible with C <code class="docutils literal notranslate"><span class="pre">intptr_t</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="numpy.int8">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">int8</span></code><a class="headerlink" href="#numpy.int8" title="Permalink to this definition">¶</a></dt>
<dd><p>Signed integer type, compatible with C <code class="docutils literal notranslate"><span class="pre">char</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Character code</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">'b'</span></code></p>
</dd>
<dt class="field-even">Canonical name</dt>
<dd class="field-even"><p><cite>numpy.byte</cite></p>
</dd>
<dt class="field-odd">Alias on this platform (Linux x86_64)</dt>
<dd class="field-odd"><p><cite>numpy.int8</cite>: 8-bit signed integer (<code class="docutils literal notranslate"><span class="pre">-128</span></code> to <code class="docutils literal notranslate"><span class="pre">127</span></code>).</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.int_">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">int_</span></code><a class="headerlink" href="#numpy.int_" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.int64" title="numpy.int64"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.int64</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.intc">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">intc</span></code><a class="headerlink" href="#numpy.intc" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.int32" title="numpy.int32"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.int32</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt id="numpy.integer">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">integer</span></code><a class="headerlink" href="#numpy.integer" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class of all integer scalar types.</p>
<dl class="py attribute">
<dt id="numpy.integer.denominator">
<code class="sig-name descname"><span class="pre">denominator</span></code><a class="headerlink" href="#numpy.integer.denominator" title="Permalink to this definition">¶</a></dt>
<dd><p>denominator of value (1)</p>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.integer.numerator">
<code class="sig-name descname"><span class="pre">numerator</span></code><a class="headerlink" href="#numpy.integer.numerator" title="Permalink to this definition">¶</a></dt>
<dd><p>numerator of value (the value itself)</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="numpy.interp">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">interp</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">left</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">right</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">period</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.interp" title="Permalink to this definition">¶</a></dt>
<dd><p>One-dimensional linear interpolation for monotonically increasing sample points.</p>
<p>Returns the one-dimensional piecewise linear interpolant to a function
with given discrete data points (<cite>xp</cite>, <cite>fp</cite>), evaluated at <cite>x</cite>.</p>
<dl>
<dt>x<span class="classifier">array_like</span></dt><dd><p>The x-coordinates at which to evaluate the interpolated values.</p>
</dd>
<dt>xp<span class="classifier">1-D sequence of floats</span></dt><dd><p>The x-coordinates of the data points, must be increasing if argument
<cite>period</cite> is not specified. Otherwise, <cite>xp</cite> is internally sorted after
normalizing the periodic boundaries with <code class="docutils literal notranslate"><span class="pre">xp</span> <span class="pre">=</span> <span class="pre">xp</span> <span class="pre">%</span> <span class="pre">period</span></code>.</p>
</dd>
<dt>fp<span class="classifier">1-D sequence of float or complex</span></dt><dd><p>The y-coordinates of the data points, same length as <cite>xp</cite>.</p>
</dd>
<dt>left<span class="classifier">optional float or complex corresponding to fp</span></dt><dd><p>Value to return for <cite>x &lt; xp[0]</cite>, default is <cite>fp[0]</cite>.</p>
</dd>
<dt>right<span class="classifier">optional float or complex corresponding to fp</span></dt><dd><p>Value to return for <cite>x &gt; xp[-1]</cite>, default is <cite>fp[-1]</cite>.</p>
</dd>
<dt>period<span class="classifier">None or float, optional</span></dt><dd><p>A period for the x-coordinates. This parameter allows the proper
interpolation of angular x-coordinates. Parameters <cite>left</cite> and <cite>right</cite>
are ignored if <cite>period</cite> is specified.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>y<span class="classifier">float or complex (corresponding to fp) or ndarray</span></dt><dd><p>The interpolated values, same shape as <cite>x</cite>.</p>
</dd>
</dl>
<dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>xp</cite> and <cite>fp</cite> have different length
If <cite>xp</cite> or <cite>fp</cite> are not 1-D sequences
If <cite>period == 0</cite></p>
</dd>
</dl>
<p>scipy.interpolate</p>
<p>The x-coordinate sequence is expected to be increasing, but this is not
explicitly enforced.  However, if the sequence <cite>xp</cite> is non-increasing,
interpolation results are meaningless.</p>
<p>Note that, since NaN is unsortable, <cite>xp</cite> also cannot contain NaNs.</p>
<p>A simple check for <cite>xp</cite> being strictly increasing is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">xp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="mf">2.5</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.72</span><span class="p">,</span> <span class="mf">3.14</span><span class="p">],</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span>
<span class="go">array([3.  , 3.  , 2.5 , 0.56, 0.  ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">UNDEF</span> <span class="o">=</span> <span class="o">-</span><span class="mf">99.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="mf">3.14</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">UNDEF</span><span class="p">)</span>
<span class="go">-99.0</span>
</pre></div>
</div>
<p>Plot an interpolant to the sine function:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yinterp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">yinterp</span><span class="p">,</span> <span class="s1">&#39;-x&#39;</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Interpolation with periodic x-coordinates:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span> <span class="o">-</span><span class="mi">170</span><span class="p">,</span> <span class="o">-</span><span class="mi">185</span><span class="p">,</span> <span class="mi">185</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">365</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">190</span><span class="p">,</span> <span class="o">-</span><span class="mi">190</span><span class="p">,</span> <span class="mi">350</span><span class="p">,</span> <span class="o">-</span><span class="mi">350</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="mi">360</span><span class="p">)</span>
<span class="go">array([7.5 , 5.  , 8.75, 6.25, 3.  , 3.25, 3.5 , 3.75])</span>
</pre></div>
</div>
<p>Complex interpolation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="n">j</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span>
<span class="go">array([0.+1.j , 1.+1.5j])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.intersect1d">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">intersect1d</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ar1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ar2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">assume_unique</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.intersect1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the intersection of two arrays.</p>
<p>Return the sorted, unique values that are in both of the input arrays.</p>
<dl>
<dt>ar1, ar2<span class="classifier">array_like</span></dt><dd><p>Input arrays. Will be flattened if not already 1D.</p>
</dd>
<dt>assume_unique<span class="classifier">bool</span></dt><dd><p>If True, the input arrays are both assumed to be unique, which
can speed up the calculation.  If True but <code class="docutils literal notranslate"><span class="pre">ar1</span></code> or <code class="docutils literal notranslate"><span class="pre">ar2</span></code> are not
unique, incorrect results and out-of-bounds indices could result.
Default is False.</p>
</dd>
<dt>return_indices<span class="classifier">bool</span></dt><dd><p>If True, the indices which correspond to the intersection of the two
arrays are returned. The first instance of a value is used if there are
multiple. Default is False.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.15.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>intersect1d<span class="classifier">ndarray</span></dt><dd><p>Sorted 1D array of common and unique elements.</p>
</dd>
<dt>comm1<span class="classifier">ndarray</span></dt><dd><p>The indices of the first occurrences of the common values in <cite>ar1</cite>.
Only provided if <cite>return_indices</cite> is True.</p>
</dd>
<dt>comm2<span class="classifier">ndarray</span></dt><dd><p>The indices of the first occurrences of the common values in <cite>ar2</cite>.
Only provided if <cite>return_indices</cite> is True.</p>
</dd>
</dl>
<dl class="simple">
<dt>numpy.lib.arraysetops<span class="classifier">Module with a number of other functions for</span></dt><dd><p>performing set operations on arrays.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">array([1, 3])</span>
</pre></div>
</div>
<p>To intersect more than two arrays, use functools.reduce:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">reduce</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reduce</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">,</span> <span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">array([3])</span>
</pre></div>
</div>
<p>To return the indices of the values common to the input arrays
along with the intersected values:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xy</span><span class="p">,</span> <span class="n">x_ind</span><span class="p">,</span> <span class="n">y_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">return_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_ind</span><span class="p">,</span> <span class="n">y_ind</span>
<span class="go">(array([0, 2, 4]), array([1, 0, 2]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xy</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="n">x_ind</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">y_ind</span><span class="p">]</span>
<span class="go">(array([1, 2, 4]), array([1, 2, 4]), array([1, 2, 4]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.intp">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">intp</span></code><a class="headerlink" href="#numpy.intp" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.int64" title="numpy.int64"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.int64</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="numpy.is_busday">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">is_busday</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weekmask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'1111100'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">holidays</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">busdaycal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.is_busday" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates which of the given dates are valid days, and which are not.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<dl class="simple">
<dt>dates<span class="classifier">array_like of datetime64[D]</span></dt><dd><p>The array of dates to process.</p>
</dd>
<dt>weekmask<span class="classifier">str or array_like of bool, optional</span></dt><dd><p>A seven-element array indicating which of Monday through Sunday are
valid days. May be specified as a length-seven list or array, like
[1,1,1,1,1,0,0]; a length-seven string, like ‘1111100’; or a string
like “Mon Tue Wed Thu Fri”, made up of 3-character abbreviations for
weekdays, optionally separated by white space. Valid abbreviations
are: Mon Tue Wed Thu Fri Sat Sun</p>
</dd>
<dt>holidays<span class="classifier">array_like of datetime64[D], optional</span></dt><dd><p>An array of dates to consider as invalid dates.  They may be
specified in any order, and NaT (not-a-time) dates are ignored.
This list is saved in a normalized form that is suited for
fast calculations of valid days.</p>
</dd>
<dt>busdaycal<span class="classifier">busdaycalendar, optional</span></dt><dd><p>A <cite>busdaycalendar</cite> object which specifies the valid days. If this
parameter is provided, neither weekmask nor holidays may be
provided.</p>
</dd>
<dt>out<span class="classifier">array of bool, optional</span></dt><dd><p>If provided, this array is filled with the result.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">array of bool</span></dt><dd><p>An array with the same shape as <code class="docutils literal notranslate"><span class="pre">dates</span></code>, containing True for
each valid day, and False for each invalid day.</p>
</dd>
</dl>
<p>busdaycalendar : An object that specifies a custom set of valid days.
busday_offset : Applies an offset counted in valid days.
busday_count : Counts how many valid days are in a half-open date range.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># The weekdays are Friday, Saturday, and Monday</span>
<span class="gp">... </span><span class="n">np</span><span class="o">.</span><span class="n">is_busday</span><span class="p">([</span><span class="s1">&#39;2011-07-01&#39;</span><span class="p">,</span> <span class="s1">&#39;2011-07-02&#39;</span><span class="p">,</span> <span class="s1">&#39;2011-07-18&#39;</span><span class="p">],</span>
<span class="gp">... </span>                <span class="n">holidays</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;2011-07-01&#39;</span><span class="p">,</span> <span class="s1">&#39;2011-07-04&#39;</span><span class="p">,</span> <span class="s1">&#39;2011-07-17&#39;</span><span class="p">])</span>
<span class="go">array([False, False,  True])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.isclose">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">isclose</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">equal_nan</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.isclose" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a boolean array where two arrays are element-wise equal within a
tolerance.</p>
<p>The tolerance values are positive, typically very small numbers.  The
relative difference (<cite>rtol</cite> * abs(<cite>b</cite>)) and the absolute difference
<cite>atol</cite> are added together to compare against the absolute difference
between <cite>a</cite> and <cite>b</cite>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The default <cite>atol</cite> is not appropriate for comparing numbers
that are much smaller than one (see Notes).</p>
</div>
<dl class="simple">
<dt>a, b<span class="classifier">array_like</span></dt><dd><p>Input arrays to compare.</p>
</dd>
<dt>rtol<span class="classifier">float</span></dt><dd><p>The relative tolerance parameter (see Notes).</p>
</dd>
<dt>atol<span class="classifier">float</span></dt><dd><p>The absolute tolerance parameter (see Notes).</p>
</dd>
<dt>equal_nan<span class="classifier">bool</span></dt><dd><p>Whether to compare NaN’s as equal.  If True, NaN’s in <cite>a</cite> will be
considered equal to NaN’s in <cite>b</cite> in the output array.</p>
</dd>
</dl>
<dl class="simple">
<dt>y<span class="classifier">array_like</span></dt><dd><p>Returns a boolean array of where <cite>a</cite> and <cite>b</cite> are equal within the
given tolerance. If both <cite>a</cite> and <cite>b</cite> are scalars, returns a single
boolean value.</p>
</dd>
</dl>
<p>allclose
math.isclose</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<p>For finite values, isclose uses the following equation to test whether
two floating point values are equivalent.</p>
<blockquote>
<div><p>absolute(<cite>a</cite> - <cite>b</cite>) &lt;= (<cite>atol</cite> + <cite>rtol</cite> * absolute(<cite>b</cite>))</p>
</div></blockquote>
<p>Unlike the built-in <cite>math.isclose</cite>, the above equation is not symmetric
in <cite>a</cite> and <cite>b</cite> – it assumes <cite>b</cite> is the reference value – so that
<cite>isclose(a, b)</cite> might be different from <cite>isclose(b, a)</cite>. Furthermore,
the default value of atol is not zero, and is used to determine what
small values should be considered close to zero. The default value is
appropriate for expected values of order unity: if the expected values
are significantly smaller than one, it can result in false positives.
<cite>atol</cite> should be carefully selected for the use case at hand. A zero value
for <cite>atol</cite> will result in <cite>False</cite> if either <cite>a</cite> or <cite>b</cite> is zero.</p>
<p><cite>isclose</cite> is not defined for non-numeric data types.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">([</span><span class="mf">1e10</span><span class="p">,</span><span class="mf">1e-7</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.00001e10</span><span class="p">,</span><span class="mf">1e-8</span><span class="p">])</span>
<span class="go">array([ True, False])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">([</span><span class="mf">1e10</span><span class="p">,</span><span class="mf">1e-8</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.00001e10</span><span class="p">,</span><span class="mf">1e-9</span><span class="p">])</span>
<span class="go">array([ True, True])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">([</span><span class="mf">1e10</span><span class="p">,</span><span class="mf">1e-8</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0001e10</span><span class="p">,</span><span class="mf">1e-9</span><span class="p">])</span>
<span class="go">array([False,  True])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
<span class="go">array([ True, False])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">equal_nan</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([ True, True])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">([</span><span class="mf">1e-8</span><span class="p">,</span> <span class="mf">1e-7</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
<span class="go">array([ True, False])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">([</span><span class="mf">1e-100</span><span class="p">,</span> <span class="mf">1e-7</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
<span class="go">array([False, False])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">([</span><span class="mf">1e-10</span><span class="p">,</span> <span class="mf">1e-10</span><span class="p">],</span> <span class="p">[</span><span class="mf">1e-20</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
<span class="go">array([ True,  True])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">([</span><span class="mf">1e-10</span><span class="p">,</span> <span class="mf">1e-10</span><span class="p">],</span> <span class="p">[</span><span class="mf">1e-20</span><span class="p">,</span> <span class="mf">0.999999e-10</span><span class="p">],</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
<span class="go">array([False,  True])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.iscomplex">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">iscomplex</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.iscomplex" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a bool array, where True if input element is complex.</p>
<p>What is tested is whether the input has a non-zero imaginary part, not if
the input type is complex.</p>
<dl class="simple">
<dt>x<span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray of bools</span></dt><dd><p>Output array.</p>
</dd>
</dl>
<p>isreal
iscomplexobj : Return True if x is a complex type or an array of complex</p>
<blockquote>
<div><p>numbers.</p>
</div></blockquote>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">iscomplex</span><span class="p">([</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="n">j</span><span class="p">])</span>
<span class="go">array([ True, False, False, False, False,  True])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.iscomplexobj">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">iscomplexobj</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.iscomplexobj" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for a complex type or an array of complex numbers.</p>
<p>The type of the input is checked, not the value. Even if the input
has an imaginary part equal to zero, <cite>iscomplexobj</cite> evaluates to True.</p>
<dl class="simple">
<dt>x<span class="classifier">any</span></dt><dd><p>The input can be of any type and shape.</p>
</dd>
</dl>
<dl class="simple">
<dt>iscomplexobj<span class="classifier">bool</span></dt><dd><p>The return value, True if <cite>x</cite> is of a complex type or has at least
one complex element.</p>
</dd>
</dl>
<p>isrealobj, iscomplex</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.isfortran">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">isfortran</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.isfortran" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the array is Fortran contiguous but <em>not</em> C contiguous.</p>
<p>This function is obsolete and, because of changes due to relaxed stride
checking, its return value for the same array may differ for versions
of NumPy &gt;= 1.10.0 and previous versions. If you only want to check if an
array is Fortran contiguous use <code class="docutils literal notranslate"><span class="pre">a.flags.f_contiguous</span></code> instead.</p>
<dl class="simple">
<dt>a<span class="classifier">ndarray</span></dt><dd><p>Input array.</p>
</dd>
</dl>
<dl class="simple">
<dt>isfortran<span class="classifier">bool</span></dt><dd><p>Returns True if the array is Fortran contiguous but <em>not</em> C contiguous.</p>
</dd>
</dl>
<p>np.array allows to specify whether the array is written in C-contiguous
order (last index varies the fastest), or FORTRAN-contiguous order in
memory (first index varies the fastest).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]],</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [4, 5, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isfortran</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]],</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [4, 5, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isfortran</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The transpose of a C-ordered array is a FORTRAN-ordered array.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]],</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [4, 5, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isfortran</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([[1, 4],</span>
<span class="go">       [2, 5],</span>
<span class="go">       [3, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isfortran</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>C-ordered arrays evaluate as False even if they are also FORTRAN-ordered.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isfortran</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">))</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.isin">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">isin</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">element</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test_elements</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">assume_unique</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invert</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.isin" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <cite>element in test_elements</cite>, broadcasting over <cite>element</cite> only.
Returns a boolean array of the same shape as <cite>element</cite> that is True
where an element of <cite>element</cite> is in <cite>test_elements</cite> and False otherwise.</p>
<dl class="simple">
<dt>element<span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt>test_elements<span class="classifier">array_like</span></dt><dd><p>The values against which to test each value of <cite>element</cite>.
This argument is flattened if it is an array or array_like.
See notes for behavior with non-array-like parameters.</p>
</dd>
<dt>assume_unique<span class="classifier">bool, optional</span></dt><dd><p>If True, the input arrays are both assumed to be unique, which
can speed up the calculation.  Default is False.</p>
</dd>
<dt>invert<span class="classifier">bool, optional</span></dt><dd><p>If True, the values in the returned array are inverted, as if
calculating <cite>element not in test_elements</cite>. Default is False.
<code class="docutils literal notranslate"><span class="pre">np.isin(a,</span> <span class="pre">b,</span> <span class="pre">invert=True)</span></code> is equivalent to (but faster
than) <code class="docutils literal notranslate"><span class="pre">np.invert(np.isin(a,</span> <span class="pre">b))</span></code>.</p>
</dd>
</dl>
<dl class="simple">
<dt>isin<span class="classifier">ndarray, bool</span></dt><dd><p>Has the same shape as <cite>element</cite>. The values <cite>element[isin]</cite>
are in <cite>test_elements</cite>.</p>
</dd>
</dl>
<p>in1d                  : Flattened version of this function.
numpy.lib.arraysetops : Module with a number of other functions for</p>
<blockquote>
<div><p>performing set operations on arrays.</p>
</div></blockquote>
<p><cite>isin</cite> is an element-wise function version of the python keyword <cite>in</cite>.
<code class="docutils literal notranslate"><span class="pre">isin(a,</span> <span class="pre">b)</span></code> is roughly equivalent to
<code class="docutils literal notranslate"><span class="pre">np.array([item</span> <span class="pre">in</span> <span class="pre">b</span> <span class="pre">for</span> <span class="pre">item</span> <span class="pre">in</span> <span class="pre">a])</span></code> if <cite>a</cite> and <cite>b</cite> are 1-D sequences.</p>
<p><cite>element</cite> and <cite>test_elements</cite> are converted to arrays if they are not
already. If <cite>test_elements</cite> is a set (or other non-sequence collection)
it will be converted to an object array with one element, rather than an
array of the values contained in <cite>test_elements</cite>. This is a consequence
of the <cite>array</cite> constructor’s way of handling non-sequence collections.
Converting the set to a list usually gives the desired behavior.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.13.0.</span></p>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">element</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">element</span>
<span class="go">array([[0, 2],</span>
<span class="go">       [4, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test_elements</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">test_elements</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span>
<span class="go">array([[False,  True],</span>
<span class="go">       [ True, False]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">element</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
<span class="go">array([2, 4])</span>
</pre></div>
</div>
<p>The indices of the matched values can be obtained with <cite>nonzero</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
<span class="go">(array([0, 1]), array([1, 0]))</span>
</pre></div>
</div>
<p>The test can also be inverted:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">test_elements</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span>
<span class="go">array([[ True, False],</span>
<span class="go">       [False,  True]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">element</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
<span class="go">array([0, 6])</span>
</pre></div>
</div>
<p>Because of how <cite>array</cite> handles sets, the following does not
work as expected:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">test_set</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">test_set</span><span class="p">)</span>
<span class="go">array([[False, False],</span>
<span class="go">       [False, False]])</span>
</pre></div>
</div>
<p>Casting the set to a list gives the expected result:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">test_set</span><span class="p">))</span>
<span class="go">array([[False,  True],</span>
<span class="go">       [ True, False]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.isneginf">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">isneginf</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.isneginf" title="Permalink to this definition">¶</a></dt>
<dd><p>Test element-wise for negative infinity, return result as bool array.</p>
<dl class="simple">
<dt>x<span class="classifier">array_like</span></dt><dd><p>The input array.</p>
</dd>
<dt>out<span class="classifier">array_like, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have a
shape that the input broadcasts to. If not provided or None, a
freshly-allocated boolean array is returned.</p>
</dd>
</dl>
<dl>
<dt>out<span class="classifier">ndarray</span></dt><dd><p>A boolean array with the same dimensions as the input.
If second argument is not supplied then a numpy boolean array is
returned with values True where the corresponding element of the
input is negative infinity and values False where the element of
the input is not negative infinity.</p>
<p>If a second argument is supplied the result is stored there. If the
type of that array is a numeric type the result is represented as
zeros and ones, if the type is boolean then as False and True. The
return value <cite>out</cite> is then a reference to that array.</p>
</dd>
</dl>
<p>isinf, isposinf, isnan, isfinite</p>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754).</p>
<p>Errors result if the second argument is also supplied when x is a scalar
input, if first and second arguments have different shapes, or if the
first argument has complex values.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">NINF</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">PINF</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
<span class="go">array([ True, False, False])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">array([1, 0, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([1, 0, 0])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.isposinf">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">isposinf</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.isposinf" title="Permalink to this definition">¶</a></dt>
<dd><p>Test element-wise for positive infinity, return result as bool array.</p>
<dl class="simple">
<dt>x<span class="classifier">array_like</span></dt><dd><p>The input array.</p>
</dd>
<dt>out<span class="classifier">array_like, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have a
shape that the input broadcasts to. If not provided or None, a
freshly-allocated boolean array is returned.</p>
</dd>
</dl>
<dl>
<dt>out<span class="classifier">ndarray</span></dt><dd><p>A boolean array with the same dimensions as the input.
If second argument is not supplied then a boolean array is returned
with values True where the corresponding element of the input is
positive infinity and values False where the element of the input is
not positive infinity.</p>
<p>If a second argument is supplied the result is stored there. If the
type of that array is a numeric type the result is represented as zeros
and ones, if the type is boolean then as False and True.
The return value <cite>out</cite> is then a reference to that array.</p>
</dd>
</dl>
<p>isinf, isneginf, isfinite, isnan</p>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754).</p>
<p>Errors result if the second argument is also supplied when x is a scalar
input, if first and second arguments have different shapes, or if the
first argument has complex values</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isposinf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">PINF</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isposinf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isposinf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">NINF</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isposinf</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
<span class="go">array([False, False,  True])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isposinf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">array([0, 0, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([0, 0, 1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.isreal">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">isreal</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.isreal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a bool array, where True if input element is real.</p>
<p>If element has complex type with zero complex part, the return value
for that element is True.</p>
<dl class="simple">
<dt>x<span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray, bool</span></dt><dd><p>Boolean array of same shape as <cite>x</cite>.</p>
</dd>
</dl>
<p><cite>isreal</cite> may behave unexpectedly for string or object arrays (see examples)</p>
<p>iscomplex
isrealobj : Return True if x is not a complex type.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="n">j</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([False,  True,  True,  True,  True, False])</span>
</pre></div>
</div>
<p>The function does not work on string arrays.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;U&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c1"># Warns about non-elementwise comparison</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Returns True for all elements in input array of <code class="docutils literal notranslate"><span class="pre">dtype=object</span></code> even if
any of the elements is complex.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="o">+</span><span class="mi">4</span><span class="n">j</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([ True,  True,  True])</span>
</pre></div>
</div>
<p>isreal should not be used with object arrays</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([ True,  True])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.isrealobj">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">isrealobj</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.isrealobj" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if x is a not complex type or an array of complex numbers.</p>
<p>The type of the input is checked, not the value. So even if the input
has an imaginary part equal to zero, <cite>isrealobj</cite> evaluates to False
if the data type is complex.</p>
<dl class="simple">
<dt>x<span class="classifier">any</span></dt><dd><p>The input can be of any type and shape.</p>
</dd>
</dl>
<dl class="simple">
<dt>y<span class="classifier">bool</span></dt><dd><p>The return value, False if <cite>x</cite> is of a complex type.</p>
</dd>
</dl>
<p>iscomplexobj, isreal</p>
<p>The function is only meant for arrays with numerical values but it
accepts all other objects. Since it assumes array input, the return
value of other objects may be True.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">(</span><span class="s1">&#39;A string&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.isscalar">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">isscalar</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">element</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.isscalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the type of <cite>element</cite> is a scalar type.</p>
<dl class="simple">
<dt>element<span class="classifier">any</span></dt><dd><p>Input argument, can be of any type and shape.</p>
</dd>
</dl>
<dl class="simple">
<dt>val<span class="classifier">bool</span></dt><dd><p>True if <cite>element</cite> is a scalar type, False if it is not.</p>
</dd>
</dl>
<p>ndim : Get the number of dimensions of an array</p>
<p>If you need a stricter way to identify a <em>numerical</em> scalar, use
<code class="docutils literal notranslate"><span class="pre">isinstance(x,</span> <span class="pre">numbers.Number)</span></code>, as that returns <code class="docutils literal notranslate"><span class="pre">False</span></code> for most
non-numerical elements such as strings.</p>
<p>In most cases <code class="docutils literal notranslate"><span class="pre">np.ndim(x)</span> <span class="pre">==</span> <span class="pre">0</span></code> should be used instead of this function,
as that will also return true for 0d arrays. This is how numpy overloads
functions in the style of the <code class="docutils literal notranslate"><span class="pre">dx</span></code> arguments to <cite>gradient</cite> and the <code class="docutils literal notranslate"><span class="pre">bins</span></code>
argument to <cite>histogram</cite>. Some key differences:</p>
<table class="table">
<colgroup>
<col style="width: 53%" />
<col style="width: 21%" />
<col style="width: 26%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>x</p></th>
<th class="head"><p><code class="docutils literal notranslate"><span class="pre">isscalar(x)</span></code></p></th>
<th class="head"><p><code class="docutils literal notranslate"><span class="pre">np.ndim(x)</span> <span class="pre">==</span> <span class="pre">0</span></code></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>PEP 3141 numeric objects (including
builtins)</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">True</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">True</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>builtin string and buffer objects</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">True</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">True</span></code></p></td>
</tr>
<tr class="row-even"><td><p>other builtin objects, like
<cite>pathlib.Path</cite>, <cite>Exception</cite>,
the result of <cite>re.compile</cite></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">False</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">True</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>third-party objects like
<cite>matplotlib.figure.Figure</cite></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">False</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">True</span></code></p></td>
</tr>
<tr class="row-even"><td><p>zero-dimensional numpy arrays</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">False</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">True</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>other numpy arrays</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">False</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">False</span></code></p></td>
</tr>
<tr class="row-even"><td><p><cite>list</cite>, <cite>tuple</cite>, and other sequence
objects</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">False</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">False</span></code></p></td>
</tr>
</tbody>
</table>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="mf">3.1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mf">3.1</span><span class="p">))</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">([</span><span class="mf">3.1</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>NumPy supports PEP 3141 numbers:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fractions</span> <span class="kn">import</span> <span class="n">Fraction</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">17</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Number</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">Number</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.issctype">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">issctype</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rep</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.issctype" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines whether the given object represents a scalar data-type.</p>
<dl class="simple">
<dt>rep<span class="classifier">any</span></dt><dd><p>If <cite>rep</cite> is an instance of a scalar dtype, True is returned. If not,
False is returned.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">bool</span></dt><dd><p>Boolean result of check whether <cite>rep</cite> is a scalar dtype.</p>
</dd>
</dl>
<p>issubsctype, issubdtype, obj2sctype, sctype2char</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">issctype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">issctype</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">issctype</span><span class="p">(</span><span class="mf">1.1</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Strings are also a scalar type:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">issctype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;str&#39;</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.issubclass_">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">issubclass_</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.issubclass_" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if a class is a subclass of a second class.</p>
<p><cite>issubclass_</cite> is equivalent to the Python built-in <code class="docutils literal notranslate"><span class="pre">issubclass</span></code>,
except that it returns False instead of raising a TypeError if one
of the arguments is not a class.</p>
<dl class="simple">
<dt>arg1<span class="classifier">class</span></dt><dd><p>Input class. True is returned if <cite>arg1</cite> is a subclass of <cite>arg2</cite>.</p>
</dd>
<dt>arg2<span class="classifier">class or tuple of classes.</span></dt><dd><p>Input class. If a tuple of classes, True is returned if <cite>arg1</cite> is a
subclass of any of the tuple elements.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">bool</span></dt><dd><p>Whether <cite>arg1</cite> is a subclass of <cite>arg2</cite> or not.</p>
</dd>
</dl>
<p>issubsctype, issubdtype, issctype</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">issubclass_</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">issubclass_</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">issubclass_</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.issubdtype">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">issubdtype</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.issubdtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if first argument is a typecode lower/equal in type hierarchy.</p>
<p>This is like the builtin <code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code>, but for <cite>dtype</cite>s.</p>
<dl class="simple">
<dt>arg1, arg2<span class="classifier">dtype_like</span></dt><dd><p><cite>dtype</cite> or object coercible to one</p>
</dd>
</dl>
<p>out : bool</p>
<p><span class="xref std std-ref">arrays.scalars</span> : Overview of the numpy type hierarchy.
issubsctype, <a href="#id86"><span class="problematic" id="id87">issubclass_</span></a></p>
<p><cite>issubdtype</cite> can be used to check the type of arrays:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">ints</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">ints</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">floats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">floats</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">floats</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Similar types of different sizes are not subdtypes of each other:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>but both are subtypes of <cite>floating</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>For convenience, dtype-like objects are allowed too:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="s1">&#39;S1&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">string_</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="s1">&#39;i4&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">signedinteger</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.issubsctype">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">issubsctype</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.issubsctype" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if the first argument is a subclass of the second argument.</p>
<dl class="simple">
<dt>arg1, arg2<span class="classifier">dtype or dtype specifier</span></dt><dd><p>Data-types.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">bool</span></dt><dd><p>The result.</p>
</dd>
</dl>
<p>issctype, issubdtype, obj2sctype</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">issubsctype</span><span class="p">(</span><span class="s1">&#39;S8&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">issubsctype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">int</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">issubsctype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">float</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.iterable">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">iterable</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.iterable" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether or not an object can be iterated over.</p>
<dl class="simple">
<dt>y<span class="classifier">object</span></dt><dd><p>Input object.</p>
</dd>
</dl>
<dl class="simple">
<dt>b<span class="classifier">bool</span></dt><dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the object has an iterator method or is a
sequence and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.ix_">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">ix_</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ix_" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct an open mesh from multiple sequences.</p>
<p>This function takes N 1-D sequences and returns N outputs with N
dimensions each, such that the shape is 1 in all but one dimension
and the dimension with the non-unit shape value cycles through all
N dimensions.</p>
<p>Using <cite>ix_</cite> one can quickly construct index arrays that will index
the cross product. <code class="docutils literal notranslate"><span class="pre">a[np.ix_([1,3],[2,5])]</span></code> returns the array
<code class="docutils literal notranslate"><span class="pre">[[a[1,2]</span> <span class="pre">a[1,5]],</span> <span class="pre">[a[3,2]</span> <span class="pre">a[3,5]]]</span></code>.</p>
<dl class="simple">
<dt>args<span class="classifier">1-D sequences</span></dt><dd><p>Each sequence should be of integer or boolean type.
Boolean sequences will be interpreted as boolean masks for the
corresponding dimension (equivalent to passing in
<code class="docutils literal notranslate"><span class="pre">np.nonzero(boolean_sequence)</span></code>).</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">tuple of ndarrays</span></dt><dd><p>N arrays with N dimensions each, with N the number of input
sequences. Together these arrays form an open mesh.</p>
</dd>
</dl>
<p>ogrid, mgrid, meshgrid</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1, 2, 3, 4],</span>
<span class="go">       [5, 6, 7, 8, 9]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ixgrid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ixgrid</span>
<span class="go">(array([[0],</span>
<span class="go">       [1]]), array([[2, 4]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ixgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">ixgrid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">((2, 1), (1, 2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">ixgrid</span><span class="p">]</span>
<span class="go">array([[2, 4],</span>
<span class="go">       [7, 9]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ixgrid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">ixgrid</span><span class="p">]</span>
<span class="go">array([[2, 4],</span>
<span class="go">       [7, 9]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ixgrid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">ixgrid</span><span class="p">]</span>
<span class="go">array([[2, 4],</span>
<span class="go">       [7, 9]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.kaiser">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">kaiser</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.kaiser" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Kaiser window.</p>
<p>The Kaiser window is a taper formed by using a Bessel function.</p>
<dl class="simple">
<dt>M<span class="classifier">int</span></dt><dd><p>Number of points in the output window. If zero or less, an
empty array is returned.</p>
</dd>
<dt>beta<span class="classifier">float</span></dt><dd><p>Shape parameter for window.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">array</span></dt><dd><p>The window, with the maximum value normalized to one (the value
one appears only if the number of samples is odd).</p>
</dd>
</dl>
<p>bartlett, blackman, hamming, hanning</p>
<p>The Kaiser window is defined as</p>
<div class="math notranslate nohighlight">
\[w(n) = I_0\left( \beta \sqrt{1-\frac{4n^2}{(M-1)^2}}
\right)/I_0(\beta)\]</div>
<p>with</p>
<div class="math notranslate nohighlight">
\[\quad -\frac{M-1}{2} \leq n \leq \frac{M-1}{2},\]</div>
<p>where <span class="math notranslate nohighlight">\(I_0\)</span> is the modified zeroth-order Bessel function.</p>
<p>The Kaiser was named for Jim Kaiser, who discovered a simple
approximation to the DPSS window based on Bessel functions.  The Kaiser
window is a very good approximation to the Digital Prolate Spheroidal
Sequence, or Slepian window, which is the transform which maximizes the
energy in the main lobe of the window relative to total energy.</p>
<p>The Kaiser can approximate many other windows by varying the beta
parameter.</p>
<table class="table">
<colgroup>
<col style="width: 15%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>beta</p></th>
<th class="head"><p>Window shape</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>Rectangular</p></td>
</tr>
<tr class="row-odd"><td><p>5</p></td>
<td><p>Similar to a Hamming</p></td>
</tr>
<tr class="row-even"><td><p>6</p></td>
<td><p>Similar to a Hanning</p></td>
</tr>
<tr class="row-odd"><td><p>8.6</p></td>
<td><p>Similar to a Blackman</p></td>
</tr>
</tbody>
</table>
<p>A beta value of 14 is probably a good starting point. Note that as beta
gets large, the window narrows, and so the number of samples needs to be
large enough to sample the increasingly narrow spike, otherwise NaNs will
get returned.</p>
<p>Most references to the Kaiser window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
“removing the foot”, i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function.</p>
<dl class="footnote brackets">
<dt class="label" id="id44"><span class="brackets">1</span></dt>
<dd><p>J. F. Kaiser, “Digital Filters” - Ch 7 in “Systems analysis by
digital computer”, Editors: F.F. Kuo and J.F. Kaiser, p 218-285.
John Wiley and Sons, New York, (1966).</p>
</dd>
<dt class="label" id="id45"><span class="brackets">2</span></dt>
<dd><p>E.R. Kanasewich, “Time Sequence Analysis in Geophysics”, The
University of Alberta Press, 1975, pp. 177-178.</p>
</dd>
<dt class="label" id="id46"><span class="brackets">3</span></dt>
<dd><p>Wikipedia, “Window function”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Window_function">https://en.wikipedia.org/wiki/Window_function</a></p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">kaiser</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span>
<span class="go"> array([7.72686684e-06, 3.46009194e-03, 4.65200189e-02, # may vary</span>
<span class="go">        2.29737120e-01, 5.99885316e-01, 9.45674898e-01,</span>
<span class="go">        9.45674898e-01, 5.99885316e-01, 2.29737120e-01,</span>
<span class="go">        4.65200189e-02, 3.46009194e-03, 7.72686684e-06])</span>
</pre></div>
</div>
<p>Plot the window and the frequency response:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy.fft</span> <span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">fftshift</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kaiser</span><span class="p">(</span><span class="mi">51</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Kaiser window&quot;</span><span class="p">)</span>
<span class="go">Text(0.5, 1.0, &#39;Kaiser window&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Amplitude&quot;</span><span class="p">)</span>
<span class="go">Text(0, 0.5, &#39;Amplitude&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Sample&quot;</span><span class="p">)</span>
<span class="go">Text(0.5, 0, &#39;Sample&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="go">&lt;Figure size 640x480 with 0 Axes&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span> <span class="o">/</span> <span class="mf">25.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fftshift</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">mag</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">response</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Frequency response of Kaiser window&quot;</span><span class="p">)</span>
<span class="go">Text(0.5, 1.0, &#39;Frequency response of Kaiser window&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Magnitude [dB]&quot;</span><span class="p">)</span>
<span class="go">Text(0, 0.5, &#39;Magnitude [dB]&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Normalized frequency [cycles per sample]&quot;</span><span class="p">)</span>
<span class="go">Text(0.5, 0, &#39;Normalized frequency [cycles per sample]&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
<span class="go">(-0.5, 0.5, -100.0, ...) # may vary</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.kron">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">kron</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.kron" title="Permalink to this definition">¶</a></dt>
<dd><p>Kronecker product of two arrays.</p>
<p>Computes the Kronecker product, a composite array made of blocks of the
second array scaled by the first.</p>
<p>a, b : array_like</p>
<p>out : ndarray</p>
<p>outer : The outer product</p>
<p>The function assumes that the number of dimensions of <cite>a</cite> and <cite>b</cite>
are the same, if necessary prepending the smallest with ones.
If <code class="docutils literal notranslate"><span class="pre">a.shape</span> <span class="pre">=</span> <span class="pre">(r0,r1,..,rN)</span></code> and <code class="docutils literal notranslate"><span class="pre">b.shape</span> <span class="pre">=</span> <span class="pre">(s0,s1,...,sN)</span></code>,
the Kronecker product has shape <code class="docutils literal notranslate"><span class="pre">(r0*s0,</span> <span class="pre">r1*s1,</span> <span class="pre">...,</span> <span class="pre">rN*SN)</span></code>.
The elements are products of elements from <cite>a</cite> and <cite>b</cite>, organized
explicitly by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">kron</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)[</span><span class="n">k0</span><span class="p">,</span><span class="n">k1</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="n">kN</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i0</span><span class="p">,</span><span class="n">i1</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="n">iN</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="n">j0</span><span class="p">,</span><span class="n">j1</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="n">jN</span><span class="p">]</span>
</pre></div>
</div>
<p>where:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">kt</span> <span class="o">=</span> <span class="n">it</span> <span class="o">*</span> <span class="n">st</span> <span class="o">+</span> <span class="n">jt</span><span class="p">,</span>  <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="n">N</span>
</pre></div>
</div>
<p>In the common 2-D case (N=1), the block structure can be visualized:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">,</span>   <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">,</span>  <span class="o">...</span> <span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span>  <span class="p">],</span>
 <span class="p">[</span>  <span class="o">...</span>                              <span class="o">...</span>   <span class="p">],</span>
 <span class="p">[</span> <span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">,</span>  <span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="o">...</span> <span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span> <span class="p">]]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">100</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">])</span>
<span class="go">array([  5,   6,   7, ..., 500, 600, 700])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">100</span><span class="p">])</span>
<span class="go">array([  5,  50, 500, ...,   7,  70, 700])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
<span class="go">array([[1.,  1.,  0.,  0.],</span>
<span class="go">       [1.,  1.,  0.,  0.],</span>
<span class="go">       [0.,  0.,  1.,  1.],</span>
<span class="go">       [0.,  0.,  1.,  1.]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 10, 6, 20)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">J</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">J1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">+</span> <span class="n">J</span>             <span class="c1"># extend to ndim=4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">S1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">J1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="n">K</span><span class="p">]</span> <span class="o">==</span> <span class="n">a</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="n">J</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.lexsort">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">lexsort</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">keys</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.lexsort" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform an indirect stable sort using a sequence of keys.</p>
<p>Given multiple sorting keys, which can be interpreted as columns in a
spreadsheet, lexsort returns an array of integer indices that describes
the sort order by multiple columns. The last key in the sequence is used
for the primary sort order, the second-to-last key for the secondary sort
order, and so on. The keys argument must be a sequence of objects that
can be converted to arrays of the same shape. If a 2D array is provided
for the keys argument, its rows are interpreted as the sorting keys and
sorting is according to the last row, second last row etc.</p>
<dl class="simple">
<dt>keys<span class="classifier">(k, N) array or tuple containing k (N,)-shaped sequences</span></dt><dd><p>The <cite>k</cite> different “columns” to be sorted.  The last column (or row if
<cite>keys</cite> is a 2D array) is the primary sort key.</p>
</dd>
<dt>axis<span class="classifier">int, optional</span></dt><dd><p>Axis to be indirectly sorted.  By default, sort over the last axis.</p>
</dd>
</dl>
<dl class="simple">
<dt>indices<span class="classifier">(N,) ndarray of ints</span></dt><dd><p>Array of indices that sort the keys along the specified axis.</p>
</dd>
</dl>
<p>argsort : Indirect sort.
ndarray.sort : In-place sort.
sort : Return a sorted copy of an array.</p>
<p>Sort names: first by surname, then by name.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">surnames</span> <span class="o">=</span>    <span class="p">(</span><span class="s1">&#39;Hertz&#39;</span><span class="p">,</span>    <span class="s1">&#39;Galilei&#39;</span><span class="p">,</span> <span class="s1">&#39;Hertz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">first_names</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Heinrich&#39;</span><span class="p">,</span> <span class="s1">&#39;Galileo&#39;</span><span class="p">,</span> <span class="s1">&#39;Gustav&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">((</span><span class="n">first_names</span><span class="p">,</span> <span class="n">surnames</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span>
<span class="go">array([1, 2, 0])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">surnames</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="n">first_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">]</span>
<span class="go">[&#39;Galilei, Galileo&#39;, &#39;Hertz, Gustav&#39;, &#39;Hertz, Heinrich&#39;]</span>
</pre></div>
</div>
<p>Sort two columns of numbers:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="c1"># First column</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># Second column</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">((</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">))</span> <span class="c1"># Sort by a, then by b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span>
<span class="go">array([2, 0, 4, 6, 5, 3, 1])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">]</span>
<span class="go">[(1, 0), (1, 9), (3, 0), (4, 1), (4, 2), (4, 4), (5, 4)]</span>
</pre></div>
</div>
<p>Note that sorting is first according to the elements of <code class="docutils literal notranslate"><span class="pre">a</span></code>.
Secondary sorting is according to the elements of <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
<p>A normal <code class="docutils literal notranslate"><span class="pre">argsort</span></code> would have yielded:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">a</span><span class="p">)]</span>
<span class="go">[(1, 9), (1, 0), (3, 0), (4, 4), (4, 2), (4, 1), (5, 4)]</span>
</pre></div>
</div>
<p>Structured arrays are sorted lexically by <code class="docutils literal notranslate"><span class="pre">argsort</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">9</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span>
<span class="gp">... </span>             <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">([(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)]))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># or np.argsort(x, order=(&#39;x&#39;, &#39;y&#39;))</span>
<span class="go">array([2, 0, 4, 6, 5, 3, 1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.linspace">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">linspace</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stop</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endpoint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">retstep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.linspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Return evenly spaced numbers over a specified interval.</p>
<p>Returns <cite>num</cite> evenly spaced samples, calculated over the
interval [<cite>start</cite>, <cite>stop</cite>].</p>
<p>The endpoint of the interval can optionally be excluded.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.16.0: </span>Non-scalar <cite>start</cite> and <cite>stop</cite> are now supported.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.20.0: </span>Values are rounded towards <code class="docutils literal notranslate"><span class="pre">-inf</span></code> instead of <code class="docutils literal notranslate"><span class="pre">0</span></code> when an
integer <code class="docutils literal notranslate"><span class="pre">dtype</span></code> is specified. The old behavior can
still be obtained with <code class="docutils literal notranslate"><span class="pre">np.linspace(start,</span> <span class="pre">stop,</span> <span class="pre">num).astype(int)</span></code></p>
</div>
<dl>
<dt>start<span class="classifier">array_like</span></dt><dd><p>The starting value of the sequence.</p>
</dd>
<dt>stop<span class="classifier">array_like</span></dt><dd><p>The end value of the sequence, unless <cite>endpoint</cite> is set to False.
In that case, the sequence consists of all but the last of <code class="docutils literal notranslate"><span class="pre">num</span> <span class="pre">+</span> <span class="pre">1</span></code>
evenly spaced samples, so that <cite>stop</cite> is excluded.  Note that the step
size changes when <cite>endpoint</cite> is False.</p>
</dd>
<dt>num<span class="classifier">int, optional</span></dt><dd><p>Number of samples to generate. Default is 50. Must be non-negative.</p>
</dd>
<dt>endpoint<span class="classifier">bool, optional</span></dt><dd><p>If True, <cite>stop</cite> is the last sample. Otherwise, it is not included.
Default is True.</p>
</dd>
<dt>retstep<span class="classifier">bool, optional</span></dt><dd><p>If True, return (<cite>samples</cite>, <cite>step</cite>), where <cite>step</cite> is the spacing
between samples.</p>
</dd>
<dt>dtype<span class="classifier">dtype, optional</span></dt><dd><p>The type of the output array.  If <cite>dtype</cite> is not given, the data type
is inferred from <cite>start</cite> and <cite>stop</cite>. The inferred dtype will never be
an integer; <cite>float</cite> is chosen even if the arguments would produce an
array of integers.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.9.0.</span></p>
</div>
</dd>
<dt>axis<span class="classifier">int, optional</span></dt><dd><p>The axis in the result to store the samples.  Relevant only if start
or stop are array-like.  By default (0), the samples will be along a
new axis inserted at the beginning. Use -1 to get an axis at the end.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.16.0.</span></p>
</div>
</dd>
</dl>
<dl>
<dt>samples<span class="classifier">ndarray</span></dt><dd><p>There are <cite>num</cite> equally spaced samples in the closed interval
<code class="docutils literal notranslate"><span class="pre">[start,</span> <span class="pre">stop]</span></code> or the half-open interval <code class="docutils literal notranslate"><span class="pre">[start,</span> <span class="pre">stop)</span></code>
(depending on whether <cite>endpoint</cite> is True or False).</p>
</dd>
<dt>step<span class="classifier">float, optional</span></dt><dd><p>Only returned if <cite>retstep</cite> is True</p>
<p>Size of spacing between samples.</p>
</dd>
</dl>
<dl>
<dt>arange<span class="classifier">Similar to <cite>linspace</cite>, but uses a step size (instead of the</span></dt><dd><p>number of samples).</p>
</dd>
<dt>geomspace<span class="classifier">Similar to <cite>linspace</cite>, but with numbers spaced evenly on a log</span></dt><dd><p>scale (a geometric progression).</p>
</dd>
<dt>logspace<span class="classifier">Similar to <cite>geomspace</cite>, but with the end points specified as</span></dt><dd><p>logarithms.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">array([2.  , 2.25, 2.5 , 2.75, 3.  ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">array([2. ,  2.2,  2.4,  2.6,  2.8])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">retstep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)</span>
</pre></div>
</div>
<p>Graphical illustration:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="mi">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">(-0.5, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.load">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">load</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mmap_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_pickle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fix_imports</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ASCII'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load arrays or pickled objects from <code class="docutils literal notranslate"><span class="pre">.npy</span></code>, <code class="docutils literal notranslate"><span class="pre">.npz</span></code> or pickled files.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Loading files that contain object arrays uses the <code class="docutils literal notranslate"><span class="pre">pickle</span></code>
module, which is not secure against erroneous or maliciously
constructed data. Consider passing <code class="docutils literal notranslate"><span class="pre">allow_pickle=False</span></code> to
load data that is known not to contain object arrays for the
safer handling of untrusted sources.</p>
</div>
<dl>
<dt>file<span class="classifier">file-like object, string, or pathlib.Path</span></dt><dd><p>The file to read. File-like objects must support the
<code class="docutils literal notranslate"><span class="pre">seek()</span></code> and <code class="docutils literal notranslate"><span class="pre">read()</span></code> methods. Pickled files require that the
file-like object support the <code class="docutils literal notranslate"><span class="pre">readline()</span></code> method as well.</p>
</dd>
<dt>mmap_mode<span class="classifier">{None, ‘r+’, ‘r’, ‘w+’, ‘c’}, optional</span></dt><dd><p>If not None, then memory-map the file, using the given mode (see
<cite>numpy.memmap</cite> for a detailed description of the modes).  A
memory-mapped array is kept on disk. However, it can be accessed
and sliced like any ndarray.  Memory mapping is especially useful
for accessing small fragments of large files without reading the
entire file into memory.</p>
</dd>
<dt>allow_pickle<span class="classifier">bool, optional</span></dt><dd><p>Allow loading pickled object arrays stored in npy files. Reasons for
disallowing pickles include security, as loading pickled data can
execute arbitrary code. If pickles are disallowed, loading object
arrays will fail. Default: False</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.16.3: </span>Made default False in response to CVE-2019-6446.</p>
</div>
</dd>
<dt>fix_imports<span class="classifier">bool, optional</span></dt><dd><p>Only useful when loading Python 2 generated pickled files on Python 3,
which includes npy/npz files containing object arrays. If <cite>fix_imports</cite>
is True, pickle will try to map the old Python 2 names to the new names
used in Python 3.</p>
</dd>
<dt>encoding<span class="classifier">str, optional</span></dt><dd><p>What encoding to use when reading Python 2 strings. Only useful when
loading Python 2 generated pickled files in Python 3, which includes
npy/npz files containing object arrays. Values other than ‘latin1’,
‘ASCII’, and ‘bytes’ are not allowed, as they can corrupt numerical
data. Default: ‘ASCII’</p>
</dd>
</dl>
<dl class="simple">
<dt>result<span class="classifier">array, tuple, dict, etc.</span></dt><dd><p>Data stored in the file. For <code class="docutils literal notranslate"><span class="pre">.npz</span></code> files, the returned instance
of NpzFile class must be closed to avoid leaking file descriptors.</p>
</dd>
</dl>
<dl class="simple">
<dt>IOError</dt><dd><p>If the input file does not exist or cannot be read.</p>
</dd>
<dt>ValueError</dt><dd><p>The file contains an object array, but allow_pickle=False given.</p>
</dd>
</dl>
<p>save, savez, savez_compressed, loadtxt
memmap : Create a memory-map to an array stored in a file on disk.
lib.format.open_memmap : Create or load a memory-mapped <code class="docutils literal notranslate"><span class="pre">.npy</span></code> file.</p>
<ul>
<li><p>If the file contains pickle data, then whatever object is stored
in the pickle is returned.</p></li>
<li><p>If the file is a <code class="docutils literal notranslate"><span class="pre">.npy</span></code> file, then a single array is returned.</p></li>
<li><p>If the file is a <code class="docutils literal notranslate"><span class="pre">.npz</span></code> file, then a dictionary-like object is
returned, containing <code class="docutils literal notranslate"><span class="pre">{filename:</span> <span class="pre">array}</span></code> key-value pairs, one for
each file in the archive.</p></li>
<li><p>If the file is a <code class="docutils literal notranslate"><span class="pre">.npz</span></code> file, the returned value supports the
context manager protocol in a similar fashion to the open function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">load</span><span class="p">(</span><span class="s1">&#39;foo.npz&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">data</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>The underlying file descriptor is closed when exiting the ‘with’
block.</p>
</li>
</ul>
<p>Store data to disk, and load it again:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;/tmp/123&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;/tmp/123.npy&#39;</span><span class="p">)</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [4, 5, 6]])</span>
</pre></div>
</div>
<p>Store compressed data to disk, and load it again:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="s1">&#39;/tmp/123.npz&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;/tmp/123.npz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [4, 5, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span>
<span class="go">array([1, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>Mem-map the stored array, and then access the second row
directly from disk:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;/tmp/123.npy&#39;</span><span class="p">,</span> <span class="n">mmap_mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
<span class="go">memmap([4, 5, 6])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.loadtxt">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">loadtxt</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">fname</span></em>, <em class="sig-param"><span class="pre">dtype=&lt;class</span> <span class="pre">'float'&gt;</span></em>, <em class="sig-param"><span class="pre">comments='#'</span></em>, <em class="sig-param"><span class="pre">delimiter=None</span></em>, <em class="sig-param"><span class="pre">converters=None</span></em>, <em class="sig-param"><span class="pre">skiprows=0</span></em>, <em class="sig-param"><span class="pre">usecols=None</span></em>, <em class="sig-param"><span class="pre">unpack=False</span></em>, <em class="sig-param"><span class="pre">ndmin=0</span></em>, <em class="sig-param"><span class="pre">encoding='bytes'</span></em>, <em class="sig-param"><span class="pre">max_rows=None</span></em>, <em class="sig-param"><span class="pre">*</span></em>, <em class="sig-param"><span class="pre">like=None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.loadtxt" title="Permalink to this definition">¶</a></dt>
<dd><p>Load data from a text file.</p>
<p>Each row in the text file must have the same number of values.</p>
<dl>
<dt>fname<span class="classifier">file, str, or pathlib.Path</span></dt><dd><p>File, filename, or generator to read.  If the filename extension is
<code class="docutils literal notranslate"><span class="pre">.gz</span></code> or <code class="docutils literal notranslate"><span class="pre">.bz2</span></code>, the file is first decompressed. Note that
generators should return byte strings.</p>
</dd>
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>Data-type of the resulting array; default: float.  If this is a
structured data-type, the resulting array will be 1-dimensional, and
each row will be interpreted as an element of the array.  In this
case, the number of columns used must match the number of fields in
the data-type.</p>
</dd>
<dt>comments<span class="classifier">str or sequence of str, optional</span></dt><dd><p>The characters or list of characters used to indicate the start of a
comment. None implies no comments. For backwards compatibility, byte
strings will be decoded as ‘latin1’. The default is ‘#’.</p>
</dd>
<dt>delimiter<span class="classifier">str, optional</span></dt><dd><p>The string used to separate values. For backwards compatibility, byte
strings will be decoded as ‘latin1’. The default is whitespace.</p>
</dd>
<dt>converters<span class="classifier">dict, optional</span></dt><dd><p>A dictionary mapping column number to a function that will parse the
column string into the desired value.  E.g., if column 0 is a date
string: <code class="docutils literal notranslate"><span class="pre">converters</span> <span class="pre">=</span> <span class="pre">{0:</span> <span class="pre">datestr2num}</span></code>.  Converters can also be
used to provide a default value for missing data (but see also
<cite>genfromtxt</cite>): <code class="docutils literal notranslate"><span class="pre">converters</span> <span class="pre">=</span> <span class="pre">{3:</span> <span class="pre">lambda</span> <span class="pre">s:</span> <span class="pre">float(s.strip()</span> <span class="pre">or</span> <span class="pre">0)}</span></code>.
Default: None.</p>
</dd>
<dt>skiprows<span class="classifier">int, optional</span></dt><dd><p>Skip the first <cite>skiprows</cite> lines, including comments; default: 0.</p>
</dd>
<dt>usecols<span class="classifier">int or sequence, optional</span></dt><dd><p>Which columns to read, with 0 being the first. For example,
<code class="docutils literal notranslate"><span class="pre">usecols</span> <span class="pre">=</span> <span class="pre">(1,4,5)</span></code> will extract the 2nd, 5th and 6th columns.
The default, None, results in all columns being read.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.11.0: </span>When a single column has to be read it is possible to use
an integer instead of a tuple. E.g <code class="docutils literal notranslate"><span class="pre">usecols</span> <span class="pre">=</span> <span class="pre">3</span></code> reads the
fourth column the same way as <code class="docutils literal notranslate"><span class="pre">usecols</span> <span class="pre">=</span> <span class="pre">(3,)</span></code> would.</p>
</div>
</dd>
<dt>unpack<span class="classifier">bool, optional</span></dt><dd><p>If True, the returned array is transposed, so that arguments may be
unpacked using <code class="docutils literal notranslate"><span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">z</span> <span class="pre">=</span> <span class="pre">loadtxt(...)</span></code>.  When used with a
structured data-type, arrays are returned for each field.
Default is False.</p>
</dd>
<dt>ndmin<span class="classifier">int, optional</span></dt><dd><p>The returned array will have at least <cite>ndmin</cite> dimensions.
Otherwise mono-dimensional axes will be squeezed.
Legal values: 0 (default), 1 or 2.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.6.0.</span></p>
</div>
</dd>
<dt>encoding<span class="classifier">str, optional</span></dt><dd><p>Encoding used to decode the inputfile. Does not apply to input streams.
The special value ‘bytes’ enables backward compatibility workarounds
that ensures you receive byte arrays as results if possible and passes
‘latin1’ encoded strings to converters. Override this value to receive
unicode arrays and pass strings as input to converters.  If set to None
the system default is used. The default value is ‘bytes’.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.14.0.</span></p>
</div>
</dd>
<dt>max_rows<span class="classifier">int, optional</span></dt><dd><p>Read <cite>max_rows</cite> lines of content after <cite>skiprows</cite> lines. The default
is to read all the lines.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.16.0.</span></p>
</div>
</dd>
<dt>like<span class="classifier">array_like</span></dt><dd><p>Reference object to allow the creation of arrays which are not
NumPy arrays. If an array-like passed in as <code class="docutils literal notranslate"><span class="pre">like</span></code> supports
the <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> protocol, the result will be defined
by it. In this case, it ensures the creation of an array object
compatible with that passed in via this argument.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.20.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>Data read from the text file.</p>
</dd>
</dl>
<p>load, fromstring, fromregex
genfromtxt : Load data with missing values handled as specified.
scipy.io.loadmat : reads MATLAB data files</p>
<p>This function aims to be a fast reader for simply formatted files.  The
<cite>genfromtxt</cite> function provides more sophisticated handling of, e.g.,
lines with missing values.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.0.</span></p>
</div>
<p>The strings produced by the Python float.hex method can be used as
input for floats.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">StringIO</span>   <span class="c1"># StringIO behaves like a file object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">(</span><span class="s2">&quot;0 1</span><span class="se">\n</span><span class="s2">2 3&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">array([[0., 1.],</span>
<span class="go">       [2., 3.]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">(</span><span class="s2">&quot;M 21 72</span><span class="se">\n</span><span class="s2">F 35 58&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;names&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;gender&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">),</span>
<span class="gp">... </span>                     <span class="s1">&#39;formats&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;S1&#39;</span><span class="p">,</span> <span class="s1">&#39;i4&#39;</span><span class="p">,</span> <span class="s1">&#39;f4&#39;</span><span class="p">)})</span>
<span class="go">array([(b&#39;M&#39;, 21, 72.), (b&#39;F&#39;, 35, 58.)],</span>
<span class="go">      dtype=[(&#39;gender&#39;, &#39;S1&#39;), (&#39;age&#39;, &#39;&lt;i4&#39;), (&#39;weight&#39;, &#39;&lt;f4&#39;)])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">(</span><span class="s2">&quot;1,0,2</span><span class="se">\n</span><span class="s2">3,0,4&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">usecols</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">unpack</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([1., 3.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([2., 4.])</span>
</pre></div>
</div>
<p>This example shows how <cite>converters</cite> can be used to convert a field
with a trailing minus sign into a negative number.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">(</span><span class="s1">&#39;10.01 31.25-</span><span class="se">\n</span><span class="s1">19.22 64.31</span><span class="se">\n</span><span class="s1">17.57- 63.94&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">conv</span><span class="p">(</span><span class="n">fld</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="n">fld</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="n">fld</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;-&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">fld</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">converters</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="n">conv</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="n">conv</span><span class="p">})</span>
<span class="go">array([[ 10.01, -31.25],</span>
<span class="go">       [ 19.22,  64.31],</span>
<span class="go">       [-17.57,  63.94]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.logspace">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">logspace</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stop</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endpoint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.logspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Return numbers spaced evenly on a log scale.</p>
<p>In linear space, the sequence starts at <code class="docutils literal notranslate"><span class="pre">base</span> <span class="pre">**</span> <span class="pre">start</span></code>
(<cite>base</cite> to the power of <cite>start</cite>) and ends with <code class="docutils literal notranslate"><span class="pre">base</span> <span class="pre">**</span> <span class="pre">stop</span></code>
(see <cite>endpoint</cite> below).</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.16.0: </span>Non-scalar <cite>start</cite> and <cite>stop</cite> are now supported.</p>
</div>
<dl>
<dt>start<span class="classifier">array_like</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">base</span> <span class="pre">**</span> <span class="pre">start</span></code> is the starting value of the sequence.</p>
</dd>
<dt>stop<span class="classifier">array_like</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">base</span> <span class="pre">**</span> <span class="pre">stop</span></code> is the final value of the sequence, unless <cite>endpoint</cite>
is False.  In that case, <code class="docutils literal notranslate"><span class="pre">num</span> <span class="pre">+</span> <span class="pre">1</span></code> values are spaced over the
interval in log-space, of which all but the last (a sequence of
length <cite>num</cite>) are returned.</p>
</dd>
<dt>num<span class="classifier">integer, optional</span></dt><dd><p>Number of samples to generate.  Default is 50.</p>
</dd>
<dt>endpoint<span class="classifier">boolean, optional</span></dt><dd><p>If true, <cite>stop</cite> is the last sample. Otherwise, it is not included.
Default is True.</p>
</dd>
<dt>base<span class="classifier">array_like, optional</span></dt><dd><p>The base of the log space. The step size between the elements in
<code class="docutils literal notranslate"><span class="pre">ln(samples)</span> <span class="pre">/</span> <span class="pre">ln(base)</span></code> (or <code class="docutils literal notranslate"><span class="pre">log_base(samples)</span></code>) is uniform.
Default is 10.0.</p>
</dd>
<dt>dtype<span class="classifier">dtype</span></dt><dd><p>The type of the output array.  If <cite>dtype</cite> is not given, the data type
is inferred from <cite>start</cite> and <cite>stop</cite>. The inferred type will never be
an integer; <cite>float</cite> is chosen even if the arguments would produce an
array of integers.</p>
</dd>
<dt>axis<span class="classifier">int, optional</span></dt><dd><p>The axis in the result to store the samples.  Relevant only if start
or stop are array-like.  By default (0), the samples will be along a
new axis inserted at the beginning. Use -1 to get an axis at the end.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.16.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>samples<span class="classifier">ndarray</span></dt><dd><p><cite>num</cite> samples, equally spaced on a log scale.</p>
</dd>
</dl>
<dl class="simple">
<dt>arange<span class="classifier">Similar to linspace, with the step size specified instead of the</span></dt><dd><p>number of samples. Note that, when used with a float endpoint, the
endpoint may or may not be included.</p>
</dd>
<dt>linspace<span class="classifier">Similar to logspace, but with the samples uniformly distributed</span></dt><dd><p>in linear space, instead of log space.</p>
</dd>
</dl>
<p>geomspace : Similar to logspace, but with endpoints specified directly.</p>
<p>Logspace is equivalent to the code</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">num</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="n">endpoint</span><span class="p">)</span>
<span class="gp">... </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">power</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
<span class="gp">... </span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">array([ 100.        ,  215.443469  ,  464.15888336, 1000.        ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">array([100.        ,  177.827941  ,  316.22776602,  562.34132519])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>
<span class="go">array([4.        ,  5.0396842 ,  6.34960421,  8.        ])</span>
</pre></div>
</div>
<p>Graphical illustration:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">(-0.5, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.longcomplex">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">longcomplex</span></code><a class="headerlink" href="#numpy.longcomplex" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.complex256" title="numpy.complex256"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.complex256</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.longdouble">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">longdouble</span></code><a class="headerlink" href="#numpy.longdouble" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.float128" title="numpy.float128"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.float128</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.longfloat">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">longfloat</span></code><a class="headerlink" href="#numpy.longfloat" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.float128" title="numpy.float128"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.float128</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt id="numpy.longlong">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">longlong</span></code><a class="headerlink" href="#numpy.longlong" title="Permalink to this definition">¶</a></dt>
<dd><p>Signed integer type, compatible with C <code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Character code</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">'q'</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="numpy.lookfor">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">lookfor</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">what</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">module</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">import_modules</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">regenerate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.lookfor" title="Permalink to this definition">¶</a></dt>
<dd><p>Do a keyword search on docstrings.</p>
<p>A list of objects that matched the search is displayed,
sorted by relevance. All given keywords need to be found in the
docstring for it to be returned as a result, but the order does
not matter.</p>
<dl class="simple">
<dt>what<span class="classifier">str</span></dt><dd><p>String containing words to look for.</p>
</dd>
<dt>module<span class="classifier">str or list, optional</span></dt><dd><p>Name of module(s) whose docstrings to go through.</p>
</dd>
<dt>import_modules<span class="classifier">bool, optional</span></dt><dd><p>Whether to import sub-modules in packages. Default is True.</p>
</dd>
<dt>regenerate<span class="classifier">bool, optional</span></dt><dd><p>Whether to re-generate the docstring cache. Default is False.</p>
</dd>
<dt>output<span class="classifier">file-like, optional</span></dt><dd><p>File-like object to write the output to. If omitted, use a pager.</p>
</dd>
</dl>
<p>source, info</p>
<p>Relevance is determined only roughly, by checking if the keywords occur
in the function name, at the start of a docstring, etc.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">lookfor</span><span class="p">(</span><span class="s1">&#39;binary representation&#39;</span><span class="p">)</span> 
<span class="go">Search results for &#39;binary representation&#39;</span>
<span class="go">------------------------------------------</span>
<span class="go">numpy.binary_repr</span>
<span class="go">    Return the binary representation of the input number as a string.</span>
<span class="go">numpy.core.setup_common.long_double_representation</span>
<span class="go">    Given a binary dump as given by GNU od -b, look for long double</span>
<span class="go">numpy.base_repr</span>
<span class="go">    Return a string representation of a number in the given base system.</span>
<span class="gp">...</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.mafromtxt">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">mafromtxt</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.mafromtxt" title="Permalink to this definition">¶</a></dt>
<dd><p>Load ASCII data stored in a text file and return a masked array.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 1.17: </span>np.mafromtxt is a deprecated alias of <cite>genfromtxt</cite> which
overwrites the <code class="docutils literal notranslate"><span class="pre">usemask</span></code> argument with <cite>True</cite> even when
explicitly called as <code class="docutils literal notranslate"><span class="pre">mafromtxt(...,</span> <span class="pre">usemask=False)</span></code>.
Use <cite>genfromtxt</cite> instead.</p>
</div>
<p>fname, kwargs : For a description of input parameters, see <cite>genfromtxt</cite>.</p>
<p>numpy.genfromtxt : generic function to load ASCII data.</p>
</dd></dl>

<dl class="py function">
<dt id="numpy.mask_indices">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">mask_indices</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.mask_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices to access (n, n) arrays, given a masking function.</p>
<p>Assume <cite>mask_func</cite> is a function that, for a square array a of size
<code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">n)</span></code> with a possible offset argument <cite>k</cite>, when called as
<code class="docutils literal notranslate"><span class="pre">mask_func(a,</span> <span class="pre">k)</span></code> returns a new array with zeros in certain locations
(functions like <cite>triu</cite> or <cite>tril</cite> do precisely this). Then this function
returns the indices where the non-zero values would be located.</p>
<dl class="simple">
<dt>n<span class="classifier">int</span></dt><dd><p>The returned indices will be valid to access arrays of shape (n, n).</p>
</dd>
<dt>mask_func<span class="classifier">callable</span></dt><dd><p>A function whose call signature is similar to that of <cite>triu</cite>, <cite>tril</cite>.
That is, <code class="docutils literal notranslate"><span class="pre">mask_func(x,</span> <span class="pre">k)</span></code> returns a boolean array, shaped like <cite>x</cite>.
<cite>k</cite> is an optional argument to the function.</p>
</dd>
<dt>k<span class="classifier">scalar</span></dt><dd><p>An optional argument which is passed through to <cite>mask_func</cite>. Functions
like <cite>triu</cite>, <cite>tril</cite> take a second argument that is interpreted as an
offset.</p>
</dd>
</dl>
<dl class="simple">
<dt>indices<span class="classifier">tuple of arrays.</span></dt><dd><p>The <cite>n</cite> arrays of indices corresponding to the locations where
<code class="docutils literal notranslate"><span class="pre">mask_func(np.ones((n,</span> <span class="pre">n)),</span> <span class="pre">k)</span></code> is True.</p>
</dd>
</dl>
<p>triu, tril, triu_indices, tril_indices</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.4.0.</span></p>
</div>
<p>These are the indices that would allow you to access the upper triangular
part of any 3x3 array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">iu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mask_indices</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">)</span>
</pre></div>
</div>
<p>For example, if <cite>a</cite> is a 3x3 array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5],</span>
<span class="go">       [6, 7, 8]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">iu</span><span class="p">]</span>
<span class="go">array([0, 1, 2, 4, 5, 8])</span>
</pre></div>
</div>
<p>An offset can be passed also to the masking function.  This gets us the
indices starting on the first diagonal right of the main one:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">iu1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mask_indices</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>with which we now extract only three elements:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">iu1</span><span class="p">]</span>
<span class="go">array([1, 2, 5])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.mat">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">mat</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.mat" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret the input as a matrix.</p>
<p>Unlike <cite>matrix</cite>, <cite>asmatrix</cite> does not make a copy if the input is already
a matrix or an ndarray.  Equivalent to <code class="docutils literal notranslate"><span class="pre">matrix(data,</span> <span class="pre">copy=False)</span></code>.</p>
<dl class="simple">
<dt>data<span class="classifier">array_like</span></dt><dd><p>Input data.</p>
</dd>
<dt>dtype<span class="classifier">data-type</span></dt><dd><p>Data-type of the output matrix.</p>
</dd>
</dl>
<dl class="simple">
<dt>mat<span class="classifier">matrix</span></dt><dd><p><cite>data</cite> interpreted as a matrix.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asmatrix</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">matrix([[5, 2],</span>
<span class="go">        [3, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt id="numpy.matrix">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">matrix</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is no longer recommended to use this class, even for linear
algebra. Instead use regular arrays. The class may be removed
in the future.</p>
</div>
<p>Returns a matrix from an array-like object, or from a string of data.
A matrix is a specialized 2-D array that retains its 2-D nature
through operations.  It has certain special operators, such as <code class="docutils literal notranslate"><span class="pre">*</span></code>
(matrix multiplication) and <code class="docutils literal notranslate"><span class="pre">**</span></code> (matrix power).</p>
<dl class="simple">
<dt>data<span class="classifier">array_like or string</span></dt><dd><p>If <cite>data</cite> is a string, it is interpreted as a matrix with commas
or spaces separating columns, and semicolons separating rows.</p>
</dd>
<dt>dtype<span class="classifier">data-type</span></dt><dd><p>Data-type of the output matrix.</p>
</dd>
<dt>copy<span class="classifier">bool</span></dt><dd><p>If <cite>data</cite> is already an <cite>ndarray</cite>, then this flag determines
whether the data is copied (the default), or whether a view is
constructed.</p>
</dd>
</dl>
<p>array</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="s1">&#39;1 2; 3 4&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">matrix([[1, 2],</span>
<span class="go">        [3, 4]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="go">matrix([[1, 2],</span>
<span class="go">        [3, 4]])</span>
</pre></div>
</div>
<dl class="py method">
<dt id="numpy.matrix.A">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">A</span></code><a class="headerlink" href="#numpy.matrix.A" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <cite>self</cite> as an <cite>ndarray</cite> object.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">np.asarray(self)</span></code>.</p>
<p>None</p>
<dl class="simple">
<dt>ret<span class="classifier">ndarray</span></dt><dd><p><cite>self</cite> as an <cite>ndarray</cite></p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)));</span> <span class="n">x</span>
<span class="go">matrix([[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">getA</span><span class="p">()</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.matrix.A1">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">A1</span></code><a class="headerlink" href="#numpy.matrix.A1" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <cite>self</cite> as a flattened <cite>ndarray</cite>.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">np.asarray(x).ravel()</span></code></p>
<p>None</p>
<dl class="simple">
<dt>ret<span class="classifier">ndarray</span></dt><dd><p><cite>self</cite>, 1-D, as an <cite>ndarray</cite></p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)));</span> <span class="n">x</span>
<span class="go">matrix([[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">getA1</span><span class="p">()</span>
<span class="go">array([ 0,  1,  2, ...,  9, 10, 11])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.matrix.H">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">H</span></code><a class="headerlink" href="#numpy.matrix.H" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the (complex) conjugate transpose of <cite>self</cite>.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">np.transpose(self)</span></code> if <cite>self</cite> is real-valued.</p>
<p>None</p>
<dl class="simple">
<dt>ret<span class="classifier">matrix object</span></dt><dd><p>complex conjugate transpose of <cite>self</cite></p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">x</span><span class="p">;</span> <span class="n">z</span>
<span class="go">matrix([[  0. +0.j,   1. -1.j,   2. -2.j,   3. -3.j],</span>
<span class="go">        [  4. -4.j,   5. -5.j,   6. -6.j,   7. -7.j],</span>
<span class="go">        [  8. -8.j,   9. -9.j,  10.-10.j,  11.-11.j]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">.</span><span class="n">getH</span><span class="p">()</span>
<span class="go">matrix([[ 0. -0.j,  4. +4.j,  8. +8.j],</span>
<span class="go">        [ 1. +1.j,  5. +5.j,  9. +9.j],</span>
<span class="go">        [ 2. +2.j,  6. +6.j, 10.+10.j],</span>
<span class="go">        [ 3. +3.j,  7. +7.j, 11.+11.j]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.matrix.I">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">I</span></code><a class="headerlink" href="#numpy.matrix.I" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the (multiplicative) inverse of invertible <cite>self</cite>.</p>
<p>None</p>
<dl class="simple">
<dt>ret<span class="classifier">matrix object</span></dt><dd><p>If <cite>self</cite> is non-singular, <cite>ret</cite> is such that <code class="docutils literal notranslate"><span class="pre">ret</span> <span class="pre">*</span> <span class="pre">self</span></code> ==
<code class="docutils literal notranslate"><span class="pre">self</span> <span class="pre">*</span> <span class="pre">ret</span></code> == <code class="docutils literal notranslate"><span class="pre">np.matrix(np.eye(self[0,:].size))</span></code> all return
<code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
</dd>
</dl>
<dl class="simple">
<dt>numpy.linalg.LinAlgError: Singular matrix</dt><dd><p>If <cite>self</cite> is singular.</p>
</dd>
</dl>
<p>linalg.inv</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="s1">&#39;[1, 2; 3, 4]&#39;</span><span class="p">);</span> <span class="n">m</span>
<span class="go">matrix([[1, 2],</span>
<span class="go">        [3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">getI</span><span class="p">()</span>
<span class="go">matrix([[-2. ,  1. ],</span>
<span class="go">        [ 1.5, -0.5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">getI</span><span class="p">()</span> <span class="o">*</span> <span class="n">m</span>
<span class="go">matrix([[ 1.,  0.], # may vary</span>
<span class="go">        [ 0.,  1.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.matrix.T">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">T</span></code><a class="headerlink" href="#numpy.matrix.T" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the transpose of the matrix.</p>
<p>Does <em>not</em> conjugate!  For the complex conjugate transpose, use <code class="docutils literal notranslate"><span class="pre">.H</span></code>.</p>
<p>None</p>
<dl class="simple">
<dt>ret<span class="classifier">matrix object</span></dt><dd><p>The (non-conjugated) transpose of the matrix.</p>
</dd>
</dl>
<p>transpose, getH</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="s1">&#39;[1, 2; 3, 4]&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">matrix([[1, 2],</span>
<span class="go">        [3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">getT</span><span class="p">()</span>
<span class="go">matrix([[1, 3],</span>
<span class="go">        [2, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.matrix.all">
<code class="sig-name descname"><span class="pre">all</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.all" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether all matrix elements along a given axis evaluate to True.</p>
<p>See <cite>numpy.all</cite> for complete descriptions</p>
<p>numpy.all</p>
<p>This is the same as <cite>ndarray.all</cite>, but it returns a <cite>matrix</cite> object.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)));</span> <span class="n">x</span>
<span class="go">matrix([[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">y</span>
<span class="go">matrix([[0, 1, 2, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span>
<span class="go">matrix([[ True,  True,  True,  True],</span>
<span class="go">        [False, False, False, False],</span>
<span class="go">        [False, False, False, False]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">matrix([[False, False, False, False]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">matrix([[ True],</span>
<span class="go">        [False],</span>
<span class="go">        [False]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.matrix.any">
<code class="sig-name descname"><span class="pre">any</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.any" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether any array element along a given axis evaluates to True.</p>
<p>Refer to <cite>numpy.any</cite> for full documentation.</p>
<dl class="simple">
<dt>axis<span class="classifier">int, optional</span></dt><dd><p>Axis along which logical OR is performed</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Output to existing array instead of creating new one, must have
same shape as expected output</p>
</dd>
</dl>
<blockquote>
<div><dl class="simple">
<dt>any<span class="classifier">bool, ndarray</span></dt><dd><p>Returns a single bool if <cite>axis</cite> is <code class="docutils literal notranslate"><span class="pre">None</span></code>; otherwise,
returns <cite>ndarray</cite></p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="numpy.matrix.argmax">
<code class="sig-name descname"><span class="pre">argmax</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.argmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Indexes of the maximum values along an axis.</p>
<p>Return the indexes of the first occurrences of the maximum values
along the specified axis.  If axis is None, the index is for the
flattened matrix.</p>
<p>See <cite>numpy.argmax</cite> for complete descriptions</p>
<p>numpy.argmax</p>
<p>This is the same as <cite>ndarray.argmax</cite>, but returns a <cite>matrix</cite> object
where <cite>ndarray.argmax</cite> would return an <cite>ndarray</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)));</span> <span class="n">x</span>
<span class="go">matrix([[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
<span class="go">11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">matrix([[2, 2, 2, 2]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">matrix([[3],</span>
<span class="go">        [3],</span>
<span class="go">        [3]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.matrix.argmin">
<code class="sig-name descname"><span class="pre">argmin</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.argmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Indexes of the minimum values along an axis.</p>
<p>Return the indexes of the first occurrences of the minimum values
along the specified axis.  If axis is None, the index is for the
flattened matrix.</p>
<p>See <cite>numpy.argmin</cite> for complete descriptions.</p>
<p>numpy.argmin</p>
<p>This is the same as <cite>ndarray.argmin</cite>, but returns a <cite>matrix</cite> object
where <cite>ndarray.argmin</cite> would return an <cite>ndarray</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)));</span> <span class="n">x</span>
<span class="go">matrix([[  0,  -1,  -2,  -3],</span>
<span class="go">        [ -4,  -5,  -6,  -7],</span>
<span class="go">        [ -8,  -9, -10, -11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
<span class="go">11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">matrix([[2, 2, 2, 2]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">matrix([[3],</span>
<span class="go">        [3],</span>
<span class="go">        [3]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.matrix.flatten">
<code class="sig-name descname"><span class="pre">flatten</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'C'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.flatten" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a flattened copy of the matrix.</p>
<p>All <cite>N</cite> elements of the matrix are placed into a single row.</p>
<dl class="simple">
<dt>order<span class="classifier">{‘C’, ‘F’, ‘A’, ‘K’}, optional</span></dt><dd><p>‘C’ means to flatten in row-major (C-style) order. ‘F’ means to
flatten in column-major (Fortran-style) order. ‘A’ means to
flatten in column-major order if <cite>m</cite> is Fortran <em>contiguous</em> in
memory, row-major order otherwise. ‘K’ means to flatten <cite>m</cite> in
the order the elements occur in memory. The default is ‘C’.</p>
</dd>
</dl>
<dl class="simple">
<dt>y<span class="classifier">matrix</span></dt><dd><p>A copy of the matrix, flattened to a <cite>(1, N)</cite> matrix where <cite>N</cite>
is the number of elements in the original matrix.</p>
</dd>
</dl>
<p>ravel : Return a flattened array.
flat : A 1-D flat iterator over the matrix.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
<span class="go">matrix([[1, 2, 3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
<span class="go">matrix([[1, 3, 2, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.matrix.getA">
<code class="sig-name descname"><span class="pre">getA</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.getA" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <cite>self</cite> as an <cite>ndarray</cite> object.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">np.asarray(self)</span></code>.</p>
<p>None</p>
<dl class="simple">
<dt>ret<span class="classifier">ndarray</span></dt><dd><p><cite>self</cite> as an <cite>ndarray</cite></p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)));</span> <span class="n">x</span>
<span class="go">matrix([[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">getA</span><span class="p">()</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.matrix.getA1">
<code class="sig-name descname"><span class="pre">getA1</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.getA1" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <cite>self</cite> as a flattened <cite>ndarray</cite>.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">np.asarray(x).ravel()</span></code></p>
<p>None</p>
<dl class="simple">
<dt>ret<span class="classifier">ndarray</span></dt><dd><p><cite>self</cite>, 1-D, as an <cite>ndarray</cite></p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)));</span> <span class="n">x</span>
<span class="go">matrix([[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">getA1</span><span class="p">()</span>
<span class="go">array([ 0,  1,  2, ...,  9, 10, 11])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.matrix.getH">
<code class="sig-name descname"><span class="pre">getH</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.getH" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the (complex) conjugate transpose of <cite>self</cite>.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">np.transpose(self)</span></code> if <cite>self</cite> is real-valued.</p>
<p>None</p>
<dl class="simple">
<dt>ret<span class="classifier">matrix object</span></dt><dd><p>complex conjugate transpose of <cite>self</cite></p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">x</span><span class="p">;</span> <span class="n">z</span>
<span class="go">matrix([[  0. +0.j,   1. -1.j,   2. -2.j,   3. -3.j],</span>
<span class="go">        [  4. -4.j,   5. -5.j,   6. -6.j,   7. -7.j],</span>
<span class="go">        [  8. -8.j,   9. -9.j,  10.-10.j,  11.-11.j]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">.</span><span class="n">getH</span><span class="p">()</span>
<span class="go">matrix([[ 0. -0.j,  4. +4.j,  8. +8.j],</span>
<span class="go">        [ 1. +1.j,  5. +5.j,  9. +9.j],</span>
<span class="go">        [ 2. +2.j,  6. +6.j, 10.+10.j],</span>
<span class="go">        [ 3. +3.j,  7. +7.j, 11.+11.j]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.matrix.getI">
<code class="sig-name descname"><span class="pre">getI</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.getI" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the (multiplicative) inverse of invertible <cite>self</cite>.</p>
<p>None</p>
<dl class="simple">
<dt>ret<span class="classifier">matrix object</span></dt><dd><p>If <cite>self</cite> is non-singular, <cite>ret</cite> is such that <code class="docutils literal notranslate"><span class="pre">ret</span> <span class="pre">*</span> <span class="pre">self</span></code> ==
<code class="docutils literal notranslate"><span class="pre">self</span> <span class="pre">*</span> <span class="pre">ret</span></code> == <code class="docutils literal notranslate"><span class="pre">np.matrix(np.eye(self[0,:].size))</span></code> all return
<code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
</dd>
</dl>
<dl class="simple">
<dt>numpy.linalg.LinAlgError: Singular matrix</dt><dd><p>If <cite>self</cite> is singular.</p>
</dd>
</dl>
<p>linalg.inv</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="s1">&#39;[1, 2; 3, 4]&#39;</span><span class="p">);</span> <span class="n">m</span>
<span class="go">matrix([[1, 2],</span>
<span class="go">        [3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">getI</span><span class="p">()</span>
<span class="go">matrix([[-2. ,  1. ],</span>
<span class="go">        [ 1.5, -0.5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">getI</span><span class="p">()</span> <span class="o">*</span> <span class="n">m</span>
<span class="go">matrix([[ 1.,  0.], # may vary</span>
<span class="go">        [ 0.,  1.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.matrix.getT">
<code class="sig-name descname"><span class="pre">getT</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.getT" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the transpose of the matrix.</p>
<p>Does <em>not</em> conjugate!  For the complex conjugate transpose, use <code class="docutils literal notranslate"><span class="pre">.H</span></code>.</p>
<p>None</p>
<dl class="simple">
<dt>ret<span class="classifier">matrix object</span></dt><dd><p>The (non-conjugated) transpose of the matrix.</p>
</dd>
</dl>
<p>transpose, getH</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="s1">&#39;[1, 2; 3, 4]&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">matrix([[1, 2],</span>
<span class="go">        [3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">getT</span><span class="p">()</span>
<span class="go">matrix([[1, 3],</span>
<span class="go">        [2, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.matrix.max">
<code class="sig-name descname"><span class="pre">max</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum value along an axis.</p>
<p>See <cite>amax</cite> for complete descriptions</p>
<p>amax, ndarray.max</p>
<p>This is the same as <cite>ndarray.max</cite>, but returns a <cite>matrix</cite> object
where <cite>ndarray.max</cite> would return an ndarray.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)));</span> <span class="n">x</span>
<span class="go">matrix([[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="go">11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">matrix([[ 8,  9, 10, 11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">matrix([[ 3],</span>
<span class="go">        [ 7],</span>
<span class="go">        [11]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.matrix.mean">
<code class="sig-name descname"><span class="pre">mean</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the average of the matrix elements along the given axis.</p>
<p>Refer to <cite>numpy.mean</cite> for full documentation.</p>
<p>numpy.mean</p>
<p>Same as <cite>ndarray.mean</cite> except that, where that returns an <cite>ndarray</cite>,
this returns a <cite>matrix</cite> object.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">matrix([[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="go">5.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">matrix([[4., 5., 6., 7.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">matrix([[ 1.5],</span>
<span class="go">        [ 5.5],</span>
<span class="go">        [ 9.5]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.matrix.min">
<code class="sig-name descname"><span class="pre">min</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the minimum value along an axis.</p>
<p>See <cite>amin</cite> for complete descriptions.</p>
<p>amin, ndarray.min</p>
<p>This is the same as <cite>ndarray.min</cite>, but returns a <cite>matrix</cite> object
where <cite>ndarray.min</cite> would return an ndarray.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)));</span> <span class="n">x</span>
<span class="go">matrix([[  0,  -1,  -2,  -3],</span>
<span class="go">        [ -4,  -5,  -6,  -7],</span>
<span class="go">        [ -8,  -9, -10, -11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
<span class="go">-11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">matrix([[ -8,  -9, -10, -11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">matrix([[ -3],</span>
<span class="go">        [ -7],</span>
<span class="go">        [-11]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.matrix.prod">
<code class="sig-name descname"><span class="pre">prod</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.prod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the product of the array elements over the given axis.</p>
<p>Refer to <cite>prod</cite> for full documentation.</p>
<p>prod, ndarray.prod</p>
<p>Same as <cite>ndarray.prod</cite>, except, where that returns an <cite>ndarray</cite>, this
returns a <cite>matrix</cite> object instead.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)));</span> <span class="n">x</span>
<span class="go">matrix([[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">matrix([[  0,  45, 120, 231]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">matrix([[   0],</span>
<span class="go">        [ 840],</span>
<span class="go">        [7920]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.matrix.ptp">
<code class="sig-name descname"><span class="pre">ptp</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.ptp" title="Permalink to this definition">¶</a></dt>
<dd><p>Peak-to-peak (maximum - minimum) value along the given axis.</p>
<p>Refer to <cite>numpy.ptp</cite> for full documentation.</p>
<p>numpy.ptp</p>
<p>Same as <cite>ndarray.ptp</cite>, except, where that would return an <cite>ndarray</cite> object,
this returns a <cite>matrix</cite> object.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)));</span> <span class="n">x</span>
<span class="go">matrix([[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">ptp</span><span class="p">()</span>
<span class="go">11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">matrix([[8, 8, 8, 8]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">matrix([[3],</span>
<span class="go">        [3],</span>
<span class="go">        [3]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.matrix.ravel">
<code class="sig-name descname"><span class="pre">ravel</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'C'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.ravel" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a flattened matrix.</p>
<p>Refer to <cite>numpy.ravel</cite> for more documentation.</p>
<dl class="simple">
<dt>order<span class="classifier">{‘C’, ‘F’, ‘A’, ‘K’}, optional</span></dt><dd><p>The elements of <cite>m</cite> are read using this index order. ‘C’ means to
index the elements in C-like order, with the last axis index
changing fastest, back to the first axis index changing slowest.
‘F’ means to index the elements in Fortran-like index order, with
the first index changing fastest, and the last index changing
slowest. Note that the ‘C’ and ‘F’ options take no account of the
memory layout of the underlying array, and only refer to the order
of axis indexing.  ‘A’ means to read the elements in Fortran-like
index order if <cite>m</cite> is Fortran <em>contiguous</em> in memory, C-like order
otherwise.  ‘K’ means to read the elements in the order they occur
in memory, except for reversing the data when strides are negative.
By default, ‘C’ index order is used.</p>
</dd>
</dl>
<dl class="simple">
<dt>ret<span class="classifier">matrix</span></dt><dd><p>Return the matrix flattened to shape <cite>(1, N)</cite> where <cite>N</cite>
is the number of elements in the original matrix.
A copy is made only if necessary.</p>
</dd>
</dl>
<p>matrix.flatten : returns a similar output matrix but always a copy
matrix.flat : a flat iterator on the array.
numpy.ravel : related function which returns an ndarray</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.matrix.squeeze">
<code class="sig-name descname"><span class="pre">squeeze</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a possibly reshaped matrix.</p>
<p>Refer to <cite>numpy.squeeze</cite> for more documentation.</p>
<dl class="simple">
<dt>axis<span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Selects a subset of the axes of length one in the shape.
If an axis is selected with shape entry greater than one,
an error is raised.</p>
</dd>
</dl>
<dl class="simple">
<dt>squeezed<span class="classifier">matrix</span></dt><dd><p>The matrix, but as a (1, N) matrix if it had shape (N, 1).</p>
</dd>
</dl>
<p>numpy.squeeze : related function</p>
<p>If <cite>m</cite> has a single column then that column is returned
as the single row of a matrix.  Otherwise <cite>m</cite> is returned.
The returned matrix is always either <cite>m</cite> itself or a view into <cite>m</cite>.
Supplying an axis keyword argument will not affect the returned matrix
but it may cause an error to be raised.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">matrix([[1],</span>
<span class="go">        [2]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
<span class="go">matrix([[1, 2]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span>
<span class="go">matrix([[1, 2]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
<span class="go">matrix([[1, 2]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
<span class="go">matrix([[1, 2],</span>
<span class="go">        [3, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.matrix.std">
<code class="sig-name descname"><span class="pre">std</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ddof</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.std" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the standard deviation of the array elements along the given axis.</p>
<p>Refer to <cite>numpy.std</cite> for full documentation.</p>
<p>numpy.std</p>
<p>This is the same as <cite>ndarray.std</cite>, except that where an <cite>ndarray</cite> would
be returned, a <cite>matrix</cite> object is returned instead.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">matrix([[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
<span class="go">3.4520525295346629 # may vary</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">matrix([[ 3.26598632,  3.26598632,  3.26598632,  3.26598632]]) # may vary</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">matrix([[ 1.11803399],</span>
<span class="go">        [ 1.11803399],</span>
<span class="go">        [ 1.11803399]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.matrix.sum">
<code class="sig-name descname"><span class="pre">sum</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the sum of the matrix elements, along the given axis.</p>
<p>Refer to <cite>numpy.sum</cite> for full documentation.</p>
<p>numpy.sum</p>
<p>This is the same as <cite>ndarray.sum</cite>, except that where an <cite>ndarray</cite> would
be returned, a <cite>matrix</cite> object is returned instead.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">matrix([[3],</span>
<span class="go">        [7]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
<span class="go">matrix([[3.],</span>
<span class="go">        [7.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asmatrix</span><span class="p">(</span><span class="n">out</span><span class="p">))</span>
<span class="go">matrix([[3.],</span>
<span class="go">        [7.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.matrix.tolist">
<code class="sig-name descname"><span class="pre">tolist</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.tolist" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix as a (possibly nested) list.</p>
<p>See <cite>ndarray.tolist</cite> for full documentation.</p>
<p>ndarray.tolist</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)));</span> <span class="n">x</span>
<span class="go">matrix([[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.matrix.var">
<code class="sig-name descname"><span class="pre">var</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ddof</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.var" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the variance of the matrix elements, along the given axis.</p>
<p>Refer to <cite>numpy.var</cite> for full documentation.</p>
<p>numpy.var</p>
<p>This is the same as <cite>ndarray.var</cite>, except that where an <cite>ndarray</cite> would
be returned, a <cite>matrix</cite> object is returned instead.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">matrix([[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">var</span><span class="p">()</span>
<span class="go">11.916666666666666</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">matrix([[ 10.66666667,  10.66666667,  10.66666667,  10.66666667]]) # may vary</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">matrix([[1.25],</span>
<span class="go">        [1.25],</span>
<span class="go">        [1.25]])</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="numpy.maximum_sctype">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">maximum_sctype</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.maximum_sctype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the scalar type of highest precision of the same kind as the input.</p>
<dl class="simple">
<dt>t<span class="classifier">dtype or dtype specifier</span></dt><dd><p>The input data type. This can be a <cite>dtype</cite> object or an object that
is convertible to a <cite>dtype</cite>.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">dtype</span></dt><dd><p>The highest precision data type of the same kind (<cite>dtype.kind</cite>) as <cite>t</cite>.</p>
</dd>
</dl>
<p>obj2sctype, mintypecode, sctype2char
dtype</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">maximum_sctype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">&lt;class &#39;numpy.int64&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">maximum_sctype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="go">&lt;class &#39;numpy.uint64&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">maximum_sctype</span><span class="p">(</span><span class="nb">complex</span><span class="p">)</span>
<span class="go">&lt;class &#39;numpy.complex256&#39;&gt; # may vary</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">maximum_sctype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
<span class="go">&lt;class &#39;numpy.str_&#39;&gt;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">maximum_sctype</span><span class="p">(</span><span class="s1">&#39;i2&#39;</span><span class="p">)</span>
<span class="go">&lt;class &#39;numpy.int64&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">maximum_sctype</span><span class="p">(</span><span class="s1">&#39;f4&#39;</span><span class="p">)</span>
<span class="go">&lt;class &#39;numpy.float128&#39;&gt; # may vary</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.may_share_memory">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">may_share_memory</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_work</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.may_share_memory" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if two arrays might share memory</p>
<p>A return of True does not necessarily mean that the two arrays
share any element.  It just means that they <em>might</em>.</p>
<p>Only the memory bounds of a and b are checked by default.</p>
<dl class="simple">
<dt>a, b<span class="classifier">ndarray</span></dt><dd><p>Input arrays</p>
</dd>
<dt>max_work<span class="classifier">int, optional</span></dt><dd><p>Effort to spend on solving the overlap problem.  See
<cite>shares_memory</cite> for details.  Default for <code class="docutils literal notranslate"><span class="pre">may_share_memory</span></code>
is to do a bounds check.</p>
</dd>
</dl>
<p>out : bool</p>
<p>shares_memory</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">may_share_memory</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]))</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">may_share_memory</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.mean">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">mean</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">a</span></em>, <em class="sig-param"><span class="pre">axis=None</span></em>, <em class="sig-param"><span class="pre">dtype=None</span></em>, <em class="sig-param"><span class="pre">out=None</span></em>, <em class="sig-param"><span class="pre">keepdims=&lt;no</span> <span class="pre">value&gt;</span></em>, <em class="sig-param"><span class="pre">*</span></em>, <em class="sig-param"><span class="pre">where=&lt;no</span> <span class="pre">value&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the arithmetic mean along the specified axis.</p>
<p>Returns the average of the array elements.  The average is taken over
the flattened array by default, otherwise over the specified axis.
<cite>float64</cite> intermediate and return values are used for integer inputs.</p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Array containing numbers whose mean is desired. If <cite>a</cite> is not an
array, a conversion is attempted.</p>
</dd>
<dt>axis<span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Axis or axes along which the means are computed. The default is to
compute the mean of the flattened array.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<p>If this is a tuple of ints, a mean is performed over multiple axes,
instead of a single axis or all the axes as before.</p>
</dd>
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>Type to use in computing the mean.  For integer inputs, the default
is <cite>float64</cite>; for floating point inputs, it is the same as the
input dtype.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Alternate output array in which to place the result.  The default
is <code class="docutils literal notranslate"><span class="pre">None</span></code>; if provided, it must have the same shape as the
expected output, but the type will be cast if necessary.
See <span class="xref std std-ref">ufuncs-output-type</span> for more details.</p>
</dd>
<dt>keepdims<span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p>If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>mean</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
<dt>where<span class="classifier">array_like of bool, optional</span></dt><dd><p>Elements to include in the mean. See <cite>~numpy.ufunc.reduce</cite> for details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.20.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>m<span class="classifier">ndarray, see dtype parameter above</span></dt><dd><p>If <cite>out=None</cite>, returns a new array containing the mean values,
otherwise a reference to the output array is returned.</p>
</dd>
</dl>
<p>average : Weighted average
std, var, nanmean, nanstd, nanvar</p>
<p>The arithmetic mean is the sum of the elements along the axis divided
by the number of elements.</p>
<p>Note that for floating-point input, the mean is computed using the
same precision the input has.  Depending on the input data, this can
cause the results to be inaccurate, especially for <cite>float32</cite> (see
example below).  Specifying a higher-precision accumulator using the
<cite>dtype</cite> keyword can alleviate this issue.</p>
<p>By default, <cite>float16</cite> results are computed using <cite>float32</cite> intermediates
for extra precision.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">2.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([2., 3.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([1.5, 3.5])</span>
</pre></div>
</div>
<p>In single precision, <cite>mean</cite> can be inaccurate:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">512</span><span class="o">*</span><span class="mi">512</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">0.54999924</span>
</pre></div>
</div>
<p>Computing the mean in float64 is more accurate:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="go">0.55000000074505806 # may vary</span>
</pre></div>
</div>
<p>Specifying a where argument:
&gt;&gt;&gt; a = np.array([[5, 9, 13], [14, 10, 12], [11, 15, 19]])
&gt;&gt;&gt; np.mean(a)
12.0
&gt;&gt;&gt; np.mean(a, where=[[True], [False], [False]])
9.0</p>
</dd></dl>

<dl class="py function">
<dt id="numpy.median">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">median</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite_input</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keepdims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.median" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the median along the specified axis.</p>
<p>Returns the median of the array elements.</p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input array or object that can be converted to an array.</p>
</dd>
<dt>axis<span class="classifier">{int, sequence of int, None}, optional</span></dt><dd><p>Axis or axes along which the medians are computed. The default
is to compute the median along a flattened version of the array.
A sequence of axes is supported since version 1.9.0.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output,
but the type (of the output) will be cast if necessary.</p>
</dd>
<dt>overwrite_input<span class="classifier">bool, optional</span></dt><dd><p>If True, then allow use of memory of input array <cite>a</cite> for
calculations. The input array will be modified by the call to
<cite>median</cite>. This will save memory when you do not need to preserve
the contents of the input array. Treat the input as undefined,
but it will probably be fully or partially sorted. Default is
False. If <cite>overwrite_input</cite> is <code class="docutils literal notranslate"><span class="pre">True</span></code> and <cite>a</cite> is not already an
<cite>ndarray</cite>, an error will be raised.</p>
</dd>
<dt>keepdims<span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original <cite>arr</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.9.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>median<span class="classifier">ndarray</span></dt><dd><p>A new array holding the result. If the input contains integers
or floats smaller than <code class="docutils literal notranslate"><span class="pre">float64</span></code>, then the output data-type is
<code class="docutils literal notranslate"><span class="pre">np.float64</span></code>.  Otherwise, the data-type of the output is the
same as that of the input. If <cite>out</cite> is specified, that array is
returned instead.</p>
</dd>
</dl>
<p>mean, percentile</p>
<p>Given a vector <code class="docutils literal notranslate"><span class="pre">V</span></code> of length <code class="docutils literal notranslate"><span class="pre">N</span></code>, the median of <code class="docutils literal notranslate"><span class="pre">V</span></code> is the
middle value of a sorted copy of <code class="docutils literal notranslate"><span class="pre">V</span></code>, <code class="docutils literal notranslate"><span class="pre">V_sorted</span></code> - i
e., <code class="docutils literal notranslate"><span class="pre">V_sorted[(N-1)/2]</span></code>, when <code class="docutils literal notranslate"><span class="pre">N</span></code> is odd, and the average of the
two middle values of <code class="docutils literal notranslate"><span class="pre">V_sorted</span></code> when <code class="docutils literal notranslate"><span class="pre">N</span></code> is even.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[10,  7,  4],</span>
<span class="go">       [ 3,  2,  1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">3.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([6.5, 4.5, 2.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([7.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="go">array([6.5,  4.5,  2.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">array([6.5,  4.5,  2.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([7.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">3.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt id="numpy.memmap">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">memmap</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">filename</span></em>, <em class="sig-param"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.uint8'&gt;</span></em>, <em class="sig-param"><span class="pre">mode='r+'</span></em>, <em class="sig-param"><span class="pre">offset=0</span></em>, <em class="sig-param"><span class="pre">shape=None</span></em>, <em class="sig-param"><span class="pre">order='C'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.memmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a memory-map to an array stored in a <em>binary</em> file on disk.</p>
<p>Memory-mapped files are used for accessing small segments of large files
on disk, without reading the entire file into memory.  NumPy’s
memmap’s are array-like objects.  This differs from Python’s <code class="docutils literal notranslate"><span class="pre">mmap</span></code>
module, which uses file-like objects.</p>
<p>This subclass of ndarray has some unpleasant interactions with
some operations, because it doesn’t quite fit properly as a subclass.
An alternative to using this subclass is to create the <code class="docutils literal notranslate"><span class="pre">mmap</span></code>
object yourself, then create an ndarray with ndarray.__new__ directly,
passing the object created in its ‘buffer=’ parameter.</p>
<p>This class may at some point be turned into a factory function
which returns a view into an mmap buffer.</p>
<p>Flush the memmap instance to write the changes to the file. Currently there
is no API to close the underlying <code class="docutils literal notranslate"><span class="pre">mmap</span></code>. It is tricky to ensure the
resource is actually closed, since it may be shared between different
memmap instances.</p>
<dl>
<dt>filename<span class="classifier">str, file-like object, or pathlib.Path instance</span></dt><dd><p>The file name or file object to be used as the array data buffer.</p>
</dd>
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>The data-type used to interpret the file contents.
Default is <cite>uint8</cite>.</p>
</dd>
<dt>mode<span class="classifier">{‘r+’, ‘r’, ‘w+’, ‘c’}, optional</span></dt><dd><p>The file is opened in this mode:</p>
<table class="table">
<colgroup>
<col style="width: 9%" />
<col style="width: 91%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>‘r’</p></td>
<td><p>Open existing file for reading only.</p></td>
</tr>
<tr class="row-even"><td><p>‘r+’</p></td>
<td><p>Open existing file for reading and writing.</p></td>
</tr>
<tr class="row-odd"><td><p>‘w+’</p></td>
<td><p>Create or overwrite existing file for reading and writing.</p></td>
</tr>
<tr class="row-even"><td><p>‘c’</p></td>
<td><p>Copy-on-write: assignments affect data in memory, but
changes are not saved to disk.  The file on disk is
read-only.</p></td>
</tr>
</tbody>
</table>
<p>Default is ‘r+’.</p>
</dd>
<dt>offset<span class="classifier">int, optional</span></dt><dd><p>In the file, array data starts at this offset. Since <cite>offset</cite> is
measured in bytes, it should normally be a multiple of the byte-size
of <cite>dtype</cite>. When <code class="docutils literal notranslate"><span class="pre">mode</span> <span class="pre">!=</span> <span class="pre">'r'</span></code>, even positive offsets beyond end of
file are valid; The file will be extended to accommodate the
additional data. By default, <code class="docutils literal notranslate"><span class="pre">memmap</span></code> will start at the beginning of
the file, even if <code class="docutils literal notranslate"><span class="pre">filename</span></code> is a file pointer <code class="docutils literal notranslate"><span class="pre">fp</span></code> and
<code class="docutils literal notranslate"><span class="pre">fp.tell()</span> <span class="pre">!=</span> <span class="pre">0</span></code>.</p>
</dd>
<dt>shape<span class="classifier">tuple, optional</span></dt><dd><p>The desired shape of the array. If <code class="docutils literal notranslate"><span class="pre">mode</span> <span class="pre">==</span> <span class="pre">'r'</span></code> and the number
of remaining bytes after <cite>offset</cite> is not a multiple of the byte-size
of <cite>dtype</cite>, you must specify <cite>shape</cite>. By default, the returned array
will be 1-D with the number of elements determined by file size
and data-type.</p>
</dd>
<dt>order<span class="classifier">{‘C’, ‘F’}, optional</span></dt><dd><p>Specify the order of the ndarray memory layout:
<span class="xref std std-term">row-major</span>, C-style or <span class="xref std std-term">column-major</span>,
Fortran-style.  This only has an effect if the shape is
greater than 1-D.  The default order is ‘C’.</p>
</dd>
</dl>
<dl class="simple">
<dt>filename<span class="classifier">str or pathlib.Path instance</span></dt><dd><p>Path to the mapped file.</p>
</dd>
<dt>offset<span class="classifier">int</span></dt><dd><p>Offset position in the file.</p>
</dd>
<dt>mode<span class="classifier">str</span></dt><dd><p>File mode.</p>
</dd>
</dl>
<dl class="simple">
<dt>flush</dt><dd><p>Flush any changes in memory to file on disk.
When you delete a memmap object, flush is called first to write
changes to disk.</p>
</dd>
</dl>
<p>lib.format.open_memmap : Create or load a memory-mapped <code class="docutils literal notranslate"><span class="pre">.npy</span></code> file.</p>
<p>The memmap object can be used anywhere an ndarray is accepted.
Given a memmap <code class="docutils literal notranslate"><span class="pre">fp</span></code>, <code class="docutils literal notranslate"><span class="pre">isinstance(fp,</span> <span class="pre">numpy.ndarray)</span></code> returns
<code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<p>Memory-mapped files cannot be larger than 2GB on 32-bit systems.</p>
<p>When a memmap causes a file to be created or extended beyond its
current size in the filesystem, the contents of the new part are
unspecified. On systems with POSIX filesystem semantics, the extended
part will be filled with zero bytes.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">resize</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
<p>This example uses a temporary file so that doctest doesn’t write
files to your directory. You would use a ‘normal’ filename.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">tempfile</span> <span class="kn">import</span> <span class="n">mkdtemp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os.path</span> <span class="k">as</span> <span class="nn">path</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filename</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">mkdtemp</span><span class="p">(),</span> <span class="s1">&#39;newfile.dat&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Create a memmap with dtype and shape that matches our data:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w+&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span>
<span class="go">memmap([[0., 0., 0., 0.],</span>
<span class="go">        [0., 0., 0., 0.],</span>
<span class="go">        [0., 0., 0., 0.]], dtype=float32)</span>
</pre></div>
</div>
<p>Write data to memmap array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span>
<span class="go">memmap([[  0.,   1.,   2.,   3.],</span>
<span class="go">        [  4.,   5.,   6.,   7.],</span>
<span class="go">        [  8.,   9.,  10.,  11.]], dtype=float32)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span><span class="o">.</span><span class="n">filename</span> <span class="o">==</span> <span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Flushes memory changes to disk in order to read them back</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
</pre></div>
</div>
<p>Load the memmap and verify data was stored:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">newfp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">newfp</span>
<span class="go">memmap([[  0.,   1.,   2.,   3.],</span>
<span class="go">        [  4.,   5.,   6.,   7.],</span>
<span class="go">        [  8.,   9.,  10.,  11.]], dtype=float32)</span>
</pre></div>
</div>
<p>Read-only memmap:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fpr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fpr</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Copy-on-write memmap:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fpc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fpc</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span>
<span class="go">True</span>
</pre></div>
</div>
<p>It’s possible to assign to copy-on-write array, but values are only
written into the memory copy of the array, and not written to disk:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fpc</span>
<span class="go">memmap([[  0.,   1.,   2.,   3.],</span>
<span class="go">        [  4.,   5.,   6.,   7.],</span>
<span class="go">        [  8.,   9.,  10.,  11.]], dtype=float32)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fpc</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fpc</span>
<span class="go">memmap([[  0.,   0.,   0.,   0.],</span>
<span class="go">        [  4.,   5.,   6.,   7.],</span>
<span class="go">        [  8.,   9.,  10.,  11.]], dtype=float32)</span>
</pre></div>
</div>
<p>File on disk is unchanged:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fpr</span>
<span class="go">memmap([[  0.,   1.,   2.,   3.],</span>
<span class="go">        [  4.,   5.,   6.,   7.],</span>
<span class="go">        [  8.,   9.,  10.,  11.]], dtype=float32)</span>
</pre></div>
</div>
<p>Offset into a memmap:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fpo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fpo</span>
<span class="go">memmap([  4.,   5.,   6.,   7.,   8.,   9.,  10.,  11.], dtype=float32)</span>
</pre></div>
</div>
<dl class="py method">
<dt id="numpy.memmap.flush">
<code class="sig-name descname"><span class="pre">flush</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.memmap.flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Write any changes in the array to the file on disk.</p>
<p>For further information, see <cite>memmap</cite>.</p>
<p>None</p>
<p>memmap</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="numpy.meshgrid">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">meshgrid</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">xi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indexing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'xy'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.meshgrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Return coordinate matrices from coordinate vectors.</p>
<p>Make N-D coordinate arrays for vectorized evaluations of
N-D scalar/vector fields over N-D grids, given
one-dimensional coordinate arrays x1, x2,…, xn.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.9: </span>1-D and 0-D cases are allowed.</p>
</div>
<dl>
<dt>x1, x2,…, xn<span class="classifier">array_like</span></dt><dd><p>1-D arrays representing the coordinates of a grid.</p>
</dd>
<dt>indexing<span class="classifier">{‘xy’, ‘ij’}, optional</span></dt><dd><p>Cartesian (‘xy’, default) or matrix (‘ij’) indexing of output.
See Notes for more details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
</dd>
<dt>sparse<span class="classifier">bool, optional</span></dt><dd><p>If True a sparse grid is returned in order to conserve memory.
Default is False.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
</dd>
<dt>copy<span class="classifier">bool, optional</span></dt><dd><p>If False, a view into the original arrays are returned in order to
conserve memory.  Default is True.  Please note that
<code class="docutils literal notranslate"><span class="pre">sparse=False,</span> <span class="pre">copy=False</span></code> will likely return non-contiguous
arrays.  Furthermore, more than one element of a broadcast array
may refer to a single memory location.  If you need to write to the
arrays, make copies first.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>X1, X2,…, XN<span class="classifier">ndarray</span></dt><dd><p>For vectors <cite>x1</cite>, <cite>x2</cite>,…, ‘xn’ with lengths <code class="docutils literal notranslate"><span class="pre">Ni=len(xi)</span></code> ,
return <code class="docutils literal notranslate"><span class="pre">(N1,</span> <span class="pre">N2,</span> <span class="pre">N3,...Nn)</span></code> shaped arrays if indexing=’ij’
or <code class="docutils literal notranslate"><span class="pre">(N2,</span> <span class="pre">N1,</span> <span class="pre">N3,...Nn)</span></code> shaped arrays if indexing=’xy’
with the elements of <cite>xi</cite> repeated to fill the matrix along
the first dimension for <cite>x1</cite>, the second for <cite>x2</cite> and so on.</p>
</dd>
</dl>
<p>This function supports both indexing conventions through the indexing
keyword argument.  Giving the string ‘ij’ returns a meshgrid with
matrix indexing, while ‘xy’ returns a meshgrid with Cartesian indexing.
In the 2-D case with inputs of length M and N, the outputs are of shape
(N, M) for ‘xy’ indexing and (M, N) for ‘ij’ indexing.  In the 3-D case
with inputs of length M, N and P, outputs are of shape (N, M, P) for
‘xy’ indexing and (M, N, P) for ‘ij’ indexing.  The difference is
illustrated by the following code snippet:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span>
        <span class="c1"># treat xv[i,j], yv[i,j]</span>

<span class="n">xv</span><span class="p">,</span> <span class="n">yv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span>
        <span class="c1"># treat xv[j,i], yv[j,i]</span>
</pre></div>
</div>
<p>In the 1-D and 0-D case, the indexing and sparse keywords have no effect.</p>
<p>mgrid : Construct a multi-dimensional “meshgrid” using indexing notation.
ogrid : Construct an open multi-dimensional “meshgrid” using indexing</p>
<blockquote>
<div><p>notation.</p>
</div></blockquote>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nx</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span>
<span class="go">array([[0. , 0.5, 1. ],</span>
<span class="go">       [0. , 0.5, 1. ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yv</span>
<span class="go">array([[0.,  0.,  0.],</span>
<span class="go">       [1.,  1.,  1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># make sparse output arrays</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span>
<span class="go">array([[0. ,  0.5,  1. ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yv</span>
<span class="go">array([[0.],</span>
<span class="go">       [1.]])</span>
</pre></div>
</div>
<p><cite>meshgrid</cite> is very useful to evaluate functions on a grid.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">xx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">yy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">xx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">yy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.min_scalar_type">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">min_scalar_type</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.min_scalar_type" title="Permalink to this definition">¶</a></dt>
<dd><p>For scalar <code class="docutils literal notranslate"><span class="pre">a</span></code>, returns the data type with the smallest size
and smallest scalar kind which can hold its value.  For non-scalar
array <code class="docutils literal notranslate"><span class="pre">a</span></code>, returns the vector’s dtype unmodified.</p>
<p>Floating point values are not demoted to integers,
and complex values are not demoted to floats.</p>
<dl class="simple">
<dt>a<span class="classifier">scalar or array_like</span></dt><dd><p>The value whose minimal data type is to be found.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">dtype</span></dt><dd><p>The minimal data type.</p>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.6.0.</span></p>
</div>
<p>result_type, promote_types, dtype, can_cast</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">min_scalar_type</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">dtype(&#39;uint8&#39;)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">min_scalar_type</span><span class="p">(</span><span class="o">-</span><span class="mi">260</span><span class="p">)</span>
<span class="go">dtype(&#39;int16&#39;)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">min_scalar_type</span><span class="p">(</span><span class="mf">3.1</span><span class="p">)</span>
<span class="go">dtype(&#39;float16&#39;)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">min_scalar_type</span><span class="p">(</span><span class="mf">1e50</span><span class="p">)</span>
<span class="go">dtype(&#39;float64&#39;)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">min_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;f8&#39;</span><span class="p">))</span>
<span class="go">dtype(&#39;float64&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.mintypecode">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">mintypecode</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">typechars</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">typeset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'GDFgdf'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'d'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.mintypecode" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the character for the minimum-size type to which given types can
be safely cast.</p>
<p>The returned type character must represent the smallest size dtype such
that an array of the returned type can handle the data from an array of
all types in <cite>typechars</cite> (or if <cite>typechars</cite> is an array, then its
dtype.char).</p>
<dl class="simple">
<dt>typechars<span class="classifier">list of str or array_like</span></dt><dd><p>If a list of strings, each string should represent a dtype.
If array_like, the character representation of the array dtype is used.</p>
</dd>
<dt>typeset<span class="classifier">str or list of str, optional</span></dt><dd><p>The set of characters that the returned character is chosen from.
The default set is ‘GDFgdf’.</p>
</dd>
<dt>default<span class="classifier">str, optional</span></dt><dd><p>The default character, this is returned if none of the characters in
<cite>typechars</cite> matches a character in <cite>typeset</cite>.</p>
</dd>
</dl>
<dl class="simple">
<dt>typechar<span class="classifier">str</span></dt><dd><p>The character representing the minimum-size type that was found.</p>
</dd>
</dl>
<p>dtype, sctype2char, maximum_sctype</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mintypecode</span><span class="p">([</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;S&#39;</span><span class="p">])</span>
<span class="go">&#39;d&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.1</span><span class="p">,</span> <span class="mi">2</span><span class="o">-</span><span class="mf">3.</span><span class="n">j</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mintypecode</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">&#39;D&#39;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mintypecode</span><span class="p">(</span><span class="s1">&#39;abceh&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;G&#39;</span><span class="p">)</span>
<span class="go">&#39;G&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.moveaxis">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">moveaxis</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">destination</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.moveaxis" title="Permalink to this definition">¶</a></dt>
<dd><p>Move axes of an array to new positions.</p>
<p>Other axes remain in their original order.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.11.0.</span></p>
</div>
<dl class="simple">
<dt>a<span class="classifier">np.ndarray</span></dt><dd><p>The array whose axes should be reordered.</p>
</dd>
<dt>source<span class="classifier">int or sequence of int</span></dt><dd><p>Original positions of the axes to move. These must be unique.</p>
</dd>
<dt>destination<span class="classifier">int or sequence of int</span></dt><dd><p>Destination positions for each of the original axes. These must also be
unique.</p>
</dd>
</dl>
<dl class="simple">
<dt>result<span class="classifier">np.ndarray</span></dt><dd><p>Array with moved axes. This array is a view of the input array.</p>
</dd>
</dl>
<p>transpose : Permute the dimensions of an array.
swapaxes : Interchange two axes of an array.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(4, 5, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 3, 4)</span>
</pre></div>
</div>
<p>These all achieve the same result:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 4, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 4, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 4, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 4, 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.msort">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">msort</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.msort" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of an array sorted along the first axis.</p>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>Array to be sorted.</p>
</dd>
</dl>
<dl class="simple">
<dt>sorted_array<span class="classifier">ndarray</span></dt><dd><p>Array of the same type and shape as <cite>a</cite>.</p>
</dd>
</dl>
<p>sort</p>
<p><code class="docutils literal notranslate"><span class="pre">np.msort(a)</span></code> is equivalent to  <code class="docutils literal notranslate"><span class="pre">np.sort(a,</span> <span class="pre">axis=0)</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt id="numpy.nan_to_num">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">nan_to_num</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nan</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">posinf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neginf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nan_to_num" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace NaN with zero and infinity with large finite numbers (default
behaviour) or with the numbers defined by the user using the <cite>nan</cite>, 
<cite>posinf</cite> and/or <cite>neginf</cite> keywords.</p>
<p>If <cite>x</cite> is inexact, NaN is replaced by zero or by the user defined value in
<cite>nan</cite> keyword, infinity is replaced by the largest finite floating point 
values representable by <code class="docutils literal notranslate"><span class="pre">x.dtype</span></code> or by the user defined value in 
<cite>posinf</cite> keyword and -infinity is replaced by the most negative finite 
floating point values representable by <code class="docutils literal notranslate"><span class="pre">x.dtype</span></code> or by the user defined 
value in <cite>neginf</cite> keyword.</p>
<p>For complex dtypes, the above is applied to each of the real and
imaginary components of <cite>x</cite> separately.</p>
<p>If <cite>x</cite> is not inexact, then no replacements are made.</p>
<dl>
<dt>x<span class="classifier">scalar or array_like</span></dt><dd><p>Input data.</p>
</dd>
<dt>copy<span class="classifier">bool, optional</span></dt><dd><p>Whether to create a copy of <cite>x</cite> (True) or to replace values
in-place (False). The in-place operation only occurs if
casting to an array does not require a copy.
Default is True.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.13.</span></p>
</div>
</dd>
<dt>nan<span class="classifier">int, float, optional</span></dt><dd><p>Value to be used to fill NaN values. If no value is passed 
then NaN values will be replaced with 0.0.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.17.</span></p>
</div>
</dd>
<dt>posinf<span class="classifier">int, float, optional</span></dt><dd><p>Value to be used to fill positive infinity values. If no value is 
passed then positive infinity values will be replaced with a very
large number.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.17.</span></p>
</div>
</dd>
<dt>neginf<span class="classifier">int, float, optional</span></dt><dd><p>Value to be used to fill negative infinity values. If no value is 
passed then negative infinity values will be replaced with a very
small (or negative) number.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.17.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p><cite>x</cite>, with the non-finite values replaced. If <cite>copy</cite> is False, this may
be <cite>x</cite> itself.</p>
</dd>
</dl>
<p>isinf : Shows which elements are positive or negative infinity.
isneginf : Shows which elements are negative infinity.
isposinf : Shows which elements are positive infinity.
isnan : Shows which elements are Not a Number (NaN).
isfinite : Shows which elements are finite (not NaN, not infinity)</p>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="go">1.7976931348623157e+308</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="go">-1.7976931348623157e+308</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="o">-</span><span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([ 1.79769313e+308, -1.79769313e+308,  0.00000000e+000, # may vary</span>
<span class="go">       -1.28000000e+002,  1.28000000e+002])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">nan</span><span class="o">=-</span><span class="mi">9999</span><span class="p">,</span> <span class="n">posinf</span><span class="o">=</span><span class="mi">33333333</span><span class="p">,</span> <span class="n">neginf</span><span class="o">=</span><span class="mi">33333333</span><span class="p">)</span>
<span class="go">array([ 3.3333333e+07,  3.3333333e+07, -9.9990000e+03, </span>
<span class="go">       -1.2800000e+02,  1.2800000e+02])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">complex</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">complex</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)])</span>
<span class="go">array([  1.79769313e+308,  -1.79769313e+308,   0.00000000e+000, # may vary</span>
<span class="go">     -1.28000000e+002,   1.28000000e+002])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">array([  1.79769313e+308 +0.00000000e+000j, # may vary</span>
<span class="go">         0.00000000e+000 +0.00000000e+000j,</span>
<span class="go">         0.00000000e+000 +1.79769313e+308j])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">nan</span><span class="o">=</span><span class="mi">111111</span><span class="p">,</span> <span class="n">posinf</span><span class="o">=</span><span class="mi">222222</span><span class="p">)</span>
<span class="go">array([222222.+111111.j, 111111.     +0.j, 111111.+222222.j])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.nanargmax">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">nanargmax</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nanargmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices of the maximum values in the specified axis ignoring
NaNs. For all-NaN slices <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> is raised. Warning: the
results cannot be trusted if a slice contains only NaNs and -Infs.</p>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input data.</p>
</dd>
<dt>axis<span class="classifier">int, optional</span></dt><dd><p>Axis along which to operate.  By default flattened input is used.</p>
</dd>
</dl>
<dl class="simple">
<dt>index_array<span class="classifier">ndarray</span></dt><dd><p>An array of indices or a single index value.</p>
</dd>
</dl>
<p>argmax, nanargmin</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanargmax</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanargmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([1, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanargmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([1, 1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.nanargmin">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">nanargmin</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nanargmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices of the minimum values in the specified axis ignoring
NaNs. For all-NaN slices <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> is raised. Warning: the results
cannot be trusted if a slice contains only NaNs and Infs.</p>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input data.</p>
</dd>
<dt>axis<span class="classifier">int, optional</span></dt><dd><p>Axis along which to operate.  By default flattened input is used.</p>
</dd>
</dl>
<dl class="simple">
<dt>index_array<span class="classifier">ndarray</span></dt><dd><p>An array of indices or a single index value.</p>
</dd>
</dl>
<p>argmin, nanargmax</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanargmin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanargmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([1, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanargmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([1, 0])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.nancumprod">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">nancumprod</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nancumprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cumulative product of array elements over a given axis treating Not a
Numbers (NaNs) as one.  The cumulative product does not change when NaNs are
encountered and leading NaNs are replaced by ones.</p>
<p>Ones are returned for slices that are all-NaN or empty.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.12.0.</span></p>
</div>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt>axis<span class="classifier">int, optional</span></dt><dd><p>Axis along which the cumulative product is computed.  By default
the input is flattened.</p>
</dd>
<dt>dtype<span class="classifier">dtype, optional</span></dt><dd><p>Type of the returned array, as well as of the accumulator in which
the elements are multiplied.  If <em>dtype</em> is not specified, it
defaults to the dtype of <cite>a</cite>, unless <cite>a</cite> has an integer dtype with
a precision less than that of the default platform integer.  In
that case, the default platform integer is used instead.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output
but the type of the resulting values will be cast if necessary.</p>
</dd>
</dl>
<dl class="simple">
<dt>nancumprod<span class="classifier">ndarray</span></dt><dd><p>A new array holding the result is returned unless <cite>out</cite> is
specified, in which case it is returned.</p>
</dd>
</dl>
<p>numpy.cumprod : Cumulative product across array propagating NaNs.
isnan : Show which elements are NaN.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumprod</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumprod</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">array([1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumprod</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
<span class="go">array([1.,  1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumprod</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([1.,  2.,  6.,  6.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumprod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[1.,  2.],</span>
<span class="go">       [3.,  2.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumprod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[1.,  2.],</span>
<span class="go">       [3.,  3.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.nancumsum">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">nancumsum</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nancumsum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cumulative sum of array elements over a given axis treating Not a
Numbers (NaNs) as zero.  The cumulative sum does not change when NaNs are
encountered and leading NaNs are replaced by zeros.</p>
<p>Zeros are returned for slices that are all-NaN or empty.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.12.0.</span></p>
</div>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt>axis<span class="classifier">int, optional</span></dt><dd><p>Axis along which the cumulative sum is computed. The default
(None) is to compute the cumsum over the flattened array.</p>
</dd>
<dt>dtype<span class="classifier">dtype, optional</span></dt><dd><p>Type of the returned array and of the accumulator in which the
elements are summed.  If <cite>dtype</cite> is not specified, it defaults
to the dtype of <cite>a</cite>, unless <cite>a</cite> has an integer dtype with a
precision less than that of the default platform integer.  In
that case, the default platform integer is used.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output
but the type will be cast if necessary. See <span class="xref std std-ref">ufuncs-output-type</span> for
more details.</p>
</dd>
</dl>
<dl class="simple">
<dt>nancumsum<span class="classifier">ndarray.</span></dt><dd><p>A new array holding the result is returned unless <cite>out</cite> is
specified, in which it is returned. The result has the same
size as <cite>a</cite>, and the same shape as <cite>a</cite> if <cite>axis</cite> is not None
or <cite>a</cite> is a 1-d array.</p>
</dd>
</dl>
<p>numpy.cumsum : Cumulative sum across array propagating NaNs.
isnan : Show which elements are NaN.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumsum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumsum</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">array([1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumsum</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
<span class="go">array([1.,  1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumsum</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([1.,  3.,  6.,  6.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[1.,  2.],</span>
<span class="go">       [4.,  2.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[1.,  3.],</span>
<span class="go">       [3.,  3.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.nanmax">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">nanmax</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">a</span></em>, <em class="sig-param"><span class="pre">axis=None</span></em>, <em class="sig-param"><span class="pre">out=None</span></em>, <em class="sig-param"><span class="pre">keepdims=&lt;no</span> <span class="pre">value&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nanmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum of an array or maximum along an axis, ignoring any
NaNs.  When all-NaN slices are encountered a <code class="docutils literal notranslate"><span class="pre">RuntimeWarning</span></code> is
raised and NaN is returned for that slice.</p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Array containing numbers whose maximum is desired. If <cite>a</cite> is not an
array, a conversion is attempted.</p>
</dd>
<dt>axis<span class="classifier">{int, tuple of int, None}, optional</span></dt><dd><p>Axis or axes along which the maximum is computed. The default is to compute
the maximum of the flattened array.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Alternate output array in which to place the result.  The default
is <code class="docutils literal notranslate"><span class="pre">None</span></code>; if provided, it must have the same shape as the
expected output, but the type will be cast if necessary. See
<span class="xref std std-ref">ufuncs-output-type</span> for more details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
</dd>
<dt>keepdims<span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original <cite>a</cite>.</p>
<p>If the value is anything but the default, then
<cite>keepdims</cite> will be passed through to the <cite>max</cite> method
of sub-classes of <cite>ndarray</cite>.  If the sub-classes methods
does not implement <cite>keepdims</cite> any exceptions will be raised.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>nanmax<span class="classifier">ndarray</span></dt><dd><p>An array with the same shape as <cite>a</cite>, with the specified axis removed.
If <cite>a</cite> is a 0-d array, or if axis is None, an ndarray scalar is
returned.  The same dtype as <cite>a</cite> is returned.</p>
</dd>
</dl>
<dl class="simple">
<dt>nanmin :</dt><dd><p>The minimum value of an array along a given axis, ignoring any NaNs.</p>
</dd>
<dt>amax :</dt><dd><p>The maximum value of an array along a given axis, propagating any NaNs.</p>
</dd>
<dt>fmax :</dt><dd><p>Element-wise maximum of two arrays, ignoring any NaNs.</p>
</dd>
<dt>maximum :</dt><dd><p>Element-wise maximum of two arrays, propagating any NaNs.</p>
</dd>
<dt>isnan :</dt><dd><p>Shows which elements are Not a Number (NaN).</p>
</dd>
<dt>isfinite:</dt><dd><p>Shows which elements are neither NaN nor infinity.</p>
</dd>
</dl>
<p>amin, fmin, minimum</p>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.
Positive infinity is treated as a very large number and negative
infinity is treated as a very small (i.e. negative) number.</p>
<p>If the input has a integer type the function is equivalent to np.max.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([3.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([2.,  3.])</span>
</pre></div>
</div>
<p>When positive infinity and negative infinity are present:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NINF</span><span class="p">])</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
<span class="go">inf</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.nanmean">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">nanmean</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">a</span></em>, <em class="sig-param"><span class="pre">axis=None</span></em>, <em class="sig-param"><span class="pre">dtype=None</span></em>, <em class="sig-param"><span class="pre">out=None</span></em>, <em class="sig-param"><span class="pre">keepdims=&lt;no</span> <span class="pre">value&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nanmean" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the arithmetic mean along the specified axis, ignoring NaNs.</p>
<p>Returns the average of the array elements.  The average is taken over
the flattened array by default, otherwise over the specified axis.
<cite>float64</cite> intermediate and return values are used for integer inputs.</p>
<p>For all-NaN slices, NaN is returned and a <cite>RuntimeWarning</cite> is raised.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Array containing numbers whose mean is desired. If <cite>a</cite> is not an
array, a conversion is attempted.</p>
</dd>
<dt>axis<span class="classifier">{int, tuple of int, None}, optional</span></dt><dd><p>Axis or axes along which the means are computed. The default is to compute
the mean of the flattened array.</p>
</dd>
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>Type to use in computing the mean.  For integer inputs, the default
is <cite>float64</cite>; for inexact inputs, it is the same as the input
dtype.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Alternate output array in which to place the result.  The default
is <code class="docutils literal notranslate"><span class="pre">None</span></code>; if provided, it must have the same shape as the
expected output, but the type will be cast if necessary. See
<span class="xref std std-ref">ufuncs-output-type</span> for more details.</p>
</dd>
<dt>keepdims<span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original <cite>a</cite>.</p>
<p>If the value is anything but the default, then
<cite>keepdims</cite> will be passed through to the <cite>mean</cite> or <cite>sum</cite> methods
of sub-classes of <cite>ndarray</cite>.  If the sub-classes methods
does not implement <cite>keepdims</cite> any exceptions will be raised.</p>
</dd>
</dl>
<dl class="simple">
<dt>m<span class="classifier">ndarray, see dtype parameter above</span></dt><dd><p>If <cite>out=None</cite>, returns a new array containing the mean values,
otherwise a reference to the output array is returned. Nan is
returned for slices that contain only NaNs.</p>
</dd>
</dl>
<p>average : Weighted average
mean : Arithmetic mean taken while not ignoring NaNs
var, nanvar</p>
<p>The arithmetic mean is the sum of the non-NaN elements along the axis
divided by the number of non-NaN elements.</p>
<p>Note that for floating-point input, the mean is computed using the same
precision the input has.  Depending on the input data, this can cause
the results to be inaccurate, especially for <cite>float32</cite>.  Specifying a
higher-precision accumulator using the <cite>dtype</cite> keyword can alleviate
this issue.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">2.6666666666666665</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([2.,  4.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([1.,  3.5]) # may vary</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.nanmedian">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">nanmedian</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">a</span></em>, <em class="sig-param"><span class="pre">axis=None</span></em>, <em class="sig-param"><span class="pre">out=None</span></em>, <em class="sig-param"><span class="pre">overwrite_input=False</span></em>, <em class="sig-param"><span class="pre">keepdims=&lt;no</span> <span class="pre">value&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nanmedian" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the median along the specified axis, while ignoring NaNs.</p>
<p>Returns the median of the array elements.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.9.0.</span></p>
</div>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input array or object that can be converted to an array.</p>
</dd>
<dt>axis<span class="classifier">{int, sequence of int, None}, optional</span></dt><dd><p>Axis or axes along which the medians are computed. The default
is to compute the median along a flattened version of the array.
A sequence of axes is supported since version 1.9.0.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output,
but the type (of the output) will be cast if necessary.</p>
</dd>
<dt>overwrite_input<span class="classifier">bool, optional</span></dt><dd><p>If True, then allow use of memory of input array <cite>a</cite> for
calculations. The input array will be modified by the call to
<cite>median</cite>. This will save memory when you do not need to preserve
the contents of the input array. Treat the input as undefined,
but it will probably be fully or partially sorted. Default is
False. If <cite>overwrite_input</cite> is <code class="docutils literal notranslate"><span class="pre">True</span></code> and <cite>a</cite> is not already an
<cite>ndarray</cite>, an error will be raised.</p>
</dd>
<dt>keepdims<span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original <cite>a</cite>.</p>
<p>If this is anything but the default value it will be passed
through (in the special case of an empty array) to the
<cite>mean</cite> function of the underlying array.  If the array is
a sub-class and <cite>mean</cite> does not have the kwarg <cite>keepdims</cite> this
will raise a RuntimeError.</p>
</dd>
</dl>
<dl class="simple">
<dt>median<span class="classifier">ndarray</span></dt><dd><p>A new array holding the result. If the input contains integers
or floats smaller than <code class="docutils literal notranslate"><span class="pre">float64</span></code>, then the output data-type is
<code class="docutils literal notranslate"><span class="pre">np.float64</span></code>.  Otherwise, the data-type of the output is the
same as that of the input. If <cite>out</cite> is specified, that array is
returned instead.</p>
</dd>
</dl>
<p>mean, median, percentile</p>
<p>Given a vector <code class="docutils literal notranslate"><span class="pre">V</span></code> of length <code class="docutils literal notranslate"><span class="pre">N</span></code>, the median of <code class="docutils literal notranslate"><span class="pre">V</span></code> is the
middle value of a sorted copy of <code class="docutils literal notranslate"><span class="pre">V</span></code>, <code class="docutils literal notranslate"><span class="pre">V_sorted</span></code> - i.e.,
<code class="docutils literal notranslate"><span class="pre">V_sorted[(N-1)/2]</span></code>, when <code class="docutils literal notranslate"><span class="pre">N</span></code> is odd and the average of the two
middle values of <code class="docutils literal notranslate"><span class="pre">V_sorted</span></code> when <code class="docutils literal notranslate"><span class="pre">N</span></code> is even.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">10.0</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[10., nan,  4.],</span>
<span class="go">       [ 3.,  2.,  1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">nan</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([6.5, 2. , 2.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([nan,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([7.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.nanmin">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">nanmin</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">a</span></em>, <em class="sig-param"><span class="pre">axis=None</span></em>, <em class="sig-param"><span class="pre">out=None</span></em>, <em class="sig-param"><span class="pre">keepdims=&lt;no</span> <span class="pre">value&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nanmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return minimum of an array or minimum along an axis, ignoring any NaNs.
When all-NaN slices are encountered a <code class="docutils literal notranslate"><span class="pre">RuntimeWarning</span></code> is raised and
Nan is returned for that slice.</p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Array containing numbers whose minimum is desired. If <cite>a</cite> is not an
array, a conversion is attempted.</p>
</dd>
<dt>axis<span class="classifier">{int, tuple of int, None}, optional</span></dt><dd><p>Axis or axes along which the minimum is computed. The default is to compute
the minimum of the flattened array.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Alternate output array in which to place the result.  The default
is <code class="docutils literal notranslate"><span class="pre">None</span></code>; if provided, it must have the same shape as the
expected output, but the type will be cast if necessary. See
<span class="xref std std-ref">ufuncs-output-type</span> for more details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
</dd>
<dt>keepdims<span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original <cite>a</cite>.</p>
<p>If the value is anything but the default, then
<cite>keepdims</cite> will be passed through to the <cite>min</cite> method
of sub-classes of <cite>ndarray</cite>.  If the sub-classes methods
does not implement <cite>keepdims</cite> any exceptions will be raised.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>nanmin<span class="classifier">ndarray</span></dt><dd><p>An array with the same shape as <cite>a</cite>, with the specified axis
removed.  If <cite>a</cite> is a 0-d array, or if axis is None, an ndarray
scalar is returned.  The same dtype as <cite>a</cite> is returned.</p>
</dd>
</dl>
<dl class="simple">
<dt>nanmax :</dt><dd><p>The maximum value of an array along a given axis, ignoring any NaNs.</p>
</dd>
<dt>amin :</dt><dd><p>The minimum value of an array along a given axis, propagating any NaNs.</p>
</dd>
<dt>fmin :</dt><dd><p>Element-wise minimum of two arrays, ignoring any NaNs.</p>
</dd>
<dt>minimum :</dt><dd><p>Element-wise minimum of two arrays, propagating any NaNs.</p>
</dd>
<dt>isnan :</dt><dd><p>Shows which elements are Not a Number (NaN).</p>
</dd>
<dt>isfinite:</dt><dd><p>Shows which elements are neither NaN nor infinity.</p>
</dd>
</dl>
<p>amax, fmax, maximum</p>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.
Positive infinity is treated as a very large number and negative
infinity is treated as a very small (i.e. negative) number.</p>
<p>If the input has a integer type the function is equivalent to np.min.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([1.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([1.,  3.])</span>
</pre></div>
</div>
<p>When positive infinity and negative infinity are present:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NINF</span><span class="p">])</span>
<span class="go">-inf</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.nanpercentile">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">nanpercentile</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">a</span></em>, <em class="sig-param"><span class="pre">q</span></em>, <em class="sig-param"><span class="pre">axis=None</span></em>, <em class="sig-param"><span class="pre">out=None</span></em>, <em class="sig-param"><span class="pre">overwrite_input=False</span></em>, <em class="sig-param"><span class="pre">interpolation='linear'</span></em>, <em class="sig-param"><span class="pre">keepdims=&lt;no</span> <span class="pre">value&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nanpercentile" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the qth percentile of the data along the specified axis,
while ignoring nan values.</p>
<p>Returns the qth percentile(s) of the array elements.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.9.0.</span></p>
</div>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input array or object that can be converted to an array, containing
nan values to be ignored.</p>
</dd>
<dt>q<span class="classifier">array_like of float</span></dt><dd><p>Percentile or sequence of percentiles to compute, which must be between
0 and 100 inclusive.</p>
</dd>
<dt>axis<span class="classifier">{int, tuple of int, None}, optional</span></dt><dd><p>Axis or axes along which the percentiles are computed. The
default is to compute the percentile(s) along a flattened
version of the array.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output,
but the type (of the output) will be cast if necessary.</p>
</dd>
<dt>overwrite_input<span class="classifier">bool, optional</span></dt><dd><p>If True, then allow the input array <cite>a</cite> to be modified by intermediate
calculations, to save memory. In this case, the contents of the input
<cite>a</cite> after this function completes is undefined.</p>
</dd>
<dt>interpolation<span class="classifier">{‘linear’, ‘lower’, ‘higher’, ‘midpoint’, ‘nearest’}</span></dt><dd><p>This optional parameter specifies the interpolation method to
use when the desired percentile lies between two data points
<code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">j</span></code>:</p>
<ul class="simple">
<li><p>‘linear’: <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">(j</span> <span class="pre">-</span> <span class="pre">i)</span> <span class="pre">*</span> <span class="pre">fraction</span></code>, where <code class="docutils literal notranslate"><span class="pre">fraction</span></code>
is the fractional part of the index surrounded by <code class="docutils literal notranslate"><span class="pre">i</span></code>
and <code class="docutils literal notranslate"><span class="pre">j</span></code>.</p></li>
<li><p>‘lower’: <code class="docutils literal notranslate"><span class="pre">i</span></code>.</p></li>
<li><p>‘higher’: <code class="docutils literal notranslate"><span class="pre">j</span></code>.</p></li>
<li><p>‘nearest’: <code class="docutils literal notranslate"><span class="pre">i</span></code> or <code class="docutils literal notranslate"><span class="pre">j</span></code>, whichever is nearest.</p></li>
<li><p>‘midpoint’: <code class="docutils literal notranslate"><span class="pre">(i</span> <span class="pre">+</span> <span class="pre">j)</span> <span class="pre">/</span> <span class="pre">2</span></code>.</p></li>
</ul>
</dd>
<dt>keepdims<span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left in
the result as dimensions with size one. With this option, the
result will broadcast correctly against the original array <cite>a</cite>.</p>
<p>If this is anything but the default value it will be passed
through (in the special case of an empty array) to the
<cite>mean</cite> function of the underlying array.  If the array is
a sub-class and <cite>mean</cite> does not have the kwarg <cite>keepdims</cite> this
will raise a RuntimeError.</p>
</dd>
</dl>
<dl class="simple">
<dt>percentile<span class="classifier">scalar or ndarray</span></dt><dd><p>If <cite>q</cite> is a single percentile and <cite>axis=None</cite>, then the result
is a scalar. If multiple percentiles are given, first axis of
the result corresponds to the percentiles. The other axes are
the axes that remain after the reduction of <cite>a</cite>. If the input
contains integers or floats smaller than <code class="docutils literal notranslate"><span class="pre">float64</span></code>, the output
data-type is <code class="docutils literal notranslate"><span class="pre">float64</span></code>. Otherwise, the output data-type is the
same as that of the input. If <cite>out</cite> is specified, that array is
returned instead.</p>
</dd>
</dl>
<p>nanmean
nanmedian : equivalent to <code class="docutils literal notranslate"><span class="pre">nanpercentile(...,</span> <span class="pre">50)</span></code>
percentile, median, mean
nanquantile : equivalent to nanpercentile, but with q in the range [0, 1].</p>
<p>Given a vector <code class="docutils literal notranslate"><span class="pre">V</span></code> of length <code class="docutils literal notranslate"><span class="pre">N</span></code>, the <code class="docutils literal notranslate"><span class="pre">q</span></code>-th percentile of
<code class="docutils literal notranslate"><span class="pre">V</span></code> is the value <code class="docutils literal notranslate"><span class="pre">q/100</span></code> of the way from the minimum to the
maximum in a sorted copy of <code class="docutils literal notranslate"><span class="pre">V</span></code>. The values and distances of
the two nearest neighbors as well as the <cite>interpolation</cite> parameter
will determine the percentile if the normalized ranking does not
match the location of <code class="docutils literal notranslate"><span class="pre">q</span></code> exactly. This function is the same as
the median if <code class="docutils literal notranslate"><span class="pre">q=50</span></code>, the same as the minimum if <code class="docutils literal notranslate"><span class="pre">q=0</span></code> and the
same as the maximum if <code class="docutils literal notranslate"><span class="pre">q=100</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">10.</span><span class="p">,</span> <span class="mf">7.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">],</span> <span class="p">[</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[10.,  nan,   4.],</span>
<span class="go">      [ 3.,   2.,   1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="go">nan</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([6.5, 2. , 2.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([[7.],</span>
<span class="go">       [2.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
<span class="go">array([6.5, 2. , 2.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">array([6.5,  2. ,  2.5])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([7., 2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.nanprod">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">nanprod</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">a</span></em>, <em class="sig-param"><span class="pre">axis=None</span></em>, <em class="sig-param"><span class="pre">dtype=None</span></em>, <em class="sig-param"><span class="pre">out=None</span></em>, <em class="sig-param"><span class="pre">keepdims=&lt;no</span> <span class="pre">value&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nanprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the product of array elements over a given axis treating Not a
Numbers (NaNs) as ones.</p>
<p>One is returned for slices that are all-NaN or empty.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.0.</span></p>
</div>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>Array containing numbers whose product is desired. If <cite>a</cite> is not an
array, a conversion is attempted.</p>
</dd>
<dt>axis<span class="classifier">{int, tuple of int, None}, optional</span></dt><dd><p>Axis or axes along which the product is computed. The default is to compute
the product of the flattened array.</p>
</dd>
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>The type of the returned array and of the accumulator in which the
elements are summed.  By default, the dtype of <cite>a</cite> is used.  An
exception is when <cite>a</cite> has an integer type with less precision than
the platform (u)intp. In that case, the default will be either
(u)int32 or (u)int64 depending on whether the platform is 32 or 64
bits. For inexact inputs, dtype must be inexact.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Alternate output array in which to place the result.  The default
is <code class="docutils literal notranslate"><span class="pre">None</span></code>. If provided, it must have the same shape as the
expected output, but the type will be cast if necessary. See
<span class="xref std std-ref">ufuncs-output-type</span> for more details. The casting of NaN to integer
can yield unexpected results.</p>
</dd>
<dt>keepdims<span class="classifier">bool, optional</span></dt><dd><p>If True, the axes which are reduced are left in the result as
dimensions with size one. With this option, the result will
broadcast correctly against the original <cite>arr</cite>.</p>
</dd>
</dl>
<dl class="simple">
<dt>nanprod<span class="classifier">ndarray</span></dt><dd><p>A new array holding the result is returned unless <cite>out</cite> is
specified, in which case it is returned.</p>
</dd>
</dl>
<p>numpy.prod : Product across array propagating NaNs.
isnan : Show which elements are NaN.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanprod</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanprod</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanprod</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanprod</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">6.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanprod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([3., 2.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.nanquantile">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">nanquantile</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">a</span></em>, <em class="sig-param"><span class="pre">q</span></em>, <em class="sig-param"><span class="pre">axis=None</span></em>, <em class="sig-param"><span class="pre">out=None</span></em>, <em class="sig-param"><span class="pre">overwrite_input=False</span></em>, <em class="sig-param"><span class="pre">interpolation='linear'</span></em>, <em class="sig-param"><span class="pre">keepdims=&lt;no</span> <span class="pre">value&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nanquantile" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the qth quantile of the data along the specified axis,
while ignoring nan values.
Returns the qth quantile(s) of the array elements.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.15.0.</span></p>
</div>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input array or object that can be converted to an array, containing
nan values to be ignored</p>
</dd>
<dt>q<span class="classifier">array_like of float</span></dt><dd><p>Quantile or sequence of quantiles to compute, which must be between
0 and 1 inclusive.</p>
</dd>
<dt>axis<span class="classifier">{int, tuple of int, None}, optional</span></dt><dd><p>Axis or axes along which the quantiles are computed. The
default is to compute the quantile(s) along a flattened
version of the array.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output,
but the type (of the output) will be cast if necessary.</p>
</dd>
<dt>overwrite_input<span class="classifier">bool, optional</span></dt><dd><p>If True, then allow the input array <cite>a</cite> to be modified by intermediate
calculations, to save memory. In this case, the contents of the input
<cite>a</cite> after this function completes is undefined.</p>
</dd>
<dt>interpolation<span class="classifier">{‘linear’, ‘lower’, ‘higher’, ‘midpoint’, ‘nearest’}</span></dt><dd><p>This optional parameter specifies the interpolation method to
use when the desired quantile lies between two data points
<code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">j</span></code>:</p>
<ul class="simple">
<li><p>linear: <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">(j</span> <span class="pre">-</span> <span class="pre">i)</span> <span class="pre">*</span> <span class="pre">fraction</span></code>, where <code class="docutils literal notranslate"><span class="pre">fraction</span></code>
is the fractional part of the index surrounded by <code class="docutils literal notranslate"><span class="pre">i</span></code>
and <code class="docutils literal notranslate"><span class="pre">j</span></code>.</p></li>
<li><p>lower: <code class="docutils literal notranslate"><span class="pre">i</span></code>.</p></li>
<li><p>higher: <code class="docutils literal notranslate"><span class="pre">j</span></code>.</p></li>
<li><p>nearest: <code class="docutils literal notranslate"><span class="pre">i</span></code> or <code class="docutils literal notranslate"><span class="pre">j</span></code>, whichever is nearest.</p></li>
<li><p>midpoint: <code class="docutils literal notranslate"><span class="pre">(i</span> <span class="pre">+</span> <span class="pre">j)</span> <span class="pre">/</span> <span class="pre">2</span></code>.</p></li>
</ul>
</dd>
<dt>keepdims<span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left in
the result as dimensions with size one. With this option, the
result will broadcast correctly against the original array <cite>a</cite>.</p>
<p>If this is anything but the default value it will be passed
through (in the special case of an empty array) to the
<cite>mean</cite> function of the underlying array.  If the array is
a sub-class and <cite>mean</cite> does not have the kwarg <cite>keepdims</cite> this
will raise a RuntimeError.</p>
</dd>
</dl>
<dl class="simple">
<dt>quantile<span class="classifier">scalar or ndarray</span></dt><dd><p>If <cite>q</cite> is a single percentile and <cite>axis=None</cite>, then the result
is a scalar. If multiple quantiles are given, first axis of
the result corresponds to the quantiles. The other axes are
the axes that remain after the reduction of <cite>a</cite>. If the input
contains integers or floats smaller than <code class="docutils literal notranslate"><span class="pre">float64</span></code>, the output
data-type is <code class="docutils literal notranslate"><span class="pre">float64</span></code>. Otherwise, the output data-type is the
same as that of the input. If <cite>out</cite> is specified, that array is
returned instead.</p>
</dd>
</dl>
<p>quantile
nanmean, nanmedian
nanmedian : equivalent to <code class="docutils literal notranslate"><span class="pre">nanquantile(...,</span> <span class="pre">0.5)</span></code>
nanpercentile : same as nanquantile, but with q in the range [0, 100].</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">10.</span><span class="p">,</span> <span class="mf">7.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">],</span> <span class="p">[</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[10.,  nan,   4.],</span>
<span class="go">      [ 3.,   2.,   1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="go">nan</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanquantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanquantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([6.5, 2. , 2.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanquantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([[7.],</span>
<span class="go">       [2.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanquantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanquantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
<span class="go">array([6.5, 2. , 2.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">array([6.5,  2. ,  2.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanquantile</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([7., 2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.nanstd">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">nanstd</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">a</span></em>, <em class="sig-param"><span class="pre">axis=None</span></em>, <em class="sig-param"><span class="pre">dtype=None</span></em>, <em class="sig-param"><span class="pre">out=None</span></em>, <em class="sig-param"><span class="pre">ddof=0</span></em>, <em class="sig-param"><span class="pre">keepdims=&lt;no</span> <span class="pre">value&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nanstd" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the standard deviation along the specified axis, while
ignoring NaNs.</p>
<p>Returns the standard deviation, a measure of the spread of a
distribution, of the non-NaN array elements. The standard deviation is
computed for the flattened array by default, otherwise over the
specified axis.</p>
<p>For all-NaN slices or slices with zero degrees of freedom, NaN is
returned and a <cite>RuntimeWarning</cite> is raised.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Calculate the standard deviation of the non-NaN values.</p>
</dd>
<dt>axis<span class="classifier">{int, tuple of int, None}, optional</span></dt><dd><p>Axis or axes along which the standard deviation is computed. The default is
to compute the standard deviation of the flattened array.</p>
</dd>
<dt>dtype<span class="classifier">dtype, optional</span></dt><dd><p>Type to use in computing the standard deviation. For arrays of
integer type the default is float64, for arrays of float types it
is the same as the array type.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Alternative output array in which to place the result. It must have
the same shape as the expected output but the type (of the
calculated values) will be cast if necessary.</p>
</dd>
<dt>ddof<span class="classifier">int, optional</span></dt><dd><p>Means Delta Degrees of Freedom.  The divisor used in calculations
is <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">ddof</span></code>, where <code class="docutils literal notranslate"><span class="pre">N</span></code> represents the number of non-NaN
elements.  By default <cite>ddof</cite> is zero.</p>
</dd>
<dt>keepdims<span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original <cite>a</cite>.</p>
<p>If this value is anything but the default it is passed through
as-is to the relevant functions of the sub-classes.  If these
functions do not have a <cite>keepdims</cite> kwarg, a RuntimeError will
be raised.</p>
</dd>
</dl>
<dl class="simple">
<dt>standard_deviation<span class="classifier">ndarray, see dtype parameter above.</span></dt><dd><p>If <cite>out</cite> is None, return a new array containing the standard
deviation, otherwise return a reference to the output array. If
ddof is &gt;= the number of non-NaN elements in a slice or the slice
contains only NaNs, then the result for that slice is NaN.</p>
</dd>
</dl>
<p>var, mean, std
nanvar, nanmean
<span class="xref std std-ref">ufuncs-output-type</span></p>
<p>The standard deviation is the square root of the average of the squared
deviations from the mean: <code class="docutils literal notranslate"><span class="pre">std</span> <span class="pre">=</span> <span class="pre">sqrt(mean(abs(x</span> <span class="pre">-</span> <span class="pre">x.mean())**2))</span></code>.</p>
<p>The average squared deviation is normally calculated as
<code class="docutils literal notranslate"><span class="pre">x.sum()</span> <span class="pre">/</span> <span class="pre">N</span></code>, where <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">len(x)</span></code>.  If, however, <cite>ddof</cite> is
specified, the divisor <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">ddof</span></code> is used instead. In standard
statistical practice, <code class="docutils literal notranslate"><span class="pre">ddof=1</span></code> provides an unbiased estimator of the
variance of the infinite population. <code class="docutils literal notranslate"><span class="pre">ddof=0</span></code> provides a maximum
likelihood estimate of the variance for normally distributed variables.
The standard deviation computed in this function is the square root of
the estimated variance, so even with <code class="docutils literal notranslate"><span class="pre">ddof=1</span></code>, it will not be an
unbiased estimate of the standard deviation per se.</p>
<p>Note that, for complex numbers, <cite>std</cite> takes the absolute value before
squaring, so that the result is always real and nonnegative.</p>
<p>For floating-point input, the <em>std</em> is computed using the same
precision the input has. Depending on the input data, this can cause
the results to be inaccurate, especially for float32 (see example
below).  Specifying a higher-accuracy accumulator using the <cite>dtype</cite>
keyword can alleviate this issue.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1.247219128924647</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([1., 0.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([0.,  0.5]) # may vary</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.nansum">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">nansum</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">a</span></em>, <em class="sig-param"><span class="pre">axis=None</span></em>, <em class="sig-param"><span class="pre">dtype=None</span></em>, <em class="sig-param"><span class="pre">out=None</span></em>, <em class="sig-param"><span class="pre">keepdims=&lt;no</span> <span class="pre">value&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nansum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum of array elements over a given axis treating Not a
Numbers (NaNs) as zero.</p>
<p>In NumPy versions &lt;= 1.9.0 Nan is returned for slices that are all-NaN or
empty. In later versions zero is returned.</p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Array containing numbers whose sum is desired. If <cite>a</cite> is not an
array, a conversion is attempted.</p>
</dd>
<dt>axis<span class="classifier">{int, tuple of int, None}, optional</span></dt><dd><p>Axis or axes along which the sum is computed. The default is to compute the
sum of the flattened array.</p>
</dd>
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>The type of the returned array and of the accumulator in which the
elements are summed.  By default, the dtype of <cite>a</cite> is used.  An
exception is when <cite>a</cite> has an integer type with less precision than
the platform (u)intp. In that case, the default will be either
(u)int32 or (u)int64 depending on whether the platform is 32 or 64
bits. For inexact inputs, dtype must be inexact.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Alternate output array in which to place the result.  The default
is <code class="docutils literal notranslate"><span class="pre">None</span></code>. If provided, it must have the same shape as the
expected output, but the type will be cast if necessary.  See
<span class="xref std std-ref">ufuncs-output-type</span> for more details. The casting of NaN to integer
can yield unexpected results.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
</dd>
<dt>keepdims<span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original <cite>a</cite>.</p>
<p>If the value is anything but the default, then
<cite>keepdims</cite> will be passed through to the <cite>mean</cite> or <cite>sum</cite> methods
of sub-classes of <cite>ndarray</cite>.  If the sub-classes methods
does not implement <cite>keepdims</cite> any exceptions will be raised.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>nansum<span class="classifier">ndarray.</span></dt><dd><p>A new array holding the result is returned unless <cite>out</cite> is
specified, in which it is returned. The result has the same
size as <cite>a</cite>, and the same shape as <cite>a</cite> if <cite>axis</cite> is not None
or <cite>a</cite> is a 1-d array.</p>
</dd>
</dl>
<p>numpy.sum : Sum across array propagating NaNs.
isnan : Show which elements are NaN.
isfinite : Show which elements are not NaN or +/-inf.</p>
<p>If both positive and negative infinity are present, the sum will be Not
A Number (NaN).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([2.,  1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
<span class="go">inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NINF</span><span class="p">])</span>
<span class="go">-inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy.testing</span> <span class="kn">import</span> <span class="n">suppress_warnings</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">suppress_warnings</span><span class="p">()</span> <span class="k">as</span> <span class="n">sup</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">sup</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="ne">RuntimeWarning</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span> <span class="c1"># both +/- infinity present</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.nanvar">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">nanvar</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">a</span></em>, <em class="sig-param"><span class="pre">axis=None</span></em>, <em class="sig-param"><span class="pre">dtype=None</span></em>, <em class="sig-param"><span class="pre">out=None</span></em>, <em class="sig-param"><span class="pre">ddof=0</span></em>, <em class="sig-param"><span class="pre">keepdims=&lt;no</span> <span class="pre">value&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nanvar" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the variance along the specified axis, while ignoring NaNs.</p>
<p>Returns the variance of the array elements, a measure of the spread of
a distribution.  The variance is computed for the flattened array by
default, otherwise over the specified axis.</p>
<p>For all-NaN slices or slices with zero degrees of freedom, NaN is
returned and a <cite>RuntimeWarning</cite> is raised.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>Array containing numbers whose variance is desired.  If <cite>a</cite> is not an
array, a conversion is attempted.</p>
</dd>
<dt>axis<span class="classifier">{int, tuple of int, None}, optional</span></dt><dd><p>Axis or axes along which the variance is computed.  The default is to compute
the variance of the flattened array.</p>
</dd>
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>Type to use in computing the variance.  For arrays of integer type
the default is <cite>float64</cite>; for arrays of float types it is the same as
the array type.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Alternate output array in which to place the result.  It must have
the same shape as the expected output, but the type is cast if
necessary.</p>
</dd>
<dt>ddof<span class="classifier">int, optional</span></dt><dd><p>“Delta Degrees of Freedom”: the divisor used in the calculation is
<code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">ddof</span></code>, where <code class="docutils literal notranslate"><span class="pre">N</span></code> represents the number of non-NaN
elements. By default <cite>ddof</cite> is zero.</p>
</dd>
<dt>keepdims<span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original <cite>a</cite>.</p>
</dd>
</dl>
<dl class="simple">
<dt>variance<span class="classifier">ndarray, see dtype parameter above</span></dt><dd><p>If <cite>out</cite> is None, return a new array containing the variance,
otherwise return a reference to the output array. If ddof is &gt;= the
number of non-NaN elements in a slice or the slice contains only
NaNs, then the result for that slice is NaN.</p>
</dd>
</dl>
<p>std : Standard deviation
mean : Average
var : Variance while not ignoring NaNs
nanstd, nanmean
<span class="xref std std-ref">ufuncs-output-type</span></p>
<p>The variance is the average of the squared deviations from the mean,
i.e.,  <code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">=</span> <span class="pre">mean(abs(x</span> <span class="pre">-</span> <span class="pre">x.mean())**2)</span></code>.</p>
<p>The mean is normally calculated as <code class="docutils literal notranslate"><span class="pre">x.sum()</span> <span class="pre">/</span> <span class="pre">N</span></code>, where <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">len(x)</span></code>.
If, however, <cite>ddof</cite> is specified, the divisor <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">ddof</span></code> is used
instead.  In standard statistical practice, <code class="docutils literal notranslate"><span class="pre">ddof=1</span></code> provides an
unbiased estimator of the variance of a hypothetical infinite
population.  <code class="docutils literal notranslate"><span class="pre">ddof=0</span></code> provides a maximum likelihood estimate of the
variance for normally distributed variables.</p>
<p>Note that for complex numbers, the absolute value is taken before
squaring, so that the result is always real and nonnegative.</p>
<p>For floating-point input, the variance is computed using the same
precision the input has.  Depending on the input data, this can cause
the results to be inaccurate, especially for <cite>float32</cite> (see example
below).  Specifying a higher-accuracy accumulator using the <code class="docutils literal notranslate"><span class="pre">dtype</span></code>
keyword can alleviate this issue.</p>
<p>For this function to work on sub-classes of ndarray, they must define
<cite>sum</cite> with the kwarg <cite>keepdims</cite></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanvar</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1.5555555555555554</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanvar</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([1.,  0.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanvar</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([0.,  0.25])  # may vary</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt id="numpy.ndarray">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">ndarray</span></code><a class="headerlink" href="#numpy.ndarray" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>ndarray(shape, dtype=float, buffer=None, offset=0,</dt><dd><p>strides=None, order=None)</p>
</dd>
</dl>
<p>An array object represents a multidimensional, homogeneous array
of fixed-size items.  An associated data-type object describes the
format of each element in the array (its byte-order, how many bytes it
occupies in memory, whether it is an integer, a floating point number,
or something else, etc.)</p>
<p>Arrays should be constructed using <cite>array</cite>, <cite>zeros</cite> or <cite>empty</cite> (refer
to the See Also section below).  The parameters given here refer to
a low-level method (<cite>ndarray(…)</cite>) for instantiating an array.</p>
<p>For more information, refer to the <cite>numpy</cite> module and examine the
methods and attributes of an array.</p>
<p>(for the __new__ method; see Notes below)</p>
<dl class="simple">
<dt>shape<span class="classifier">tuple of ints</span></dt><dd><p>Shape of created array.</p>
</dd>
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>Any object that can be interpreted as a numpy data type.</p>
</dd>
<dt>buffer<span class="classifier">object exposing buffer interface, optional</span></dt><dd><p>Used to fill the array with data.</p>
</dd>
<dt>offset<span class="classifier">int, optional</span></dt><dd><p>Offset of array data in buffer.</p>
</dd>
<dt>strides<span class="classifier">tuple of ints, optional</span></dt><dd><p>Strides of data in memory.</p>
</dd>
<dt>order<span class="classifier">{‘C’, ‘F’}, optional</span></dt><dd><p>Row-major (C-style) or column-major (Fortran-style) order.</p>
</dd>
</dl>
<dl class="simple">
<dt>T<span class="classifier">ndarray</span></dt><dd><p>Transpose of the array.</p>
</dd>
<dt>data<span class="classifier">buffer</span></dt><dd><p>The array’s elements, in memory.</p>
</dd>
<dt>dtype<span class="classifier">dtype object</span></dt><dd><p>Describes the format of the elements in the array.</p>
</dd>
<dt>flags<span class="classifier">dict</span></dt><dd><p>Dictionary containing information related to memory use, e.g.,
‘C_CONTIGUOUS’, ‘OWNDATA’, ‘WRITEABLE’, etc.</p>
</dd>
<dt>flat<span class="classifier">numpy.flatiter object</span></dt><dd><p>Flattened version of the array as an iterator.  The iterator
allows assignments, e.g., <code class="docutils literal notranslate"><span class="pre">x.flat</span> <span class="pre">=</span> <span class="pre">3</span></code> (See <cite>ndarray.flat</cite> for
assignment examples; TODO).</p>
</dd>
<dt>imag<span class="classifier">ndarray</span></dt><dd><p>Imaginary part of the array.</p>
</dd>
<dt>real<span class="classifier">ndarray</span></dt><dd><p>Real part of the array.</p>
</dd>
<dt>size<span class="classifier">int</span></dt><dd><p>Number of elements in the array.</p>
</dd>
<dt>itemsize<span class="classifier">int</span></dt><dd><p>The memory use of each array element in bytes.</p>
</dd>
<dt>nbytes<span class="classifier">int</span></dt><dd><p>The total number of bytes required to store the array data,
i.e., <code class="docutils literal notranslate"><span class="pre">itemsize</span> <span class="pre">*</span> <span class="pre">size</span></code>.</p>
</dd>
<dt>ndim<span class="classifier">int</span></dt><dd><p>The array’s number of dimensions.</p>
</dd>
<dt>shape<span class="classifier">tuple of ints</span></dt><dd><p>Shape of the array.</p>
</dd>
<dt>strides<span class="classifier">tuple of ints</span></dt><dd><p>The step-size required to move from one element to the next in
memory. For example, a contiguous <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">4)</span></code> array of type
<code class="docutils literal notranslate"><span class="pre">int16</span></code> in C-order has strides <code class="docutils literal notranslate"><span class="pre">(8,</span> <span class="pre">2)</span></code>.  This implies that
to move from element to element in memory requires jumps of 2 bytes.
To move from row-to-row, one needs to jump 8 bytes at a time
(<code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">4</span></code>).</p>
</dd>
<dt>ctypes<span class="classifier">ctypes object</span></dt><dd><p>Class containing properties of the array needed for interaction
with ctypes.</p>
</dd>
<dt>base<span class="classifier">ndarray</span></dt><dd><p>If the array is a view into another array, that array is its <cite>base</cite>
(unless that array is also a view).  The <cite>base</cite> array is where the
array data is actually stored.</p>
</dd>
</dl>
<p>array : Construct an array.
zeros : Create an array, each element of which is zero.
empty : Create an array, but leave its allocated memory unchanged (i.e.,</p>
<blockquote>
<div><p>it contains “garbage”).</p>
</div></blockquote>
<p>dtype : Create a data-type.
numpy.typing.NDArray : A <span class="xref std std-term">generic</span> version</p>
<blockquote>
<div><p>of ndarray.</p>
</div></blockquote>
<p>There are two modes of creating an array using <code class="docutils literal notranslate"><span class="pre">__new__</span></code>:</p>
<ol class="arabic simple">
<li><p>If <cite>buffer</cite> is None, then only <cite>shape</cite>, <cite>dtype</cite>, and <cite>order</cite>
are used.</p></li>
<li><p>If <cite>buffer</cite> is an object exposing the buffer interface, then
all keywords are interpreted.</p></li>
</ol>
<p>No <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method is needed because the array is fully initialized
after the <code class="docutils literal notranslate"><span class="pre">__new__</span></code> method.</p>
<p>These examples illustrate the low-level <cite>ndarray</cite> constructor.  Refer
to the <cite>See Also</cite> section above for easier ways of constructing an
ndarray.</p>
<p>First mode, <cite>buffer</cite> is None:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
<span class="go">array([[0.0e+000, 0.0e+000], # random</span>
<span class="go">       [     nan, 2.5e-323]])</span>
</pre></div>
</div>
<p>Second mode:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="mi">2</span><span class="p">,),</span> <span class="n">buffer</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span>
<span class="gp">... </span>           <span class="n">offset</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">()</span><span class="o">.</span><span class="n">itemsize</span><span class="p">,</span>
<span class="gp">... </span>           <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="c1"># offset = 1*itemsize, i.e. skip first element</span>
<span class="go">array([2, 3])</span>
</pre></div>
</div>
<dl class="py attribute">
<dt id="numpy.ndarray.T">
<code class="sig-name descname"><span class="pre">T</span></code><a class="headerlink" href="#numpy.ndarray.T" title="Permalink to this definition">¶</a></dt>
<dd><p>The transposed array.</p>
<p>Same as <code class="docutils literal notranslate"><span class="pre">self.transpose()</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">4.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[ 1.,  2.],</span>
<span class="go">       [ 3.,  4.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">T</span>
<span class="go">array([[ 1.,  3.],</span>
<span class="go">       [ 2.,  4.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">4.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([ 1.,  2.,  3.,  4.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">T</span>
<span class="go">array([ 1.,  2.,  3.,  4.])</span>
</pre></div>
</div>
<p>transpose</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.all">
<code class="sig-name descname"><span class="pre">all</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keepdims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">where</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.all" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if all elements evaluate to True.</p>
<p>Refer to <cite>numpy.all</cite> for full documentation.</p>
<p>numpy.all : equivalent function</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.any">
<code class="sig-name descname"><span class="pre">any</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keepdims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">where</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.any" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if any of the elements of <cite>a</cite> evaluate to True.</p>
<p>Refer to <cite>numpy.any</cite> for full documentation.</p>
<p>numpy.any : equivalent function</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.argmax">
<code class="sig-name descname"><span class="pre">argmax</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.argmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Return indices of the maximum values along the given axis.</p>
<p>Refer to <cite>numpy.argmax</cite> for full documentation.</p>
<p>numpy.argmax : equivalent function</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.argmin">
<code class="sig-name descname"><span class="pre">argmin</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.argmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return indices of the minimum values along the given axis.</p>
<p>Refer to <cite>numpy.argmin</cite> for detailed documentation.</p>
<p>numpy.argmin : equivalent function</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.argpartition">
<code class="sig-name descname"><span class="pre">argpartition</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'introselect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.argpartition" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the indices that would partition this array.</p>
<p>Refer to <cite>numpy.argpartition</cite> for full documentation.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
<p>numpy.argpartition : equivalent function</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.argsort">
<code class="sig-name descname"><span class="pre">argsort</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.argsort" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the indices that would sort this array.</p>
<p>Refer to <cite>numpy.argsort</cite> for full documentation.</p>
<p>numpy.argsort : equivalent function</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.astype">
<code class="sig-name descname"><span class="pre">astype</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dtype</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'K'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">casting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'unsafe'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subok</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.astype" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy of the array, cast to a specified type.</p>
<dl>
<dt>dtype<span class="classifier">str or dtype</span></dt><dd><p>Typecode or data-type to which the array is cast.</p>
</dd>
<dt>order<span class="classifier">{‘C’, ‘F’, ‘A’, ‘K’}, optional</span></dt><dd><p>Controls the memory layout order of the result.
‘C’ means C order, ‘F’ means Fortran order, ‘A’
means ‘F’ order if all the arrays are Fortran contiguous,
‘C’ order otherwise, and ‘K’ means as close to the
order the array elements appear in memory as possible.
Default is ‘K’.</p>
</dd>
<dt>casting<span class="classifier">{‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional</span></dt><dd><p>Controls what kind of data casting may occur. Defaults to ‘unsafe’
for backwards compatibility.</p>
<blockquote>
<div><ul class="simple">
<li><p>‘no’ means the data types should not be cast at all.</p></li>
<li><p>‘equiv’ means only byte-order changes are allowed.</p></li>
<li><p>‘safe’ means only casts which can preserve values are allowed.</p></li>
<li><p>‘same_kind’ means only safe casts or casts within a kind,
like float64 to float32, are allowed.</p></li>
<li><p>‘unsafe’ means any data conversions may be done.</p></li>
</ul>
</div></blockquote>
</dd>
<dt>subok<span class="classifier">bool, optional</span></dt><dd><p>If True, then sub-classes will be passed-through (default), otherwise
the returned array will be forced to be a base-class array.</p>
</dd>
<dt>copy<span class="classifier">bool, optional</span></dt><dd><p>By default, astype always returns a newly allocated array. If this
is set to false, and the <cite>dtype</cite>, <cite>order</cite>, and <cite>subok</cite>
requirements are satisfied, the input array is returned instead
of a copy.</p>
</dd>
</dl>
<dl class="simple">
<dt>arr_t<span class="classifier">ndarray</span></dt><dd><p>Unless <cite>copy</cite> is False and the other conditions for returning the input
array are satisfied (see description for <cite>copy</cite> input parameter), <cite>arr_t</cite>
is a new array of the same shape as the input array, with dtype, order
given by <cite>dtype</cite>, <cite>order</cite>.</p>
</dd>
</dl>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.17.0: </span>Casting between a simple data type and a structured one is possible only
for “unsafe” casting.  Casting to multiple fields is allowed, but
casting from multiple fields is not.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.9.0: </span>Casting from numeric to string types in ‘safe’ casting mode requires
that the string dtype length is long enough to store the max
integer/float value converted.</p>
</div>
<dl class="simple">
<dt>ComplexWarning</dt><dd><p>When casting from complex to float or int. To avoid this,
one should use <code class="docutils literal notranslate"><span class="pre">a.real.astype(t)</span></code>.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([1. ,  2. ,  2.5])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([1, 2, 2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.ndarray.base">
<code class="sig-name descname"><span class="pre">base</span></code><a class="headerlink" href="#numpy.ndarray.base" title="Permalink to this definition">¶</a></dt>
<dd><p>Base object if memory is from some other object.</p>
<p>The base of an array that owns its memory is None:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Slicing creates a view, whose memory is shared with x:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="n">x</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.byteswap">
<code class="sig-name descname"><span class="pre">byteswap</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.byteswap" title="Permalink to this definition">¶</a></dt>
<dd><p>Swap the bytes of the array elements</p>
<p>Toggle between low-endian and big-endian data representation by
returning a byteswapped array, optionally swapped in-place.
Arrays of byte-strings are not swapped. The real and imaginary
parts of a complex number are swapped individually.</p>
<dl class="simple">
<dt>inplace<span class="classifier">bool, optional</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, swap bytes in-place, default is <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>The byteswapped array. If <cite>inplace</cite> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, this is
a view to self.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">8755</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">hex</span><span class="p">,</span> <span class="n">A</span><span class="p">))</span>
<span class="go">[&#39;0x1&#39;, &#39;0x100&#39;, &#39;0x2233&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">byteswap</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([  256,     1, 13090], dtype=int16)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">hex</span><span class="p">,</span> <span class="n">A</span><span class="p">))</span>
<span class="go">[&#39;0x100&#39;, &#39;0x1&#39;, &#39;0x3322&#39;]</span>
</pre></div>
</div>
<p>Arrays of byte-strings are not swapped</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="sa">b</span><span class="s1">&#39;ceg&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;fac&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">byteswap</span><span class="p">()</span>
<span class="go">array([b&#39;ceg&#39;, b&#39;fac&#39;], dtype=&#39;|S3&#39;)</span>
</pre></div>
</div>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">A.newbyteorder().byteswap()</span></code> produces an array with the same values</dt><dd><p>but different representation in memory</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="go">array([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,</span>
<span class="go">       0, 0], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">()</span><span class="o">.</span><span class="n">byteswap</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([1, 2, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="go">array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,</span>
<span class="go">       0, 3], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.choose">
<code class="sig-name descname"><span class="pre">choose</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">choices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'raise'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.choose" title="Permalink to this definition">¶</a></dt>
<dd><p>Use an index array to construct a new array from a set of choices.</p>
<p>Refer to <cite>numpy.choose</cite> for full documentation.</p>
<p>numpy.choose : equivalent function</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.clip">
<code class="sig-name descname"><span class="pre">clip</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">min</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.clip" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array whose values are limited to <code class="docutils literal notranslate"><span class="pre">[min,</span> <span class="pre">max]</span></code>.
One of max or min must be given.</p>
<p>Refer to <cite>numpy.clip</cite> for full documentation.</p>
<p>numpy.clip : equivalent function</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.compress">
<code class="sig-name descname"><span class="pre">compress</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">condition</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.compress" title="Permalink to this definition">¶</a></dt>
<dd><p>Return selected slices of this array along given axis.</p>
<p>Refer to <cite>numpy.compress</cite> for full documentation.</p>
<p>numpy.compress : equivalent function</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.conj">
<code class="sig-name descname"><span class="pre">conj</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.conj" title="Permalink to this definition">¶</a></dt>
<dd><p>Complex-conjugate all elements.</p>
<p>Refer to <cite>numpy.conjugate</cite> for full documentation.</p>
<p>numpy.conjugate : equivalent function</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.conjugate">
<code class="sig-name descname"><span class="pre">conjugate</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the complex conjugate, element-wise.</p>
<p>Refer to <cite>numpy.conjugate</cite> for full documentation.</p>
<p>numpy.conjugate : equivalent function</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.copy">
<code class="sig-name descname"><span class="pre">copy</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'C'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the array.</p>
<dl class="simple">
<dt>order<span class="classifier">{‘C’, ‘F’, ‘A’, ‘K’}, optional</span></dt><dd><p>Controls the memory layout of the copy. ‘C’ means C-order,
‘F’ means F-order, ‘A’ means ‘F’ if <cite>a</cite> is Fortran contiguous,
‘C’ otherwise. ‘K’ means match the layout of <cite>a</cite> as closely
as possible. (Note that this function and <a class="reference internal" href="#numpy.copy" title="numpy.copy"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.copy()</span></code></a> are very
similar but have different default values for their order=
arguments, and this function always passes sub-classes through.)</p>
</dd>
</dl>
<p>numpy.copy : Similar function with different default behavior
numpy.copyto</p>
<p>This function is the preferred method for creating an array copy.  The
function <a class="reference internal" href="#numpy.copy" title="numpy.copy"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.copy()</span></code></a> is similar, but it defaults to using order ‘K’,
and will not pass sub-classes through by default.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]],</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 0, 0],</span>
<span class="go">       [0, 0, 0]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [4, 5, 6]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s1">&#39;C_CONTIGUOUS&#39;</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.ndarray.ctypes">
<code class="sig-name descname"><span class="pre">ctypes</span></code><a class="headerlink" href="#numpy.ndarray.ctypes" title="Permalink to this definition">¶</a></dt>
<dd><p>An object to simplify the interaction of the array with the ctypes
module.</p>
<p>This attribute creates an object that makes it easier to use arrays
when calling shared libraries with the ctypes module. The returned
object has, among others, data, shape, and strides attributes (see
Notes below) which themselves return ctypes objects that can be used
as arguments to a shared library.</p>
<p>None</p>
<dl class="simple">
<dt>c<span class="classifier">Python object</span></dt><dd><p>Possessing attributes data, shape, strides, etc.</p>
</dd>
</dl>
<p>numpy.ctypeslib</p>
<p>Below are the public attributes of this object which were documented
in “Guide to NumPy” (we have omitted undocumented public attributes,
as well as documented private attributes):</p>
<dl class="py attribute">
<dt>
<code class="sig-prename descclassname"><span class="pre">_ctypes.</span></code><code class="sig-name descname"><span class="pre">data</span></code></dt>
<dd><p>A pointer to the memory area of the array as a Python integer.
This memory area may contain data that is not aligned, or not in correct
byte-order. The memory area may not even be writeable. The array
flags and data-type of this array should be respected when passing this
attribute to arbitrary C-code to avoid trouble that can include Python
crashing. User Beware! The value of this attribute is exactly the same
as <code class="docutils literal notranslate"><span class="pre">self._array_interface_['data'][0]</span></code>.</p>
<p>Note that unlike <code class="docutils literal notranslate"><span class="pre">data_as</span></code>, a reference will not be kept to the array:
code like <code class="docutils literal notranslate"><span class="pre">ctypes.c_void_p((a</span> <span class="pre">+</span> <span class="pre">b).ctypes.data)</span></code> will result in a
pointer to a deallocated array, and should be spelt
<code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">+</span> <span class="pre">b).ctypes.data_as(ctypes.c_void_p)</span></code></p>
</dd></dl>

<dl class="py attribute">
<dt>
<code class="sig-prename descclassname"><span class="pre">_ctypes.</span></code><code class="sig-name descname"><span class="pre">shape</span></code></dt>
<dd><p>(c_intp*self.ndim): A ctypes array of length self.ndim where
the basetype is the C-integer corresponding to <code class="docutils literal notranslate"><span class="pre">dtype('p')</span></code> on this
platform. This base-type could be <cite>ctypes.c_int</cite>, <cite>ctypes.c_long</cite>, or
<cite>ctypes.c_longlong</cite> depending on the platform.
The c_intp type is defined accordingly in <cite>numpy.ctypeslib</cite>.
The ctypes array contains the shape of the underlying array.</p>
</dd></dl>

<dl class="py attribute">
<dt>
<code class="sig-prename descclassname"><span class="pre">_ctypes.</span></code><code class="sig-name descname"><span class="pre">strides</span></code></dt>
<dd><p>(c_intp*self.ndim): A ctypes array of length self.ndim where
the basetype is the same as for the shape attribute. This ctypes array
contains the strides information from the underlying array. This strides
information is important for showing how many bytes must be jumped to
get to the next element in the array.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-prename descclassname"><span class="pre">_ctypes.</span></code><code class="sig-name descname"><span class="pre">data_as</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Return the data pointer cast to a particular c-types object.
For example, calling <code class="docutils literal notranslate"><span class="pre">self._as_parameter_</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">self.data_as(ctypes.c_void_p)</span></code>. Perhaps you want to use the data as a
pointer to a ctypes array of floating-point data:
<code class="docutils literal notranslate"><span class="pre">self.data_as(ctypes.POINTER(ctypes.c_double))</span></code>.</p>
<p>The returned pointer will keep a reference to the array.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-prename descclassname"><span class="pre">_ctypes.</span></code><code class="sig-name descname"><span class="pre">shape_as</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Return the shape tuple as an array of some other c-types
type. For example: <code class="docutils literal notranslate"><span class="pre">self.shape_as(ctypes.c_short)</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-prename descclassname"><span class="pre">_ctypes.</span></code><code class="sig-name descname"><span class="pre">strides_as</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Return the strides tuple as an array of some other
c-types type. For example: <code class="docutils literal notranslate"><span class="pre">self.strides_as(ctypes.c_longlong)</span></code>.</p>
</dd></dl>

<p>If the ctypes module is not available, then the ctypes attribute
of array objects still returns something useful, but ctypes objects
are not returned and errors may be raised instead. In particular,
the object will still have the <code class="docutils literal notranslate"><span class="pre">as_parameter</span></code> attribute which will
return an integer equal to the data attribute.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ctypes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3]], dtype=int32)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data</span>
<span class="go">31962608 # may vary</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint32</span><span class="p">))</span>
<span class="go">&lt;__main__.LP_c_uint object at 0x7ff2fc1fc200&gt; # may vary</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint32</span><span class="p">))</span><span class="o">.</span><span class="n">contents</span>
<span class="go">c_uint(0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint64</span><span class="p">))</span><span class="o">.</span><span class="n">contents</span>
<span class="go">c_ulong(4294967296)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">shape</span>
<span class="go">&lt;numpy.core._internal.c_long_Array_2 object at 0x7ff2fc1fce60&gt; # may vary</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">strides</span>
<span class="go">&lt;numpy.core._internal.c_long_Array_2 object at 0x7ff2fc1ff320&gt; # may vary</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.cumprod">
<code class="sig-name descname"><span class="pre">cumprod</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.cumprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cumulative product of the elements along the given axis.</p>
<p>Refer to <cite>numpy.cumprod</cite> for full documentation.</p>
<p>numpy.cumprod : equivalent function</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.cumsum">
<code class="sig-name descname"><span class="pre">cumsum</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.cumsum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cumulative sum of the elements along the given axis.</p>
<p>Refer to <cite>numpy.cumsum</cite> for full documentation.</p>
<p>numpy.cumsum : equivalent function</p>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.ndarray.data">
<code class="sig-name descname"><span class="pre">data</span></code><a class="headerlink" href="#numpy.ndarray.data" title="Permalink to this definition">¶</a></dt>
<dd><p>Python buffer object pointing to the start of the array’s data.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.diagonal">
<code class="sig-name descname"><span class="pre">diagonal</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.diagonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return specified diagonals. In NumPy 1.9 the returned array is a
read-only view instead of a copy as in previous NumPy versions.  In
a future version the read-only restriction will be removed.</p>
<p>Refer to <a class="reference internal" href="#numpy.diagonal" title="numpy.diagonal"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.diagonal()</span></code></a> for full documentation.</p>
<p>numpy.diagonal : equivalent function</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.dot">
<code class="sig-name descname"><span class="pre">dot</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Dot product of two arrays.</p>
<p>Refer to <cite>numpy.dot</cite> for full documentation.</p>
<p>numpy.dot : equivalent function</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">array([[2.,  2.],</span>
<span class="go">       [2.,  2.]])</span>
</pre></div>
</div>
<p>This array method can be conveniently chained:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">array([[8.,  8.],</span>
<span class="go">       [8.,  8.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.ndarray.dtype">
<code class="sig-name descname"><span class="pre">dtype</span></code><a class="headerlink" href="#numpy.ndarray.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Data-type of the array’s elements.</p>
<p>None</p>
<p>d : numpy dtype object</p>
<p>numpy.dtype</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype(&#39;int32&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="go">&lt;type &#39;numpy.dtype&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.dump">
<code class="sig-name descname"><span class="pre">dump</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump a pickle of the array to the specified file.
The array can be read back with pickle.load or numpy.load.</p>
<dl>
<dt>file<span class="classifier">str or Path</span></dt><dd><p>A string naming the dump file.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.17.0: </span><cite>pathlib.Path</cite> objects are now accepted.</p>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.dumps">
<code class="sig-name descname"><span class="pre">dumps</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.dumps" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pickle of the array as a string.
pickle.loads or numpy.loads will convert the string back to an array.</p>
<p>None</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.fill">
<code class="sig-name descname"><span class="pre">fill</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.fill" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill the array with a scalar value.</p>
<dl class="simple">
<dt>value<span class="classifier">scalar</span></dt><dd><p>All elements of <cite>a</cite> will be assigned this value.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([0, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([1.,  1.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.ndarray.flags">
<code class="sig-name descname"><span class="pre">flags</span></code><a class="headerlink" href="#numpy.ndarray.flags" title="Permalink to this definition">¶</a></dt>
<dd><p>Information about the memory layout of the array.</p>
<dl class="simple">
<dt>C_CONTIGUOUS (C)</dt><dd><p>The data is in a single, C-style contiguous segment.</p>
</dd>
<dt>F_CONTIGUOUS (F)</dt><dd><p>The data is in a single, Fortran-style contiguous segment.</p>
</dd>
<dt>OWNDATA (O)</dt><dd><p>The array owns the memory it uses or borrows it from another object.</p>
</dd>
<dt>WRITEABLE (W)</dt><dd><p>The data area can be written to.  Setting this to False locks
the data, making it read-only.  A view (slice, etc.) inherits WRITEABLE
from its base array at creation time, but a view of a writeable
array may be subsequently locked while the base array remains writeable.
(The opposite is not true, in that a view of a locked array may not
be made writeable.  However, currently, locking a base object does not
lock any views that already reference it, so under that circumstance it
is possible to alter the contents of a locked array via a previously
created writeable view onto it.)  Attempting to change a non-writeable
array raises a RuntimeError exception.</p>
</dd>
<dt>ALIGNED (A)</dt><dd><p>The data and all elements are aligned appropriately for the hardware.</p>
</dd>
<dt>WRITEBACKIFCOPY (X)</dt><dd><p>This array is a copy of some other array. The C-API function
PyArray_ResolveWritebackIfCopy must be called before deallocating
to the base array will be updated with the contents of this array.</p>
</dd>
<dt>UPDATEIFCOPY (U)</dt><dd><p>(Deprecated, use WRITEBACKIFCOPY) This array is a copy of some other array.
When this array is
deallocated, the base array will be updated with the contents of
this array.</p>
</dd>
<dt>FNC</dt><dd><p>F_CONTIGUOUS and not C_CONTIGUOUS.</p>
</dd>
<dt>FORC</dt><dd><p>F_CONTIGUOUS or C_CONTIGUOUS (one-segment test).</p>
</dd>
<dt>BEHAVED (B)</dt><dd><p>ALIGNED and WRITEABLE.</p>
</dd>
<dt>CARRAY (CA)</dt><dd><p>BEHAVED and C_CONTIGUOUS.</p>
</dd>
<dt>FARRAY (FA)</dt><dd><p>BEHAVED and F_CONTIGUOUS and not C_CONTIGUOUS.</p>
</dd>
</dl>
<p>The <cite>flags</cite> object can be accessed dictionary-like (as in <code class="docutils literal notranslate"><span class="pre">a.flags['WRITEABLE']</span></code>),
or by using lowercased attribute names (as in <code class="docutils literal notranslate"><span class="pre">a.flags.writeable</span></code>). Short flag
names are only supported in dictionary access.</p>
<p>Only the WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED flags can be
changed by the user, via direct assignment to the attribute or dictionary
entry, or by calling <cite>ndarray.setflags</cite>.</p>
<p>The array flags cannot be set arbitrarily:</p>
<ul class="simple">
<li><p>UPDATEIFCOPY can only be set <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p>WRITEBACKIFCOPY can only be set <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p>ALIGNED can only be set <code class="docutils literal notranslate"><span class="pre">True</span></code> if the data is truly aligned.</p></li>
<li><p>WRITEABLE can only be set <code class="docutils literal notranslate"><span class="pre">True</span></code> if the array owns its own memory
or the ultimate owner of the memory exposes a writeable buffer
interface or is a string.</p></li>
</ul>
<p>Arrays can be both C-style and Fortran-style contiguous simultaneously.
This is clear for 1-dimensional arrays, but can also be true for higher
dimensional arrays.</p>
<p>Even for contiguous arrays a stride for a given dimension
<code class="docutils literal notranslate"><span class="pre">arr.strides[dim]</span></code> may be <em>arbitrary</em> if <code class="docutils literal notranslate"><span class="pre">arr.shape[dim]</span> <span class="pre">==</span> <span class="pre">1</span></code>
or the array has no elements.
It does <em>not</em> generally hold that <code class="docutils literal notranslate"><span class="pre">self.strides[-1]</span> <span class="pre">==</span> <span class="pre">self.itemsize</span></code>
for C-style contiguous arrays or <code class="docutils literal notranslate"><span class="pre">self.strides[0]</span> <span class="pre">==</span> <span class="pre">self.itemsize</span></code> for
Fortran-style contiguous arrays is true.</p>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.ndarray.flat">
<code class="sig-name descname"><span class="pre">flat</span></code><a class="headerlink" href="#numpy.ndarray.flat" title="Permalink to this definition">¶</a></dt>
<dd><p>A 1-D iterator over the array.</p>
<p>This is a <cite>numpy.flatiter</cite> instance, which acts similarly to, but is not
a subclass of, Python’s built-in iterator object.</p>
<p>flatten : Return a copy of the array collapsed into one dimension.</p>
<p>flatiter</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [4, 5, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">T</span>
<span class="go">array([[1, 4],</span>
<span class="go">       [2, 5],</span>
<span class="go">       [3, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">flat</span><span class="p">)</span>
<span class="go">&lt;class &#39;numpy.flatiter&#39;&gt;</span>
</pre></div>
</div>
<p>An assignment example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">flat</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">x</span>
<span class="go">array([[3, 3, 3],</span>
<span class="go">       [3, 3, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">flat</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">x</span>
<span class="go">array([[3, 1, 3],</span>
<span class="go">       [3, 1, 3]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.flatten">
<code class="sig-name descname"><span class="pre">flatten</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'C'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.flatten" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the array collapsed into one dimension.</p>
<dl class="simple">
<dt>order<span class="classifier">{‘C’, ‘F’, ‘A’, ‘K’}, optional</span></dt><dd><p>‘C’ means to flatten in row-major (C-style) order.
‘F’ means to flatten in column-major (Fortran-
style) order. ‘A’ means to flatten in column-major
order if <cite>a</cite> is Fortran <em>contiguous</em> in memory,
row-major order otherwise. ‘K’ means to flatten
<cite>a</cite> in the order the elements occur in memory.
The default is ‘C’.</p>
</dd>
</dl>
<dl class="simple">
<dt>y<span class="classifier">ndarray</span></dt><dd><p>A copy of the input array, flattened to one dimension.</p>
</dd>
</dl>
<p>ravel : Return a flattened array.
flat : A 1-D flat iterator over the array.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
<span class="go">array([1, 2, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
<span class="go">array([1, 3, 2, 4])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.getfield">
<code class="sig-name descname"><span class="pre">getfield</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dtype</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.getfield" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a field of the given array as a certain type.</p>
<p>A field is a view of the array data with a given data-type. The values in
the view are determined by the given type and the offset into the current
array in bytes. The offset needs to be such that the view dtype fits in the
array dtype; for example an array of dtype complex128 has 16-byte elements.
If taking a view with a 32-bit integer (4 bytes), the offset needs to be
between 0 and 12 bytes.</p>
<dl class="simple">
<dt>dtype<span class="classifier">str or dtype</span></dt><dd><p>The data type of the view. The dtype size of the view can not be larger
than that of the array itself.</p>
</dd>
<dt>offset<span class="classifier">int</span></dt><dd><p>Number of bytes to skip before beginning the element view.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mf">1.</span><span class="o">+</span><span class="mf">1.</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="mf">4.</span><span class="n">j</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[1.+1.j,  0.+0.j],</span>
<span class="go">       [0.+0.j,  2.+4.j]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">getfield</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="go">array([[1.,  0.],</span>
<span class="go">       [0.,  2.]])</span>
</pre></div>
</div>
<p>By choosing an offset of 8 bytes we can select the complex part of the
array for our view:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">getfield</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="go">array([[1.,  0.],</span>
<span class="go">       [0.,  4.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.ndarray.imag">
<code class="sig-name descname"><span class="pre">imag</span></code><a class="headerlink" href="#numpy.ndarray.imag" title="Permalink to this definition">¶</a></dt>
<dd><p>The imaginary part of the array.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">([</span><span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">imag</span>
<span class="go">array([ 0.        ,  0.70710678])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">imag</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype(&#39;float64&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.item">
<code class="sig-name descname"><span class="pre">item</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.item" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy an element of an array to a standard Python scalar and return it.</p>
<p>*args : Arguments (variable number and type)</p>
<blockquote>
<div><ul class="simple">
<li><p>none: in this case, the method only works for arrays
with one element (<cite>a.size == 1</cite>), which element is
copied into a standard Python scalar object and returned.</p></li>
<li><p>int_type: this argument is interpreted as a flat index into
the array, specifying which element to copy and return.</p></li>
<li><p>tuple of int_types: functions as does a single int_type argument,
except that the argument is interpreted as an nd-index into the
array.</p></li>
</ul>
</div></blockquote>
<dl class="simple">
<dt>z<span class="classifier">Standard Python scalar object</span></dt><dd><p>A copy of the specified element of the array as a suitable
Python scalar</p>
</dd>
</dl>
<p>When the data type of <cite>a</cite> is longdouble or clongdouble, item() returns
a scalar array object because there is no available Python scalar that
would not lose information. Void arrays return a buffer object for item(),
unless fields are defined, in which case a tuple is returned.</p>
<p><cite>item</cite> is very similar to a[args], except, instead of an array scalar,
a standard Python scalar is returned. This can be useful for speeding up
access to elements of the array and doing arithmetic on elements of the
array using Python’s optimized math.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[2, 2, 6],</span>
<span class="go">       [1, 3, 6],</span>
<span class="go">       [1, 0, 1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">item</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">item</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.itemset">
<code class="sig-name descname"><span class="pre">itemset</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.itemset" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert scalar into an array (scalar is cast to array’s dtype, if possible)</p>
<p>There must be at least 1 argument, and define the last argument
as <em>item</em>.  Then, <code class="docutils literal notranslate"><span class="pre">a.itemset(*args)</span></code> is equivalent to but faster
than <code class="docutils literal notranslate"><span class="pre">a[args]</span> <span class="pre">=</span> <span class="pre">item</span></code>.  The item should be a scalar value and <cite>args</cite>
must select a single item in the array <cite>a</cite>.</p>
<dl class="simple">
<dt>*args<span class="classifier">Arguments</span></dt><dd><p>If one argument: a scalar, only used in case <cite>a</cite> is of size 1.
If two arguments: the last argument is the value to be set
and must be a scalar, the first argument specifies a single array
element location. It is either an int or a tuple.</p>
</dd>
</dl>
<p>Compared to indexing syntax, <cite>itemset</cite> provides some speed increase
for placing a scalar into a particular location in an <cite>ndarray</cite>,
if you must do this.  However, generally this is discouraged:
among other problems, it complicates the appearance of the code.
Also, when using <cite>itemset</cite> (and <cite>item</cite>) inside a loop, be sure
to assign the methods to a local variable to avoid the attribute
look-up at each loop iteration.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[2, 2, 6],</span>
<span class="go">       [1, 3, 6],</span>
<span class="go">       [1, 0, 1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">itemset</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">itemset</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">9</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[2, 2, 6],</span>
<span class="go">       [1, 0, 6],</span>
<span class="go">       [1, 0, 9]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.ndarray.itemsize">
<code class="sig-name descname"><span class="pre">itemsize</span></code><a class="headerlink" href="#numpy.ndarray.itemsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Length of one array element in bytes.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">16</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.max">
<code class="sig-name descname"><span class="pre">max</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">axis=None</span></em>, <em class="sig-param"><span class="pre">out=None</span></em>, <em class="sig-param"><span class="pre">keepdims=False</span></em>, <em class="sig-param"><span class="pre">initial=&lt;no</span> <span class="pre">value&gt;</span></em>, <em class="sig-param"><span class="pre">where=True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum along a given axis.</p>
<p>Refer to <cite>numpy.amax</cite> for full documentation.</p>
<p>numpy.amax : equivalent function</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.mean">
<code class="sig-name descname"><span class="pre">mean</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keepdims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">where</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the average of the array elements along given axis.</p>
<p>Refer to <cite>numpy.mean</cite> for full documentation.</p>
<p>numpy.mean : equivalent function</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.min">
<code class="sig-name descname"><span class="pre">min</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">axis=None</span></em>, <em class="sig-param"><span class="pre">out=None</span></em>, <em class="sig-param"><span class="pre">keepdims=False</span></em>, <em class="sig-param"><span class="pre">initial=&lt;no</span> <span class="pre">value&gt;</span></em>, <em class="sig-param"><span class="pre">where=True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the minimum along a given axis.</p>
<p>Refer to <cite>numpy.amin</cite> for full documentation.</p>
<p>numpy.amin : equivalent function</p>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.ndarray.nbytes">
<code class="sig-name descname"><span class="pre">nbytes</span></code><a class="headerlink" href="#numpy.ndarray.nbytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Total bytes consumed by the elements of the array.</p>
<p>Does not include memory consumed by non-element attributes of the
array object.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">480</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">480</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.ndarray.ndim">
<code class="sig-name descname"><span class="pre">ndim</span></code><a class="headerlink" href="#numpy.ndarray.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of array dimensions.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">ndim</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.newbyteorder">
<code class="sig-name descname"><span class="pre">newbyteorder</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'S'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.newbyteorder" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the array with the same data viewed with a different byte order.</p>
<p>Equivalent to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">arr</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">newbytorder</span><span class="p">(</span><span class="n">new_order</span><span class="p">))</span>
</pre></div>
</div>
<p>Changes are also made in all fields and sub-arrays of the array data
type.</p>
<dl>
<dt>new_order<span class="classifier">string, optional</span></dt><dd><p>Byte order to force; a value from the byte order specifications
below. <cite>new_order</cite> codes can be any of:</p>
<ul class="simple">
<li><p>‘S’ - swap dtype from current to opposite endian</p></li>
<li><p>{‘&lt;’, ‘little’} - little endian</p></li>
<li><p>{‘&gt;’, ‘big’} - big endian</p></li>
<li><p>‘=’ - native order, equivalent to <cite>sys.byteorder</cite></p></li>
<li><p>{‘|’, ‘I’} - ignore (no change to byte order)</p></li>
</ul>
<p>The default value (‘S’) results in swapping the current
byte order.</p>
</dd>
</dl>
<dl class="simple">
<dt>new_arr<span class="classifier">array</span></dt><dd><p>New array object with the dtype reflecting given change to the
byte order.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.nonzero">
<code class="sig-name descname"><span class="pre">nonzero</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.nonzero" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices of the elements that are non-zero.</p>
<p>Refer to <cite>numpy.nonzero</cite> for full documentation.</p>
<p>numpy.nonzero : equivalent function</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.partition">
<code class="sig-name descname"><span class="pre">partition</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'introselect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.partition" title="Permalink to this definition">¶</a></dt>
<dd><p>Rearranges the elements in the array in such a way that the value of the
element in kth position is in the position it would be in a sorted array.
All elements smaller than the kth element are moved before this element and
all equal or greater are moved behind it. The ordering of the elements in
the two partitions is undefined.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
<dl class="simple">
<dt>kth<span class="classifier">int or sequence of ints</span></dt><dd><p>Element index to partition by. The kth element value will be in its
final sorted position and all smaller elements will be moved before it
and all equal or greater elements behind it.
The order of all elements in the partitions is undefined.
If provided with a sequence of kth it will partition all elements
indexed by kth of them into their sorted position at once.</p>
</dd>
<dt>axis<span class="classifier">int, optional</span></dt><dd><p>Axis along which to sort. Default is -1, which means sort along the
last axis.</p>
</dd>
<dt>kind<span class="classifier">{‘introselect’}, optional</span></dt><dd><p>Selection algorithm. Default is ‘introselect’.</p>
</dd>
<dt>order<span class="classifier">str or list of str, optional</span></dt><dd><p>When <cite>a</cite> is an array with fields defined, this argument specifies
which fields to compare first, second, etc. A single field can
be specified as a string, and not all fields need to be specified,
but unspecified fields will still be used, in the order in which
they come up in the dtype, to break ties.</p>
</dd>
</dl>
<p>numpy.partition : Return a parititioned copy of an array.
argpartition : Indirect partition.
sort : Full sort.</p>
<p>See <code class="docutils literal notranslate"><span class="pre">np.partition</span></code> for notes on the different algorithms.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([2, 1, 3, 4])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">partition</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([1, 2, 3, 4])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.prod">
<code class="sig-name descname"><span class="pre">prod</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keepdims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">where</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.prod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the product of the array elements over the given axis</p>
<p>Refer to <cite>numpy.prod</cite> for full documentation.</p>
<p>numpy.prod : equivalent function</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.ptp">
<code class="sig-name descname"><span class="pre">ptp</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keepdims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.ptp" title="Permalink to this definition">¶</a></dt>
<dd><p>Peak to peak (maximum - minimum) value along a given axis.</p>
<p>Refer to <cite>numpy.ptp</cite> for full documentation.</p>
<p>numpy.ptp : equivalent function</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.put">
<code class="sig-name descname"><span class="pre">put</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'raise'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.put" title="Permalink to this definition">¶</a></dt>
<dd><p>Set <code class="docutils literal notranslate"><span class="pre">a.flat[n]</span> <span class="pre">=</span> <span class="pre">values[n]</span></code> for all <cite>n</cite> in indices.</p>
<p>Refer to <cite>numpy.put</cite> for full documentation.</p>
<p>numpy.put : equivalent function</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.ravel">
<code class="sig-name descname"><span class="pre">ravel</span></code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="pre">order</span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.ravel" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a flattened array.</p>
<p>Refer to <cite>numpy.ravel</cite> for full documentation.</p>
<p>numpy.ravel : equivalent function</p>
<p>ndarray.flat : a flat iterator on the array.</p>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.ndarray.real">
<code class="sig-name descname"><span class="pre">real</span></code><a class="headerlink" href="#numpy.ndarray.real" title="Permalink to this definition">¶</a></dt>
<dd><p>The real part of the array.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">([</span><span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">real</span>
<span class="go">array([ 1.        ,  0.70710678])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">real</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype(&#39;float64&#39;)</span>
</pre></div>
</div>
<p>numpy.real : equivalent function</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.repeat">
<code class="sig-name descname"><span class="pre">repeat</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">repeats</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.repeat" title="Permalink to this definition">¶</a></dt>
<dd><p>Repeat elements of an array.</p>
<p>Refer to <cite>numpy.repeat</cite> for full documentation.</p>
<p>numpy.repeat : equivalent function</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.reshape">
<code class="sig-name descname"><span class="pre">reshape</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'C'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.reshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array containing the same data with a new shape.</p>
<p>Refer to <cite>numpy.reshape</cite> for full documentation.</p>
<p>numpy.reshape : equivalent function</p>
<p>Unlike the free function <cite>numpy.reshape</cite>, this method on <cite>ndarray</cite> allows
the elements of the shape parameter to be passed in as separate arguments.
For example, <code class="docutils literal notranslate"><span class="pre">a.reshape(10,</span> <span class="pre">11)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">a.reshape((10,</span> <span class="pre">11))</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.resize">
<code class="sig-name descname"><span class="pre">resize</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refcheck</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.resize" title="Permalink to this definition">¶</a></dt>
<dd><p>Change shape and size of array in-place.</p>
<dl>
<dt>new_shape<span class="classifier">tuple of ints, or <cite>n</cite> ints</span></dt><dd><p>Shape of resized array.</p>
</dd>
<dt>refcheck<span class="classifier">bool, optional</span></dt><dd><p>If False, reference count will not be checked. Default is True.</p>
</dd>
</dl>
<p>None</p>
<dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>a</cite> does not own its own data or references or views to it exist,
and the data memory must be changed.
PyPy only: will always raise if the data memory must be changed, since
there is no reliable way to determine if references or views to it
exist.</p>
</dd>
<dt>SystemError</dt><dd><p>If the <cite>order</cite> keyword argument is specified. This behaviour is a
bug in NumPy.</p>
</dd>
</dl>
<p>resize : Return a new array with the specified shape.</p>
<p>This reallocates space for the data area if necessary.</p>
<p>Only contiguous arrays (data elements consecutive in memory) can be
resized.</p>
<p>The purpose of the reference count check is to make sure you
do not use this array as a buffer for another Python object and then
reallocate the memory. However, reference counts can increase in
other ways so if you are sure that you have not shared the memory
for this array with another Python object, then you may safely set
<cite>refcheck</cite> to False.</p>
<p>Shrinking an array: array is flattened (in the order that the data are
stored in memory), resized, and reshaped:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]],</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">resize</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0],</span>
<span class="go">       [1]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]],</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">resize</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0],</span>
<span class="go">       [2]])</span>
</pre></div>
</div>
<p>Enlarging an array: as above, but missing entries are filled with zeros:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"># new_shape parameter doesn&#39;t have to be a tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 0, 0]])</span>
</pre></div>
</div>
<p>Referencing an array prevents resizing…</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">resize</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">cannot resize an array that references or is referenced ...</span>
</pre></div>
</div>
<p>Unless <cite>refcheck</cite> is False:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">resize</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">refcheck</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">array([[0]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.round">
<code class="sig-name descname"><span class="pre">round</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">decimals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.round" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <cite>a</cite> with each element rounded to the given number of decimals.</p>
<p>Refer to <cite>numpy.around</cite> for full documentation.</p>
<p>numpy.around : equivalent function</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.searchsorted">
<code class="sig-name descname"><span class="pre">searchsorted</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">side</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'left'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sorter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.searchsorted" title="Permalink to this definition">¶</a></dt>
<dd><p>Find indices where elements of v should be inserted in a to maintain order.</p>
<p>For full documentation, see <cite>numpy.searchsorted</cite></p>
<p>numpy.searchsorted : equivalent function</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.setfield">
<code class="sig-name descname"><span class="pre">setfield</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">val</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.setfield" title="Permalink to this definition">¶</a></dt>
<dd><p>Put a value into a specified place in a field defined by a data-type.</p>
<p>Place <cite>val</cite> into <cite>a</cite>’s field defined by <cite>dtype</cite> and beginning <cite>offset</cite>
bytes into the field.</p>
<dl class="simple">
<dt>val<span class="classifier">object</span></dt><dd><p>Value to be placed in field.</p>
</dd>
<dt>dtype<span class="classifier">dtype object</span></dt><dd><p>Data-type of the field in which to place <cite>val</cite>.</p>
</dd>
<dt>offset<span class="classifier">int, optional</span></dt><dd><p>The number of bytes into the field at which to place <cite>val</cite>.</p>
</dd>
</dl>
<p>None</p>
<p>getfield</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">getfield</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="go">array([[1.,  0.,  0.],</span>
<span class="go">       [0.,  1.,  0.],</span>
<span class="go">       [0.,  0.,  1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">setfield</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">getfield</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="go">array([[3, 3, 3],</span>
<span class="go">       [3, 3, 3],</span>
<span class="go">       [3, 3, 3]], dtype=int32)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[1.0e+000, 1.5e-323, 1.5e-323],</span>
<span class="go">       [1.5e-323, 1.0e+000, 1.5e-323],</span>
<span class="go">       [1.5e-323, 1.5e-323, 1.0e+000]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">setfield</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[1.,  0.,  0.],</span>
<span class="go">       [0.,  1.,  0.],</span>
<span class="go">       [0.,  0.,  1.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.setflags">
<code class="sig-name descname"><span class="pre">setflags</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">write</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">align</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">uic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.setflags" title="Permalink to this definition">¶</a></dt>
<dd><p>Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY),
respectively.</p>
<p>These Boolean-valued flags affect how numpy interprets the memory
area used by <cite>a</cite> (see Notes below). The ALIGNED flag can only
be set to True if the data is actually aligned according to the type.
The WRITEBACKIFCOPY and (deprecated) UPDATEIFCOPY flags can never be set
to True. The flag WRITEABLE can only be set to True if the array owns its
own memory, or the ultimate owner of the memory exposes a writeable buffer
interface, or is a string. (The exception for string is made so that
unpickling can be done without copying memory.)</p>
<dl class="simple">
<dt>write<span class="classifier">bool, optional</span></dt><dd><p>Describes whether or not <cite>a</cite> can be written to.</p>
</dd>
<dt>align<span class="classifier">bool, optional</span></dt><dd><p>Describes whether or not <cite>a</cite> is aligned properly for its type.</p>
</dd>
<dt>uic<span class="classifier">bool, optional</span></dt><dd><p>Describes whether or not <cite>a</cite> is a copy of another “base” array.</p>
</dd>
</dl>
<p>Array flags provide information about how the memory area used
for the array is to be interpreted. There are 7 Boolean flags
in use, only four of which can be changed by the user:
WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED.</p>
<p>WRITEABLE (W) the data area can be written to;</p>
<p>ALIGNED (A) the data and strides are aligned appropriately for the hardware
(as determined by the compiler);</p>
<p>UPDATEIFCOPY (U) (deprecated), replaced by WRITEBACKIFCOPY;</p>
<p>WRITEBACKIFCOPY (X) this array is a copy of some other array (referenced
by .base). When the C-API function PyArray_ResolveWritebackIfCopy is
called, the base array will be updated with the contents of this array.</p>
<p>All flags can be accessed using the single (upper case) letter as well
as the full name.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([[3, 1, 7],</span>
<span class="go">       [2, 0, 0],</span>
<span class="go">       [8, 5, 9]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">flags</span>
<span class="go">  C_CONTIGUOUS : True</span>
<span class="go">  F_CONTIGUOUS : False</span>
<span class="go">  OWNDATA : True</span>
<span class="go">  WRITEABLE : True</span>
<span class="go">  ALIGNED : True</span>
<span class="go">  WRITEBACKIFCOPY : False</span>
<span class="go">  UPDATEIFCOPY : False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">setflags</span><span class="p">(</span><span class="n">write</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">flags</span>
<span class="go">  C_CONTIGUOUS : True</span>
<span class="go">  F_CONTIGUOUS : False</span>
<span class="go">  OWNDATA : True</span>
<span class="go">  WRITEABLE : False</span>
<span class="go">  ALIGNED : False</span>
<span class="go">  WRITEBACKIFCOPY : False</span>
<span class="go">  UPDATEIFCOPY : False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">setflags</span><span class="p">(</span><span class="n">uic</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">cannot set WRITEBACKIFCOPY flag to True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.ndarray.shape">
<code class="sig-name descname"><span class="pre">shape</span></code><a class="headerlink" href="#numpy.ndarray.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Tuple of array dimensions.</p>
<p>The shape property is usually used to get the current shape of an array,
but may also be used to reshape the array in-place by assigning a tuple of
array dimensions to it.  As with <cite>numpy.reshape</cite>, one of the new shape
dimensions can be -1, in which case its value is inferred from the size of
the array and the remaining dimensions. Reshaping an array in-place will
fail if a copy is required.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(4,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 3, 4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">total size of new array must be unchanged</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">))[::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">AttributeError</span>: <span class="n">Incompatible shape for in-place modification. Use</span>
<span class="go">`.reshape()` to make a copy with the desired shape.</span>
</pre></div>
</div>
<p>numpy.reshape : similar function
ndarray.reshape : similar method</p>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.ndarray.size">
<code class="sig-name descname"><span class="pre">size</span></code><a class="headerlink" href="#numpy.ndarray.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of elements in the array.</p>
<p>Equal to <code class="docutils literal notranslate"><span class="pre">np.prod(a.shape)</span></code>, i.e., the product of the array’s
dimensions.</p>
<p><cite>a.size</cite> returns a standard arbitrary precision Python integer. This
may not be the case with other methods of obtaining the same value
(like the suggested <code class="docutils literal notranslate"><span class="pre">np.prod(a.shape)</span></code>, which returns an instance
of <code class="docutils literal notranslate"><span class="pre">np.int_</span></code>), and may be relevant if the value is used further in
calculations that may overflow a fixed size integer type.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">size</span>
<span class="go">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">30</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.sort">
<code class="sig-name descname"><span class="pre">sort</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort an array in-place. Refer to <cite>numpy.sort</cite> for full documentation.</p>
<dl>
<dt>axis<span class="classifier">int, optional</span></dt><dd><p>Axis along which to sort. Default is -1, which means sort along the
last axis.</p>
</dd>
<dt>kind<span class="classifier">{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional</span></dt><dd><p>Sorting algorithm. The default is ‘quicksort’. Note that both ‘stable’
and ‘mergesort’ use timsort under the covers and, in general, the
actual implementation will vary with datatype. The ‘mergesort’ option
is retained for backwards compatibility.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.15.0: </span>The ‘stable’ option was added.</p>
</div>
</dd>
<dt>order<span class="classifier">str or list of str, optional</span></dt><dd><p>When <cite>a</cite> is an array with fields defined, this argument specifies
which fields to compare first, second, etc.  A single field can
be specified as a string, and not all fields need be specified,
but unspecified fields will still be used, in the order in which
they come up in the dtype, to break ties.</p>
</dd>
</dl>
<p>numpy.sort : Return a sorted copy of an array.
numpy.argsort : Indirect sort.
numpy.lexsort : Indirect stable sort on multiple keys.
numpy.searchsorted : Find elements in sorted array.
numpy.partition: Partial sort.</p>
<p>See <cite>numpy.sort</cite> for notes on the different sorting algorithms.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[1, 4],</span>
<span class="go">       [1, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[1, 3],</span>
<span class="go">       [1, 4]])</span>
</pre></div>
</div>
<p>Use the <cite>order</cite> keyword to specify a field to use when sorting a
structured array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;S1&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([(b&#39;c&#39;, 1), (b&#39;a&#39;, 2)],</span>
<span class="go">      dtype=[(&#39;x&#39;, &#39;S1&#39;), (&#39;y&#39;, &#39;&lt;i8&#39;)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.squeeze">
<code class="sig-name descname"><span class="pre">squeeze</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove axes of length one from <cite>a</cite>.</p>
<p>Refer to <cite>numpy.squeeze</cite> for full documentation.</p>
<p>numpy.squeeze : equivalent function</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.std">
<code class="sig-name descname"><span class="pre">std</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ddof</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keepdims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">where</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.std" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the standard deviation of the array elements along given axis.</p>
<p>Refer to <cite>numpy.std</cite> for full documentation.</p>
<p>numpy.std : equivalent function</p>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.ndarray.strides">
<code class="sig-name descname"><span class="pre">strides</span></code><a class="headerlink" href="#numpy.ndarray.strides" title="Permalink to this definition">¶</a></dt>
<dd><p>Tuple of bytes to step in each dimension when traversing an array.</p>
<p>The byte offset of element <code class="docutils literal notranslate"><span class="pre">(i[0],</span> <span class="pre">i[1],</span> <span class="pre">...,</span> <span class="pre">i[n])</span></code> in an array <cite>a</cite>
is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">offset</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span><span class="o">.</span><span class="n">strides</span><span class="p">)</span>
</pre></div>
</div>
<p>A more detailed explanation of strides can be found in the
“ndarray.rst” file in the NumPy reference guide.</p>
<p>Imagine an array of 32-bit integers (each 4 bytes):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
</pre></div>
</div>
<p>This array is stored in memory as 40 bytes, one after the other
(known as a contiguous block of memory).  The strides of an array tell
us how many bytes we have to skip in memory to move to the next position
along a certain axis.  For example, we have to skip 4 bytes (1 value) to
move to the next column, but 20 bytes (5 values) to get to the same
position in the next row.  As such, the strides for the array <cite>x</cite> will be
<code class="docutils literal notranslate"><span class="pre">(20,</span> <span class="pre">4)</span></code>.</p>
<p>numpy.lib.stride_tricks.as_strided</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">3</span><span class="o">*</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([[[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]],</span>
<span class="go">       [[12, 13, 14, 15],</span>
<span class="go">        [16, 17, 18, 19],</span>
<span class="go">        [20, 21, 22, 23]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">strides</span>
<span class="go">(48, 16, 4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="go">17</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">offset</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">strides</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">offset</span><span class="o">/</span><span class="n">y</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">17</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="mi">6</span><span class="o">*</span><span class="mi">7</span><span class="o">*</span><span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">strides</span>
<span class="go">(32, 4, 224, 1344)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">offset</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">strides</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="go">813</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">offset</span> <span class="o">/</span> <span class="n">x</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">813</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.sum">
<code class="sig-name descname"><span class="pre">sum</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keepdims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">where</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum of the array elements over the given axis.</p>
<p>Refer to <cite>numpy.sum</cite> for full documentation.</p>
<p>numpy.sum : equivalent function</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.swapaxes">
<code class="sig-name descname"><span class="pre">swapaxes</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.swapaxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a view of the array with <cite>axis1</cite> and <cite>axis2</cite> interchanged.</p>
<p>Refer to <cite>numpy.swapaxes</cite> for full documentation.</p>
<p>numpy.swapaxes : equivalent function</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.take">
<code class="sig-name descname"><span class="pre">take</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'raise'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.take" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array formed from the elements of <cite>a</cite> at the given indices.</p>
<p>Refer to <cite>numpy.take</cite> for full documentation.</p>
<p>numpy.take : equivalent function</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.tobytes">
<code class="sig-name descname"><span class="pre">tobytes</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'C'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.tobytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct Python bytes containing the raw data bytes in the array.</p>
<p>Constructs Python bytes showing a copy of the raw contents of
data memory. The bytes object is produced in C-order by default.
This behavior is controlled by the <code class="docutils literal notranslate"><span class="pre">order</span></code> parameter.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.9.0.</span></p>
</div>
<dl class="simple">
<dt>order<span class="classifier">{‘C’, ‘F’, ‘A’}, optional</span></dt><dd><p>Controls the memory layout of the bytes object. ‘C’ means C-order,
‘F’ means F-order, ‘A’ (short for <em>Any</em>) means ‘F’ if <cite>a</cite> is
Fortran contiguous, ‘C’ otherwise. Default is ‘C’.</p>
</dd>
</dl>
<dl class="simple">
<dt>s<span class="classifier">bytes</span></dt><dd><p>Python bytes exhibiting a copy of <cite>a</cite>’s raw data.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;&lt;u2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">b&#39;\x00\x00\x01\x00\x02\x00\x03\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">tobytes</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">tobytes</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
<span class="go">b&#39;\x00\x00\x02\x00\x01\x00\x03\x00&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.tofile">
<code class="sig-name descname"><span class="pre">tofile</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'%s'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.tofile" title="Permalink to this definition">¶</a></dt>
<dd><p>Write array to a file as text or binary (default).</p>
<p>Data is always written in ‘C’ order, independent of the order of <cite>a</cite>.
The data produced by this method can be recovered using the function
fromfile().</p>
<dl>
<dt>fid<span class="classifier">file or str or Path</span></dt><dd><p>An open file object, or a string containing a filename.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.17.0: </span><cite>pathlib.Path</cite> objects are now accepted.</p>
</div>
</dd>
<dt>sep<span class="classifier">str</span></dt><dd><p>Separator between array items for text output.
If “” (empty), a binary file is written, equivalent to
<code class="docutils literal notranslate"><span class="pre">file.write(a.tobytes())</span></code>.</p>
</dd>
<dt>format<span class="classifier">str</span></dt><dd><p>Format string for text file output.
Each entry in the array is formatted to text by first converting
it to the closest Python type, and then using “format” % item.</p>
</dd>
</dl>
<p>This is a convenience function for quick storage of array data.
Information on endianness and precision is lost, so this method is not a
good choice for files intended to archive data or transport data between
machines with different endianness. Some of these problems can be overcome
by outputting the data as text files, at the expense of speed and file
size.</p>
<p>When fid is a file object, array contents are directly written to the
file, bypassing the file object’s <code class="docutils literal notranslate"><span class="pre">write</span></code> method. As a result, tofile
cannot be used with files objects supporting compression (e.g., GzipFile)
or file-like objects that do not support <code class="docutils literal notranslate"><span class="pre">fileno()</span></code> (e.g., BytesIO).</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.tolist">
<code class="sig-name descname"><span class="pre">tolist</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.tolist" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the array as an <code class="docutils literal notranslate"><span class="pre">a.ndim</span></code>-levels deep nested list of Python scalars.</p>
<p>Return a copy of the array data as a (nested) Python list.
Data items are converted to the nearest compatible builtin Python type, via
the <cite>~numpy.ndarray.item</cite> function.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">a.ndim</span></code> is 0, then since the depth of the nested list is 0, it will
not be a list at all, but a simple Python scalar.</p>
<p>none</p>
<dl class="simple">
<dt>y<span class="classifier">object, or list of object, or list of list of object, or …</span></dt><dd><p>The possibly nested list of array elements.</p>
</dd>
</dl>
<p>The array may be recreated via <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">np.array(a.tolist())</span></code>, although this
may sometimes lose precision.</p>
<p>For a 1D array, <code class="docutils literal notranslate"><span class="pre">a.tolist()</span></code> is almost the same as <code class="docutils literal notranslate"><span class="pre">list(a)</span></code>,
except that <code class="docutils literal notranslate"><span class="pre">tolist</span></code> changes numpy scalars to Python scalars:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_list</span>
<span class="go">[1, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">a_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&lt;class &#39;numpy.uint32&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_tolist</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_tolist</span>
<span class="go">[1, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">a_tolist</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&lt;class &#39;int&#39;&gt;</span>
</pre></div>
</div>
<p>Additionally, for a 2D array, <code class="docutils literal notranslate"><span class="pre">tolist</span></code> applies recursively:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">[array([1, 2]), array([3, 4])]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[[1, 2], [3, 4]]</span>
</pre></div>
</div>
<p>The base case for this recursion is a 0D array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">iteration over a 0-d array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.tostring">
<code class="sig-name descname"><span class="pre">tostring</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'C'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.tostring" title="Permalink to this definition">¶</a></dt>
<dd><p>A compatibility alias for <cite>tobytes</cite>, with exactly the same behavior.</p>
<p>Despite its name, it returns <cite>bytes</cite> not <cite>str</cite>s.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 1.19.0.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.trace">
<code class="sig-name descname"><span class="pre">trace</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum along diagonals of the array.</p>
<p>Refer to <cite>numpy.trace</cite> for full documentation.</p>
<p>numpy.trace : equivalent function</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.transpose">
<code class="sig-name descname"><span class="pre">transpose</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">axes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a view of the array with axes transposed.</p>
<p>For a 1-D array this has no effect, as a transposed vector is simply the
same vector. To convert a 1-D array into a 2D column vector, an additional
dimension must be added. <cite>np.atleast2d(a).T</cite> achieves this, as does
<cite>a[:, np.newaxis]</cite>.
For a 2-D array, this is a standard matrix transpose.
For an n-D array, if axes are given, their order indicates how the
axes are permuted (see Examples). If axes are not provided and
<code class="docutils literal notranslate"><span class="pre">a.shape</span> <span class="pre">=</span> <span class="pre">(i[0],</span> <span class="pre">i[1],</span> <span class="pre">...</span> <span class="pre">i[n-2],</span> <span class="pre">i[n-1])</span></code>, then
<code class="docutils literal notranslate"><span class="pre">a.transpose().shape</span> <span class="pre">=</span> <span class="pre">(i[n-1],</span> <span class="pre">i[n-2],</span> <span class="pre">...</span> <span class="pre">i[1],</span> <span class="pre">i[0])</span></code>.</p>
<p>axes : None, tuple of ints, or <cite>n</cite> ints</p>
<blockquote>
<div><ul class="simple">
<li><p>None or no argument: reverses the order of the axes.</p></li>
<li><p>tuple of ints: <cite>i</cite> in the <cite>j</cite>-th place in the tuple means <cite>a</cite>’s
<cite>i</cite>-th axis becomes <cite>a.transpose()</cite>’s <cite>j</cite>-th axis.</p></li>
<li><p><cite>n</cite> ints: same as an n-tuple of the same ints (this form is
intended simply as a “convenience” alternative to the tuple form)</p></li>
</ul>
</div></blockquote>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>View of <cite>a</cite>, with axes suitably permuted.</p>
</dd>
</dl>
<p>transpose : Equivalent function
ndarray.T : Array property returning the array transposed.
ndarray.reshape : Give a new shape to an array without changing its data.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
<span class="go">array([[1, 3],</span>
<span class="go">       [2, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">array([[1, 3],</span>
<span class="go">       [2, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">array([[1, 3],</span>
<span class="go">       [2, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.var">
<code class="sig-name descname"><span class="pre">var</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ddof</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keepdims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">where</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.var" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the variance of the array elements, along given axis.</p>
<p>Refer to <cite>numpy.var</cite> for full documentation.</p>
<p>numpy.var : equivalent function</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.ndarray.view">
<code class="sig-name descname"><span class="pre">view</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">[dtype][,</span> <span class="pre">type]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.view" title="Permalink to this definition">¶</a></dt>
<dd><p>New view of array with the same data.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Passing None for <code class="docutils literal notranslate"><span class="pre">dtype</span></code> is different from omitting the parameter,
since the former invokes <code class="docutils literal notranslate"><span class="pre">dtype(None)</span></code> which is an alias for
<code class="docutils literal notranslate"><span class="pre">dtype('float_')</span></code>.</p>
</div>
<dl class="simple">
<dt>dtype<span class="classifier">data-type or ndarray sub-class, optional</span></dt><dd><p>Data-type descriptor of the returned view, e.g., float32 or int16.
Omitting it results in the view having the same data-type as <cite>a</cite>.
This argument can also be specified as an ndarray sub-class, which
then specifies the type of the returned object (this is equivalent to
setting the <code class="docutils literal notranslate"><span class="pre">type</span></code> parameter).</p>
</dd>
<dt>type<span class="classifier">Python type, optional</span></dt><dd><p>Type of the returned view, e.g., ndarray or matrix.  Again, omission
of the parameter results in type preservation.</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">a.view()</span></code> is used two different ways:</p>
<p><code class="docutils literal notranslate"><span class="pre">a.view(some_dtype)</span></code> or <code class="docutils literal notranslate"><span class="pre">a.view(dtype=some_dtype)</span></code> constructs a view
of the array’s memory with a different data-type.  This can cause a
reinterpretation of the bytes of memory.</p>
<p><code class="docutils literal notranslate"><span class="pre">a.view(ndarray_subclass)</span></code> or <code class="docutils literal notranslate"><span class="pre">a.view(type=ndarray_subclass)</span></code> just
returns an instance of <cite>ndarray_subclass</cite> that looks at the same array
(same shape, dtype, etc.)  This does not cause a reinterpretation of the
memory.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">a.view(some_dtype)</span></code>, if <code class="docutils literal notranslate"><span class="pre">some_dtype</span></code> has a different number of
bytes per entry than the previous dtype (for example, converting a
regular array to a structured array), then the behavior of the view
cannot be predicted just from the superficial appearance of <code class="docutils literal notranslate"><span class="pre">a</span></code> (shown
by <code class="docutils literal notranslate"><span class="pre">print(a)</span></code>). It also depends on exactly how <code class="docutils literal notranslate"><span class="pre">a</span></code> is stored in
memory. Therefore if <code class="docutils literal notranslate"><span class="pre">a</span></code> is C-ordered versus fortran-ordered, versus
defined as a slice or transpose, etc., the view may give different
results.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)])</span>
</pre></div>
</div>
<p>Viewing array data using a different type and dtype:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">matrix([[513]], dtype=int16)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="go">&lt;class &#39;numpy.matrix&#39;&gt;</span>
</pre></div>
</div>
<p>Creating a view on a structured array so it can be used in calculations</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4]], dtype=int8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([2.,  3.])</span>
</pre></div>
</div>
<p>Making changes to the view changes the underlying array</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([(1, 20), (3,  4)], dtype=[(&#39;a&#39;, &#39;i1&#39;), (&#39;b&#39;, &#39;i1&#39;)])</span>
</pre></div>
</div>
<p>Using a view to convert an array to a recarray:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">.</span><span class="n">a</span>
<span class="go">array([1, 3], dtype=int8)</span>
</pre></div>
</div>
<p>Views share data:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">(9, 10)</span>
</pre></div>
</div>
<p>Views that change the dtype size (bytes per entry) should normally be
avoided on arrays defined by slices, transposes, fortran-ordering, etc.:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [4, 5]], dtype=int16)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;width&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;length&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)])</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">ValueError</span>: <span class="n">To change to a dtype of a different size, the array must be C-contiguous</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;width&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;length&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)])</span>
<span class="go">array([[(1, 2)],</span>
<span class="go">       [(4, 5)]], dtype=[(&#39;width&#39;, &#39;&lt;i2&#39;), (&#39;length&#39;, &#39;&lt;i2&#39;)])</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="numpy.ndenumerate">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">ndenumerate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndenumerate" title="Permalink to this definition">¶</a></dt>
<dd><p>Multidimensional index iterator.</p>
<p>Return an iterator yielding pairs of array coordinates and values.</p>
<dl class="simple">
<dt>arr<span class="classifier">ndarray</span></dt><dd><p>Input array.</p>
</dd>
</dl>
<p>ndindex, flatiter</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">(0, 0) 1</span>
<span class="go">(0, 1) 2</span>
<span class="go">(1, 0) 3</span>
<span class="go">(1, 1) 4</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.ndfromtxt">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">ndfromtxt</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndfromtxt" title="Permalink to this definition">¶</a></dt>
<dd><p>Load ASCII data stored in a file and return it as a single array.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 1.17: </span>ndfromtxt` is a deprecated alias of <cite>genfromtxt</cite> which
overwrites the <code class="docutils literal notranslate"><span class="pre">usemask</span></code> argument with <cite>False</cite> even when
explicitly called as <code class="docutils literal notranslate"><span class="pre">ndfromtxt(...,</span> <span class="pre">usemask=True)</span></code>.
Use <cite>genfromtxt</cite> instead.</p>
</div>
<p>fname, kwargs : For a description of input parameters, see <cite>genfromtxt</cite>.</p>
<p>numpy.genfromtxt : generic function.</p>
</dd></dl>

<dl class="py function">
<dt id="numpy.ndim">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">ndim</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of dimensions of an array.</p>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input array.  If it is not already an ndarray, a conversion is
attempted.</p>
</dd>
</dl>
<dl class="simple">
<dt>number_of_dimensions<span class="classifier">int</span></dt><dd><p>The number of dimensions in <cite>a</cite>.  Scalars are zero-dimensional.</p>
</dd>
</dl>
<p>ndarray.ndim : equivalent method
shape : dimensions of array
ndarray.shape : dimensions of array</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]])</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]]))</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt id="numpy.ndindex">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">ndindex</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndindex" title="Permalink to this definition">¶</a></dt>
<dd><p>An N-dimensional iterator object to index arrays.</p>
<p>Given the shape of an array, an <cite>ndindex</cite> instance iterates over
the N-dimensional index of the array. At each iteration a tuple
of indices is returned, the last dimension is iterated over first.</p>
<dl class="simple">
<dt>shape<span class="classifier">ints, or a single tuple of ints</span></dt><dd><p>The size of each dimension of the array can be passed as 
individual parameters or as the elements of a tuple.</p>
</dd>
</dl>
<p>ndenumerate, flatiter</p>
<p># dimensions as individual arguments
&gt;&gt;&gt; for index in np.ndindex(3, 2, 1):
…     print(index)
(0, 0, 0)
(0, 1, 0)
(1, 0, 0)
(1, 1, 0)
(2, 0, 0)
(2, 1, 0)</p>
<p># same dimensions - but in a tuple (3, 2, 1)
&gt;&gt;&gt; for index in np.ndindex((3, 2, 1)):
…     print(index)
(0, 0, 0)
(0, 1, 0)
(1, 0, 0)
(1, 1, 0)
(2, 0, 0)
(2, 1, 0)</p>
<dl class="py method">
<dt id="numpy.ndindex.ndincr">
<code class="sig-name descname"><span class="pre">ndincr</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndindex.ndincr" title="Permalink to this definition">¶</a></dt>
<dd><p>Increment the multi-dimensional index by one.</p>
<p>This method is for backward compatibility only: do not use.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 1.20.0: </span>This method has been advised against since numpy 1.8.0, but only
started emitting DeprecationWarning as of this version.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="numpy.nditer">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">nditer</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">op_flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">op_dtypes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'K'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">casting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'safe'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">op_axes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">itershape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffersize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nditer" title="Permalink to this definition">¶</a></dt>
<dd><p>Efficient multi-dimensional iterator object to iterate over arrays.
To get started using this object, see the
<span class="xref std std-ref">introductory guide to array iteration</span>.</p>
<dl class="simple">
<dt>op<span class="classifier">ndarray or sequence of array_like</span></dt><dd><p>The array(s) to iterate over.</p>
</dd>
<dt>flags<span class="classifier">sequence of str, optional</span></dt><dd><p>Flags to control the behavior of the iterator.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">buffered</span></code> enables buffering when required.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">c_index</span></code> causes a C-order index to be tracked.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">f_index</span></code> causes a Fortran-order index to be tracked.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">multi_index</span></code> causes a multi-index, or a tuple of indices
with one per iteration dimension, to be tracked.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">common_dtype</span></code> causes all the operands to be converted to
a common data type, with copying or buffering as necessary.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">copy_if_overlap</span></code> causes the iterator to determine if read
operands have overlap with write operands, and make temporary
copies as necessary to avoid overlap. False positives (needless
copying) are possible in some cases.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">delay_bufalloc</span></code> delays allocation of the buffers until
a reset() call is made. Allows <code class="docutils literal notranslate"><span class="pre">allocate</span></code> operands to
be initialized before their values are copied into the buffers.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">external_loop</span></code> causes the <code class="docutils literal notranslate"><span class="pre">values</span></code> given to be
one-dimensional arrays with multiple values instead of
zero-dimensional arrays.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">grow_inner</span></code> allows the <code class="docutils literal notranslate"><span class="pre">value</span></code> array sizes to be made
larger than the buffer size when both <code class="docutils literal notranslate"><span class="pre">buffered</span></code> and
<code class="docutils literal notranslate"><span class="pre">external_loop</span></code> is used.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ranged</span></code> allows the iterator to be restricted to a sub-range
of the iterindex values.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">refs_ok</span></code> enables iteration of reference types, such as
object arrays.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reduce_ok</span></code> enables iteration of <code class="docutils literal notranslate"><span class="pre">readwrite</span></code> operands
which are broadcasted, also known as reduction operands.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">zerosize_ok</span></code> allows <cite>itersize</cite> to be zero.</p></li>
</ul>
</dd>
<dt>op_flags<span class="classifier">list of list of str, optional</span></dt><dd><p>This is a list of flags for each operand. At minimum, one of
<code class="docutils literal notranslate"><span class="pre">readonly</span></code>, <code class="docutils literal notranslate"><span class="pre">readwrite</span></code>, or <code class="docutils literal notranslate"><span class="pre">writeonly</span></code> must be specified.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">readonly</span></code> indicates the operand will only be read from.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">readwrite</span></code> indicates the operand will be read from and written to.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">writeonly</span></code> indicates the operand will only be written to.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">no_broadcast</span></code> prevents the operand from being broadcasted.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">contig</span></code> forces the operand data to be contiguous.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">aligned</span></code> forces the operand data to be aligned.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nbo</span></code> forces the operand data to be in native byte order.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">copy</span></code> allows a temporary read-only copy if required.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">updateifcopy</span></code> allows a temporary read-write copy if required.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">allocate</span></code> causes the array to be allocated if it is None
in the <code class="docutils literal notranslate"><span class="pre">op</span></code> parameter.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">no_subtype</span></code> prevents an <code class="docutils literal notranslate"><span class="pre">allocate</span></code> operand from using a subtype.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">arraymask</span></code> indicates that this operand is the mask to use
for selecting elements when writing to operands with the
‘writemasked’ flag set. The iterator does not enforce this,
but when writing from a buffer back to the array, it only
copies those elements indicated by this mask.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">writemasked</span></code> indicates that only elements where the chosen
<code class="docutils literal notranslate"><span class="pre">arraymask</span></code> operand is True will be written to.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">overlap_assume_elementwise</span></code> can be used to mark operands that are
accessed only in the iterator order, to allow less conservative
copying when <code class="docutils literal notranslate"><span class="pre">copy_if_overlap</span></code> is present.</p></li>
</ul>
</dd>
<dt>op_dtypes<span class="classifier">dtype or tuple of dtype(s), optional</span></dt><dd><p>The required data type(s) of the operands. If copying or buffering
is enabled, the data will be converted to/from their original types.</p>
</dd>
<dt>order<span class="classifier">{‘C’, ‘F’, ‘A’, ‘K’}, optional</span></dt><dd><p>Controls the iteration order. ‘C’ means C order, ‘F’ means
Fortran order, ‘A’ means ‘F’ order if all the arrays are Fortran
contiguous, ‘C’ order otherwise, and ‘K’ means as close to the
order the array elements appear in memory as possible. This also
affects the element memory order of <code class="docutils literal notranslate"><span class="pre">allocate</span></code> operands, as they
are allocated to be compatible with iteration order.
Default is ‘K’.</p>
</dd>
<dt>casting<span class="classifier">{‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional</span></dt><dd><p>Controls what kind of data casting may occur when making a copy
or buffering.  Setting this to ‘unsafe’ is not recommended,
as it can adversely affect accumulations.</p>
<ul class="simple">
<li><p>‘no’ means the data types should not be cast at all.</p></li>
<li><p>‘equiv’ means only byte-order changes are allowed.</p></li>
<li><p>‘safe’ means only casts which can preserve values are allowed.</p></li>
<li><p>‘same_kind’ means only safe casts or casts within a kind,
like float64 to float32, are allowed.</p></li>
<li><p>‘unsafe’ means any data conversions may be done.</p></li>
</ul>
</dd>
<dt>op_axes<span class="classifier">list of list of ints, optional</span></dt><dd><p>If provided, is a list of ints or None for each operands.
The list of axes for an operand is a mapping from the dimensions
of the iterator to the dimensions of the operand. A value of
-1 can be placed for entries, causing that dimension to be
treated as <cite>newaxis</cite>.</p>
</dd>
<dt>itershape<span class="classifier">tuple of ints, optional</span></dt><dd><p>The desired shape of the iterator. This allows <code class="docutils literal notranslate"><span class="pre">allocate</span></code> operands
with a dimension mapped by op_axes not corresponding to a dimension
of a different operand to get a value not equal to 1 for that
dimension.</p>
</dd>
<dt>buffersize<span class="classifier">int, optional</span></dt><dd><p>When buffering is enabled, controls the size of the temporary
buffers. Set to 0 for the default value.</p>
</dd>
</dl>
<dl class="simple">
<dt>dtypes<span class="classifier">tuple of dtype(s)</span></dt><dd><p>The data types of the values provided in <cite>value</cite>. This may be
different from the operand data types if buffering is enabled.
Valid only before the iterator is closed.</p>
</dd>
<dt>finished<span class="classifier">bool</span></dt><dd><p>Whether the iteration over the operands is finished or not.</p>
</dd>
<dt>has_delayed_bufalloc<span class="classifier">bool</span></dt><dd><p>If True, the iterator was created with the <code class="docutils literal notranslate"><span class="pre">delay_bufalloc</span></code> flag,
and no reset() function was called on it yet.</p>
</dd>
<dt>has_index<span class="classifier">bool</span></dt><dd><p>If True, the iterator was created with either the <code class="docutils literal notranslate"><span class="pre">c_index</span></code> or
the <code class="docutils literal notranslate"><span class="pre">f_index</span></code> flag, and the property <cite>index</cite> can be used to
retrieve it.</p>
</dd>
<dt>has_multi_index<span class="classifier">bool</span></dt><dd><p>If True, the iterator was created with the <code class="docutils literal notranslate"><span class="pre">multi_index</span></code> flag,
and the property <cite>multi_index</cite> can be used to retrieve it.</p>
</dd>
<dt>index</dt><dd><p>When the <code class="docutils literal notranslate"><span class="pre">c_index</span></code> or <code class="docutils literal notranslate"><span class="pre">f_index</span></code> flag was used, this property
provides access to the index. Raises a ValueError if accessed
and <code class="docutils literal notranslate"><span class="pre">has_index</span></code> is False.</p>
</dd>
<dt>iterationneedsapi<span class="classifier">bool</span></dt><dd><p>Whether iteration requires access to the Python API, for example
if one of the operands is an object array.</p>
</dd>
<dt>iterindex<span class="classifier">int</span></dt><dd><p>An index which matches the order of iteration.</p>
</dd>
<dt>itersize<span class="classifier">int</span></dt><dd><p>Size of the iterator.</p>
</dd>
<dt>itviews</dt><dd><p>Structured view(s) of <cite>operands</cite> in memory, matching the reordered
and optimized iterator access pattern. Valid only before the iterator
is closed.</p>
</dd>
<dt>multi_index</dt><dd><p>When the <code class="docutils literal notranslate"><span class="pre">multi_index</span></code> flag was used, this property
provides access to the index. Raises a ValueError if accessed
accessed and <code class="docutils literal notranslate"><span class="pre">has_multi_index</span></code> is False.</p>
</dd>
<dt>ndim<span class="classifier">int</span></dt><dd><p>The dimensions of the iterator.</p>
</dd>
<dt>nop<span class="classifier">int</span></dt><dd><p>The number of iterator operands.</p>
</dd>
<dt>operands<span class="classifier">tuple of operand(s)</span></dt><dd><p>The array(s) to be iterated over. Valid only before the iterator is
closed.</p>
</dd>
<dt>shape<span class="classifier">tuple of ints</span></dt><dd><p>Shape tuple, the shape of the iterator.</p>
</dd>
<dt>value</dt><dd><p>Value of <code class="docutils literal notranslate"><span class="pre">operands</span></code> at current iteration. Normally, this is a
tuple of array scalars, but if the flag <code class="docutils literal notranslate"><span class="pre">external_loop</span></code> is used,
it is a tuple of one dimensional arrays.</p>
</dd>
</dl>
<p><cite>nditer</cite> supersedes <cite>flatiter</cite>.  The iterator implementation behind
<cite>nditer</cite> is also exposed by the NumPy C API.</p>
<p>The Python exposure supplies two iteration interfaces, one which follows
the Python iterator protocol, and another which mirrors the C-style
do-while pattern.  The native Python approach is better in most cases, but
if you need the coordinates or index of an iterator, use the C-style pattern.</p>
<p>Here is how we might write an <code class="docutils literal notranslate"><span class="pre">iter_add</span></code> function, using the
Python iterator protocol:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">iter_add_py</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">addop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span>
<span class="gp">... </span>    <span class="n">it</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nditer</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">out</span><span class="p">],</span> <span class="p">[],</span>
<span class="gp">... </span>                <span class="p">[[</span><span class="s1">&#39;readonly&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;readonly&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;writeonly&#39;</span><span class="p">,</span><span class="s1">&#39;allocate&#39;</span><span class="p">]])</span>
<span class="gp">... </span>    <span class="k">with</span> <span class="n">it</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
<span class="gp">... </span>            <span class="n">addop</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">it</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p>Here is the same function, but following the C-style pattern:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">iter_add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">... </span>   <span class="n">addop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span>
<span class="gp">... </span>   <span class="n">it</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nditer</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">out</span><span class="p">],</span> <span class="p">[],</span>
<span class="gp">... </span>               <span class="p">[[</span><span class="s1">&#39;readonly&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;readonly&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;writeonly&#39;</span><span class="p">,</span><span class="s1">&#39;allocate&#39;</span><span class="p">]])</span>
<span class="gp">... </span>   <span class="k">with</span> <span class="n">it</span><span class="p">:</span>
<span class="gp">... </span>       <span class="k">while</span> <span class="ow">not</span> <span class="n">it</span><span class="o">.</span><span class="n">finished</span><span class="p">:</span>
<span class="gp">... </span>           <span class="n">addop</span><span class="p">(</span><span class="n">it</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">it</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">it</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">... </span>           <span class="n">it</span><span class="o">.</span><span class="n">iternext</span><span class="p">()</span>
<span class="gp">... </span>       <span class="k">return</span> <span class="n">it</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p>Here is an example outer product function:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">outer_it</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">mulop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span>
<span class="gp">... </span>    <span class="n">it</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nditer</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">out</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;external_loop&#39;</span><span class="p">],</span>
<span class="gp">... </span>            <span class="p">[[</span><span class="s1">&#39;readonly&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;readonly&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;writeonly&#39;</span><span class="p">,</span> <span class="s1">&#39;allocate&#39;</span><span class="p">]],</span>
<span class="gp">... </span>            <span class="n">op_axes</span><span class="o">=</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span> <span class="o">+</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span>
<span class="gp">... </span>                     <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">ndim</span><span class="p">)),</span>
<span class="gp">... </span>                     <span class="kc">None</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">with</span> <span class="n">it</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
<span class="gp">... </span>            <span class="n">mulop</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">it</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">outer_it</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [2, 4, 6]])</span>
</pre></div>
</div>
<p>Here is an example function which operates like a “lambda” ufunc:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">luf</span><span class="p">(</span><span class="n">lamdaexpr</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="gp">... </span>   <span class="sd">&#39;&#39;&#39;luf(lambdaexpr, op1, ..., opn, out=None, order=&#39;K&#39;, casting=&#39;safe&#39;, buffersize=0)&#39;&#39;&#39;</span>
<span class="gp">... </span>   <span class="n">nargs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="gp">... </span>   <span class="n">op</span> <span class="o">=</span> <span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;out&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">),)</span> <span class="o">+</span> <span class="n">args</span>
<span class="gp">... </span>   <span class="n">it</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nditer</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;buffered&#39;</span><span class="p">,</span><span class="s1">&#39;external_loop&#39;</span><span class="p">],</span>
<span class="gp">... </span>           <span class="p">[[</span><span class="s1">&#39;writeonly&#39;</span><span class="p">,</span><span class="s1">&#39;allocate&#39;</span><span class="p">,</span><span class="s1">&#39;no_broadcast&#39;</span><span class="p">]]</span> <span class="o">+</span>
<span class="gp">... </span>                           <span class="p">[[</span><span class="s1">&#39;readonly&#39;</span><span class="p">,</span><span class="s1">&#39;nbo&#39;</span><span class="p">,</span><span class="s1">&#39;aligned&#39;</span><span class="p">]]</span><span class="o">*</span><span class="n">nargs</span><span class="p">,</span>
<span class="gp">... </span>           <span class="n">order</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;order&#39;</span><span class="p">,</span><span class="s1">&#39;K&#39;</span><span class="p">),</span>
<span class="gp">... </span>           <span class="n">casting</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;casting&#39;</span><span class="p">,</span><span class="s1">&#39;safe&#39;</span><span class="p">),</span>
<span class="gp">... </span>           <span class="n">buffersize</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;buffersize&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">... </span>   <span class="k">while</span> <span class="ow">not</span> <span class="n">it</span><span class="o">.</span><span class="n">finished</span><span class="p">:</span>
<span class="gp">... </span>       <span class="n">it</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">lamdaexpr</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
<span class="gp">... </span>       <span class="n">it</span><span class="o">.</span><span class="n">iternext</span><span class="p">()</span>
<span class="gp">... </span>   <span class="k">return</span> <span class="n">it</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">luf</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">:</span><span class="n">i</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([  0.5,   1.5,   4.5,   9.5,  16.5])</span>
</pre></div>
</div>
<p>If operand flags <cite>“writeonly”</cite> or <cite>“readwrite”</cite> are used the
operands may be views into the original data with the
<cite>WRITEBACKIFCOPY</cite> flag. In this case <cite>nditer</cite> must be used as a
context manager or the <cite>nditer.close</cite> method must be called before
using the result. The temporary data will be written back to the
original data when the <cite>__exit__</cite> function is called but not before:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;i4&#39;</span><span class="p">)[::</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">nditer</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[],</span>
<span class="gp">... </span>       <span class="p">[[</span><span class="s1">&#39;writeonly&#39;</span><span class="p">,</span> <span class="s1">&#39;updateifcopy&#39;</span><span class="p">]],</span>
<span class="gp">... </span>       <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;unsafe&#39;</span><span class="p">,</span>
<span class="gp">... </span>       <span class="n">op_dtypes</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;f4&#39;</span><span class="p">)])</span> <span class="k">as</span> <span class="n">i</span><span class="p">:</span>
<span class="gp">... </span>   <span class="n">x</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">... </span>   <span class="n">x</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">... </span>   <span class="c1"># a still unchanged here</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">x</span>
<span class="go">(array([-1, -2, -3], dtype=int32), array([-1., -2., -3.], dtype=float32))</span>
</pre></div>
</div>
<p>It is important to note that once the iterator is exited, dangling
references (like <cite>x</cite> in the example) may or may not share data with
the original data <cite>a</cite>. If writeback semantics were active, i.e. if
<cite>x.base.flags.writebackifcopy</cite> is <cite>True</cite>, then exiting the iterator
will sever the connection between <cite>x</cite> and <cite>a</cite>, writing to <cite>x</cite> will
no longer write to <cite>a</cite>. If writeback semantics are not active, then
<cite>x.data</cite> will still point at some part of <cite>a.data</cite>, and writing to
one will affect the other.</p>
<p>Context management and the <cite>close</cite> method appeared in version 1.15.0.</p>
<dl class="py method">
<dt id="numpy.nditer.close">
<code class="sig-name descname"><span class="pre">close</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nditer.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Resolve all writeback semantics in writeable operands.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.15.0.</span></p>
</div>
<p><span class="xref std std-ref">nditer-context-manager</span></p>
</dd></dl>

<dl class="py method">
<dt id="numpy.nditer.copy">
<code class="sig-name descname"><span class="pre">copy</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nditer.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a copy of the iterator in its current state.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">it</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nditer</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">(array(0), array(1))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">it2</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">it2</span><span class="p">)</span>
<span class="go">(array(1), array(2))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.nditer.debug_print">
<code class="sig-name descname"><span class="pre">debug_print</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nditer.debug_print" title="Permalink to this definition">¶</a></dt>
<dd><p>Print the current state of the <cite>nditer</cite> instance and debug info to stdout.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.nditer.enable_external_loop">
<code class="sig-name descname"><span class="pre">enable_external_loop</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nditer.enable_external_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>When the “external_loop” was not used during construction, but
is desired, this modifies the iterator to behave as if the flag
was specified.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.nditer.iternext">
<code class="sig-name descname"><span class="pre">iternext</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nditer.iternext" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether iterations are left, and perform a single internal iteration
without returning the result.  Used in the C-style pattern do-while
pattern.  For an example, see <cite>nditer</cite>.</p>
<dl class="simple">
<dt>iternext<span class="classifier">bool</span></dt><dd><p>Whether or not there are iterations left.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.nditer.operands">
<code class="sig-name descname"><span class="pre">operands</span></code><a class="headerlink" href="#numpy.nditer.operands" title="Permalink to this definition">¶</a></dt>
<dd><p>operands[<cite>Slice</cite>]</p>
<p>The array(s) to be iterated over. Valid only before the iterator is closed.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.nditer.remove_axis">
<code class="sig-name descname"><span class="pre">remove_axis</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nditer.remove_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes axis <cite>i</cite> from the iterator. Requires that the flag “multi_index”
be enabled.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.nditer.remove_multi_index">
<code class="sig-name descname"><span class="pre">remove_multi_index</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nditer.remove_multi_index" title="Permalink to this definition">¶</a></dt>
<dd><p>When the “multi_index” flag was specified, this removes it, allowing
the internal iteration structure to be optimized further.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.nditer.reset">
<code class="sig-name descname"><span class="pre">reset</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nditer.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the iterator to its initial state.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="numpy.nested_iters">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">nested_iters</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nested_iters" title="Permalink to this definition">¶</a></dt>
<dd><p>Create nditers for use in nested loops</p>
<p>Create a tuple of <cite>nditer</cite> objects which iterate in nested loops over
different axes of the op argument. The first iterator is used in the
outermost loop, the last in the innermost loop. Advancing one will change
the subsequent iterators to point at its new element.</p>
<dl class="simple">
<dt>op<span class="classifier">ndarray or sequence of array_like</span></dt><dd><p>The array(s) to iterate over.</p>
</dd>
<dt>axes<span class="classifier">list of list of int</span></dt><dd><p>Each item is used as an “op_axes” argument to an nditer</p>
</dd>
<dt>flags, op_flags, op_dtypes, order, casting, buffersize (optional)</dt><dd><p>See <cite>nditer</cite> parameters of the same name</p>
</dd>
</dl>
<dl class="simple">
<dt>iters<span class="classifier">tuple of nditer</span></dt><dd><p>An nditer for each item in <cite>axes</cite>, outermost first</p>
</dd>
</dl>
<p>nditer</p>
<p>Basic usage. Note how y is the “flattened” version of
[a[:, 0, :], a[:, 1, 0], a[:, 2, :]] since we specified
the first iter’s axes as [1]</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nested_iters</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span> <span class="n">flags</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;multi_index&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">i</span><span class="p">:</span>
<span class="gp">... </span>     <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">multi_index</span><span class="p">)</span>
<span class="gp">... </span>     <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">j</span><span class="p">:</span>
<span class="gp">... </span>         <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">multi_index</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">(0,)</span>
<span class="go"> (0, 0) 0</span>
<span class="go"> (0, 1) 1</span>
<span class="go"> (1, 0) 6</span>
<span class="go"> (1, 1) 7</span>
<span class="go">(1,)</span>
<span class="go"> (0, 0) 2</span>
<span class="go"> (0, 1) 3</span>
<span class="go"> (1, 0) 8</span>
<span class="go"> (1, 1) 9</span>
<span class="go">(2,)</span>
<span class="go"> (0, 0) 4</span>
<span class="go"> (0, 1) 5</span>
<span class="go"> (1, 0) 10</span>
<span class="go"> (1, 1) 11</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.nonzero">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">nonzero</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nonzero" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices of the elements that are non-zero.</p>
<p>Returns a tuple of arrays, one for each dimension of <cite>a</cite>,
containing the indices of the non-zero elements in that
dimension. The values in <cite>a</cite> are always tested and returned in
row-major, C-style order.</p>
<p>To group the indices by element, rather than dimension, use <cite>argwhere</cite>,
which returns a row for each non-zero element.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When called on a zero-d array or scalar, <code class="docutils literal notranslate"><span class="pre">nonzero(a)</span></code> is treated
as <code class="docutils literal notranslate"><span class="pre">nonzero(atleast_1d(a))</span></code>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 1.17.0: </span>Use <cite>atleast_1d</cite> explicitly if this behavior is deliberate.</p>
</div>
</div>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
</dl>
<dl class="simple">
<dt>tuple_of_arrays<span class="classifier">tuple</span></dt><dd><p>Indices of elements that are non-zero.</p>
</dd>
</dl>
<dl class="simple">
<dt>flatnonzero :</dt><dd><p>Return indices that are non-zero in the flattened version of the input
array.</p>
</dd>
<dt>ndarray.nonzero :</dt><dd><p>Equivalent ndarray method.</p>
</dd>
<dt>count_nonzero :</dt><dd><p>Counts the number of non-zero elements in the input array.</p>
</dd>
</dl>
<p>While the nonzero values can be obtained with <code class="docutils literal notranslate"><span class="pre">a[nonzero(a)]</span></code>, it is
recommended to use <code class="docutils literal notranslate"><span class="pre">x[x.astype(bool)]</span></code> or <code class="docutils literal notranslate"><span class="pre">x[x</span> <span class="pre">!=</span> <span class="pre">0]</span></code> instead, which
will correctly handle 0-d arrays.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[3, 0, 0],</span>
<span class="go">       [0, 4, 0],</span>
<span class="go">       [5, 6, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(array([0, 1, 2, 2]), array([0, 1, 0, 1]))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
<span class="go">array([3, 4, 5, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">array([[0, 0],</span>
<span class="go">       [1, 1],</span>
<span class="go">       [2, 0],</span>
<span class="go">       [2, 1]])</span>
</pre></div>
</div>
<p>A common use for <code class="docutils literal notranslate"><span class="pre">nonzero</span></code> is to find the indices of an array, where
a condition is True.  Given an array <cite>a</cite>, the condition <cite>a</cite> &gt; 3 is a
boolean array and since False is interpreted as 0, np.nonzero(a &gt; 3)
yields the indices of the <cite>a</cite> where the condition is true.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">3</span>
<span class="go">array([[False, False, False],</span>
<span class="go">       [ True,  True,  True],</span>
<span class="go">       [ True,  True,  True]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))</span>
</pre></div>
</div>
<p>Using this result to index <cite>a</cite> is equivalent to using the mask directly:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)]</span>
<span class="go">array([4, 5, 6, 7, 8, 9])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">]</span>  <span class="c1"># prefer this spelling</span>
<span class="go">array([4, 5, 6, 7, 8, 9])</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">nonzero</span></code> can also be called as a method of the array.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
<span class="go">(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt id="numpy.number">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">number</span></code><a class="headerlink" href="#numpy.number" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class of all numeric scalar types.</p>
</dd></dl>

<dl class="py function">
<dt id="numpy.obj2sctype">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">obj2sctype</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rep</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.obj2sctype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the scalar dtype or NumPy equivalent of Python type of an object.</p>
<dl class="simple">
<dt>rep<span class="classifier">any</span></dt><dd><p>The object of which the type is returned.</p>
</dd>
<dt>default<span class="classifier">any, optional</span></dt><dd><p>If given, this is returned for objects whose types can not be
determined. If not given, None is returned for those objects.</p>
</dd>
</dl>
<dl class="simple">
<dt>dtype<span class="classifier">dtype or Python type</span></dt><dd><p>The data type of <cite>rep</cite>.</p>
</dd>
</dl>
<p>sctype2char, issctype, issubsctype, issubdtype, maximum_sctype</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">obj2sctype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="go">&lt;class &#39;numpy.int32&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">obj2sctype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">]))</span>
<span class="go">&lt;class &#39;numpy.float64&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">obj2sctype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="n">j</span><span class="p">]))</span>
<span class="go">&lt;class &#39;numpy.complex128&#39;&gt;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">obj2sctype</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
<span class="go">&lt;class &#39;numpy.object_&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">obj2sctype</span><span class="p">(</span><span class="s1">&#39;string&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">obj2sctype</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
<span class="go">&lt;class &#39;list&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.object0">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">object0</span></code><a class="headerlink" href="#numpy.object0" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.object_" title="numpy.object_"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.object_</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt id="numpy.object_">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">object_</span></code><a class="headerlink" href="#numpy.object_" title="Permalink to this definition">¶</a></dt>
<dd><p>Any Python object.</p>
<dl class="field-list simple">
<dt class="field-odd">Character code</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">'O'</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="numpy.ones">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">ones</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'C'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">like</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ones" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new array of given shape and type, filled with ones.</p>
<dl>
<dt>shape<span class="classifier">int or sequence of ints</span></dt><dd><p>Shape of the new array, e.g., <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">3)</span></code> or <code class="docutils literal notranslate"><span class="pre">2</span></code>.</p>
</dd>
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>The desired data-type for the array, e.g., <cite>numpy.int8</cite>.  Default is
<cite>numpy.float64</cite>.</p>
</dd>
<dt>order<span class="classifier">{‘C’, ‘F’}, optional, default: C</span></dt><dd><p>Whether to store multi-dimensional data in row-major
(C-style) or column-major (Fortran-style) order in
memory.</p>
</dd>
<dt>like<span class="classifier">array_like</span></dt><dd><p>Reference object to allow the creation of arrays which are not
NumPy arrays. If an array-like passed in as <code class="docutils literal notranslate"><span class="pre">like</span></code> supports
the <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> protocol, the result will be defined
by it. In this case, it ensures the creation of an array object
compatible with that passed in via this argument.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.20.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>Array of ones with the given shape, dtype, and order.</p>
</dd>
</dl>
<p>ones_like : Return an array of ones with shape and type of input.
empty : Return a new uninitialized array.
zeros : Return a new array setting values to zero.
full : Return a new array of given shape filled with value.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">array([1., 1., 1., 1., 1.])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([1, 1, 1, 1, 1])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">array([[1.],</span>
<span class="go">       [1.]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">array([[1.,  1.],</span>
<span class="go">       [1.,  1.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.ones_like">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">ones_like</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'K'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subok</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ones_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of ones with the same shape and type as a given array.</p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>The shape and data-type of <cite>a</cite> define these same attributes of
the returned array.</p>
</dd>
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>Overrides the data type of the result.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.6.0.</span></p>
</div>
</dd>
<dt>order<span class="classifier">{‘C’, ‘F’, ‘A’, or ‘K’}, optional</span></dt><dd><p>Overrides the memory layout of the result. ‘C’ means C-order,
‘F’ means F-order, ‘A’ means ‘F’ if <cite>a</cite> is Fortran contiguous,
‘C’ otherwise. ‘K’ means match the layout of <cite>a</cite> as closely
as possible.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.6.0.</span></p>
</div>
</dd>
<dt>subok<span class="classifier">bool, optional.</span></dt><dd><p>If True, then the newly created array will use the sub-class
type of <cite>a</cite>, otherwise it will be a base-class array. Defaults
to True.</p>
</dd>
<dt>shape<span class="classifier">int or sequence of ints, optional.</span></dt><dd><p>Overrides the shape of the result. If order=’K’ and the number of
dimensions is unchanged, will try to keep order, otherwise,
order=’C’ is implied.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.17.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>Array of ones with the same shape and type as <cite>a</cite>.</p>
</dd>
</dl>
<p>empty_like : Return an empty array with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full_like : Return a new array with shape of input filled with value.
ones : Return a new array setting values to one.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([[1, 1, 1],</span>
<span class="go">       [1, 1, 1]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([0., 1., 2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">array([1.,  1.,  1.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.outer">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">outer</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.outer" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the outer product of two vectors.</p>
<p>Given two vectors, <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">[a0,</span> <span class="pre">a1,</span> <span class="pre">...,</span> <span class="pre">aM]</span></code> and
<code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">=</span> <span class="pre">[b0,</span> <span class="pre">b1,</span> <span class="pre">...,</span> <span class="pre">bN]</span></code>,
the outer product <a href="#id88"><span class="problematic" id="id47">[1]_</span></a> is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">a0</span><span class="o">*</span><span class="n">b0</span>  <span class="n">a0</span><span class="o">*</span><span class="n">b1</span> <span class="o">...</span> <span class="n">a0</span><span class="o">*</span><span class="n">bN</span> <span class="p">]</span>
 <span class="p">[</span><span class="n">a1</span><span class="o">*</span><span class="n">b0</span>    <span class="o">.</span>
 <span class="p">[</span> <span class="o">...</span>          <span class="o">.</span>
 <span class="p">[</span><span class="n">aM</span><span class="o">*</span><span class="n">b0</span>            <span class="n">aM</span><span class="o">*</span><span class="n">bN</span> <span class="p">]]</span>
</pre></div>
</div>
<dl>
<dt>a<span class="classifier">(M,) array_like</span></dt><dd><p>First input vector.  Input is flattened if
not already 1-dimensional.</p>
</dd>
<dt>b<span class="classifier">(N,) array_like</span></dt><dd><p>Second input vector.  Input is flattened if
not already 1-dimensional.</p>
</dd>
<dt>out<span class="classifier">(M, N) ndarray, optional</span></dt><dd><p>A location where the result is stored</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.9.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">(M, N) ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">out[i,</span> <span class="pre">j]</span> <span class="pre">=</span> <span class="pre">a[i]</span> <span class="pre">*</span> <span class="pre">b[j]</span></code></p>
</dd>
</dl>
<p>inner
einsum : <code class="docutils literal notranslate"><span class="pre">einsum('i,j-&gt;ij',</span> <span class="pre">a.ravel(),</span> <span class="pre">b.ravel())</span></code> is the equivalent.
ufunc.outer : A generalization to dimensions other than 1D and other</p>
<blockquote>
<div><p>operations. <code class="docutils literal notranslate"><span class="pre">np.multiply.outer(a.ravel(),</span> <span class="pre">b.ravel())</span></code>
is the equivalent.</p>
</div></blockquote>
<dl>
<dt>tensordot<span class="classifier"><code class="docutils literal notranslate"><span class="pre">np.tensordot(a.ravel(),</span> <span class="pre">b.ravel(),</span> <span class="pre">axes=((),</span> <span class="pre">()))</span></code></span></dt><dd><p>is the equivalent.</p>
</dd>
</dl>
<dl class="footnote brackets">
<dt class="label" id="id48"><span class="brackets">1</span></dt>
<dd><p>: G. H. Golub and C. F. Van Loan, <em>Matrix Computations</em>, 3rd
ed., Baltimore, MD, Johns Hopkins University Press, 1996,
pg. 8.</p>
</dd>
</dl>
<p>Make a (<em>very</em> coarse) grid for computing a Mandelbrot set:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,)),</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rl</span>
<span class="go">array([[-2., -1.,  0.,  1.,  2.],</span>
<span class="go">       [-2., -1.,  0.,  1.,  2.],</span>
<span class="go">       [-2., -1.,  0.,  1.,  2.],</span>
<span class="go">       [-2., -1.,  0.,  1.,  2.],</span>
<span class="go">       [-2., -1.,  0.,  1.,  2.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span>
<span class="go">array([[0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j],</span>
<span class="go">       [0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j],</span>
<span class="go">       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],</span>
<span class="go">       [0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j],</span>
<span class="go">       [0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span> <span class="o">=</span> <span class="n">rl</span> <span class="o">+</span> <span class="n">im</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span>
<span class="go">array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],</span>
<span class="go">       [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],</span>
<span class="go">       [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],</span>
<span class="go">       [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],</span>
<span class="go">       [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])</span>
</pre></div>
</div>
<p>An example using a “vector” of letters:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">array([[&#39;a&#39;, &#39;aa&#39;, &#39;aaa&#39;],</span>
<span class="go">       [&#39;b&#39;, &#39;bb&#39;, &#39;bbb&#39;],</span>
<span class="go">       [&#39;c&#39;, &#39;cc&#39;, &#39;ccc&#39;]], dtype=object)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.packbits">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">packbits</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bitorder</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'big'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.packbits" title="Permalink to this definition">¶</a></dt>
<dd><p>Packs the elements of a binary-valued array into bits in a uint8 array.</p>
<p>The result is padded to full bytes by inserting zero bits at the end.</p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>An array of integers or booleans whose elements should be packed to
bits.</p>
</dd>
<dt>axis<span class="classifier">int, optional</span></dt><dd><p>The dimension over which bit-packing is done.
<code class="docutils literal notranslate"><span class="pre">None</span></code> implies packing the flattened array.</p>
</dd>
<dt>bitorder<span class="classifier">{‘big’, ‘little’}, optional</span></dt><dd><p>The order of the input bits. ‘big’ will mimic bin(val),
<code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">1]</span> <span class="pre">=&gt;</span> <span class="pre">3</span> <span class="pre">=</span> <span class="pre">0b00000011</span></code>, ‘little’ will
reverse the order so <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0]</span> <span class="pre">=&gt;</span> <span class="pre">3</span></code>.
Defaults to ‘big’.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.17.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>packed<span class="classifier">ndarray</span></dt><dd><p>Array of type uint8 whose elements represent bits corresponding to the
logical (0 or nonzero) value of the input elements. The shape of
<cite>packed</cite> has the same number of dimensions as the input (unless <cite>axis</cite>
is None, in which case the output is 1-D).</p>
</dd>
</dl>
<dl class="simple">
<dt>unpackbits: Unpacks elements of a uint8 array into a binary-valued output</dt><dd><p>array.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>               <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span>
<span class="gp">... </span>              <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>               <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">packbits</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([[[160],</span>
<span class="go">        [ 64]],</span>
<span class="go">       [[192],</span>
<span class="go">        [ 32]]], dtype=uint8)</span>
</pre></div>
</div>
<p>Note that in binary 160 = 1010 0000, 64 = 0100 0000, 192 = 1100 0000,
and 32 = 0010 0000.</p>
</dd></dl>

<dl class="py function">
<dt id="numpy.pad">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">pad</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad_width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'constant'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.pad" title="Permalink to this definition">¶</a></dt>
<dd><p>Pad an array.</p>
<dl>
<dt>array<span class="classifier">array_like of rank N</span></dt><dd><p>The array to pad.</p>
</dd>
<dt>pad_width<span class="classifier">{sequence, array_like, int}</span></dt><dd><p>Number of values padded to the edges of each axis.
((before_1, after_1), … (before_N, after_N)) unique pad widths
for each axis.
((before, after),) yields same before and after pad for each axis.
(pad,) or int is a shortcut for before = after = pad width for all
axes.</p>
</dd>
<dt>mode<span class="classifier">str or function, optional</span></dt><dd><p>One of the following string values or a user supplied function.</p>
<dl>
<dt>‘constant’ (default)</dt><dd><p>Pads with a constant value.</p>
</dd>
<dt>‘edge’</dt><dd><p>Pads with the edge values of array.</p>
</dd>
<dt>‘linear_ramp’</dt><dd><p>Pads with the linear ramp between end_value and the
array edge value.</p>
</dd>
<dt>‘maximum’</dt><dd><p>Pads with the maximum value of all or part of the
vector along each axis.</p>
</dd>
<dt>‘mean’</dt><dd><p>Pads with the mean value of all or part of the
vector along each axis.</p>
</dd>
<dt>‘median’</dt><dd><p>Pads with the median value of all or part of the
vector along each axis.</p>
</dd>
<dt>‘minimum’</dt><dd><p>Pads with the minimum value of all or part of the
vector along each axis.</p>
</dd>
<dt>‘reflect’</dt><dd><p>Pads with the reflection of the vector mirrored on
the first and last values of the vector along each
axis.</p>
</dd>
<dt>‘symmetric’</dt><dd><p>Pads with the reflection of the vector mirrored
along the edge of the array.</p>
</dd>
<dt>‘wrap’</dt><dd><p>Pads with the wrap of the vector along the axis.
The first values are used to pad the end and the
end values are used to pad the beginning.</p>
</dd>
<dt>‘empty’</dt><dd><p>Pads with undefined values.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.17.</span></p>
</div>
</dd>
<dt>&lt;function&gt;</dt><dd><p>Padding function, see Notes.</p>
</dd>
</dl>
</dd>
<dt>stat_length<span class="classifier">sequence or int, optional</span></dt><dd><p>Used in ‘maximum’, ‘mean’, ‘median’, and ‘minimum’.  Number of
values at edge of each axis used to calculate the statistic value.</p>
<p>((before_1, after_1), … (before_N, after_N)) unique statistic
lengths for each axis.</p>
<p>((before, after),) yields same before and after statistic lengths
for each axis.</p>
<p>(stat_length,) or int is a shortcut for before = after = statistic
length for all axes.</p>
<p>Default is <code class="docutils literal notranslate"><span class="pre">None</span></code>, to use the entire axis.</p>
</dd>
<dt>constant_values<span class="classifier">sequence or scalar, optional</span></dt><dd><p>Used in ‘constant’.  The values to set the padded values for each
axis.</p>
<p><code class="docutils literal notranslate"><span class="pre">((before_1,</span> <span class="pre">after_1),</span> <span class="pre">...</span> <span class="pre">(before_N,</span> <span class="pre">after_N))</span></code> unique pad constants
for each axis.</p>
<p><code class="docutils literal notranslate"><span class="pre">((before,</span> <span class="pre">after),)</span></code> yields same before and after constants for each
axis.</p>
<p><code class="docutils literal notranslate"><span class="pre">(constant,)</span></code> or <code class="docutils literal notranslate"><span class="pre">constant</span></code> is a shortcut for <code class="docutils literal notranslate"><span class="pre">before</span> <span class="pre">=</span> <span class="pre">after</span> <span class="pre">=</span> <span class="pre">constant</span></code> for
all axes.</p>
<p>Default is 0.</p>
</dd>
<dt>end_values<span class="classifier">sequence or scalar, optional</span></dt><dd><p>Used in ‘linear_ramp’.  The values used for the ending value of the
linear_ramp and that will form the edge of the padded array.</p>
<p><code class="docutils literal notranslate"><span class="pre">((before_1,</span> <span class="pre">after_1),</span> <span class="pre">...</span> <span class="pre">(before_N,</span> <span class="pre">after_N))</span></code> unique end values
for each axis.</p>
<p><code class="docutils literal notranslate"><span class="pre">((before,</span> <span class="pre">after),)</span></code> yields same before and after end values for each
axis.</p>
<p><code class="docutils literal notranslate"><span class="pre">(constant,)</span></code> or <code class="docutils literal notranslate"><span class="pre">constant</span></code> is a shortcut for <code class="docutils literal notranslate"><span class="pre">before</span> <span class="pre">=</span> <span class="pre">after</span> <span class="pre">=</span> <span class="pre">constant</span></code> for
all axes.</p>
<p>Default is 0.</p>
</dd>
<dt>reflect_type<span class="classifier">{‘even’, ‘odd’}, optional</span></dt><dd><p>Used in ‘reflect’, and ‘symmetric’.  The ‘even’ style is the
default with an unaltered reflection around the edge value.  For
the ‘odd’ style, the extended part of the array is created by
subtracting the reflected values from two times the edge value.</p>
</dd>
</dl>
<dl class="simple">
<dt>pad<span class="classifier">ndarray</span></dt><dd><p>Padded array of rank equal to <cite>array</cite> with shape increased
according to <cite>pad_width</cite>.</p>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<p>For an array with rank greater than 1, some of the padding of later
axes is calculated from padding of previous axes.  This is easiest to
think about with a rank 2 array where the corners of the padded array
are calculated by using padded values from the first axis.</p>
<p>The padding function, if used, should modify a rank 1 array in-place. It
has the following signature:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">padding_func</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">iaxis_pad_width</span><span class="p">,</span> <span class="n">iaxis</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
<p>where</p>
<blockquote>
<div><dl class="simple">
<dt>vector<span class="classifier">ndarray</span></dt><dd><p>A rank 1 array already padded with zeros.  Padded values are
vector[:iaxis_pad_width[0]] and vector[-iaxis_pad_width[1]:].</p>
</dd>
<dt>iaxis_pad_width<span class="classifier">tuple</span></dt><dd><p>A 2-tuple of ints, iaxis_pad_width[0] represents the number of
values padded at the beginning of vector where
iaxis_pad_width[1] represents the number of values padded at
the end of vector.</p>
</dd>
<dt>iaxis<span class="classifier">int</span></dt><dd><p>The axis currently being calculated.</p>
</dd>
<dt>kwargs<span class="classifier">dict</span></dt><dd><p>Any keyword arguments the function requires.</p>
</dd>
</dl>
</div></blockquote>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="go">array([4, 4, 1, ..., 6, 6, 6])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;edge&#39;</span><span class="p">)</span>
<span class="go">array([1, 1, 1, ..., 5, 5, 5])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;linear_ramp&#39;</span><span class="p">,</span> <span class="n">end_values</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">))</span>
<span class="go">array([ 5,  3,  1,  2,  3,  4,  5,  2, -1, -4])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="s1">&#39;maximum&#39;</span><span class="p">)</span>
<span class="go">array([5, 5, 1, 2, 3, 4, 5, 5, 5])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="s1">&#39;mean&#39;</span><span class="p">)</span>
<span class="go">array([3, 3, 1, 2, 3, 4, 5, 3, 3])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="s1">&#39;median&#39;</span><span class="p">)</span>
<span class="go">array([3, 3, 1, 2, 3, 4, 5, 3, 3])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span> <span class="s1">&#39;minimum&#39;</span><span class="p">)</span>
<span class="go">array([[1, 1, 1, 2, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 2, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 2, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 2, 1, 1, 1],</span>
<span class="go">       [3, 3, 3, 4, 3, 3, 3],</span>
<span class="go">       [1, 1, 1, 2, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 2, 1, 1, 1]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;reflect&#39;</span><span class="p">)</span>
<span class="go">array([3, 2, 1, 2, 3, 4, 5, 4, 3, 2])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;reflect&#39;</span><span class="p">,</span> <span class="n">reflect_type</span><span class="o">=</span><span class="s1">&#39;odd&#39;</span><span class="p">)</span>
<span class="go">array([-1,  0,  1,  2,  3,  4,  5,  6,  7,  8])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;symmetric&#39;</span><span class="p">)</span>
<span class="go">array([2, 1, 1, 2, 3, 4, 5, 5, 4, 3])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;symmetric&#39;</span><span class="p">,</span> <span class="n">reflect_type</span><span class="o">=</span><span class="s1">&#39;odd&#39;</span><span class="p">)</span>
<span class="go">array([0, 1, 1, 2, 3, 4, 5, 5, 6, 7])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;wrap&#39;</span><span class="p">)</span>
<span class="go">array([4, 5, 1, 2, 3, 4, 5, 1, 2, 3])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">pad_with</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">iaxis</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">pad_value</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;padder&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">vector</span><span class="p">[:</span><span class="n">pad_width</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">pad_value</span>
<span class="gp">... </span>    <span class="n">vector</span><span class="p">[</span><span class="o">-</span><span class="n">pad_width</span><span class="p">[</span><span class="mi">1</span><span class="p">]:]</span> <span class="o">=</span> <span class="n">pad_value</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">pad_with</span><span class="p">)</span>
<span class="go">array([[10, 10, 10, 10, 10, 10, 10],</span>
<span class="go">       [10, 10, 10, 10, 10, 10, 10],</span>
<span class="go">       [10, 10,  0,  1,  2, 10, 10],</span>
<span class="go">       [10, 10,  3,  4,  5, 10, 10],</span>
<span class="go">       [10, 10, 10, 10, 10, 10, 10],</span>
<span class="go">       [10, 10, 10, 10, 10, 10, 10]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">pad_with</span><span class="p">,</span> <span class="n">padder</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="go">array([[100, 100, 100, 100, 100, 100, 100],</span>
<span class="go">       [100, 100, 100, 100, 100, 100, 100],</span>
<span class="go">       [100, 100,   0,   1,   2, 100, 100],</span>
<span class="go">       [100, 100,   3,   4,   5, 100, 100],</span>
<span class="go">       [100, 100, 100, 100, 100, 100, 100],</span>
<span class="go">       [100, 100, 100, 100, 100, 100, 100]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.partition">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">partition</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'introselect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.partition" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a partitioned copy of an array.</p>
<p>Creates a copy of the array with its elements rearranged in such a
way that the value of the element in k-th position is in the
position it would be in a sorted array. All elements smaller than
the k-th element are moved before this element and all equal or
greater are moved behind it. The ordering of the elements in the two
partitions is undefined.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>Array to be sorted.</p>
</dd>
<dt>kth<span class="classifier">int or sequence of ints</span></dt><dd><p>Element index to partition by. The k-th value of the element
will be in its final sorted position and all smaller elements
will be moved before it and all equal or greater elements behind
it. The order of all elements in the partitions is undefined. If
provided with a sequence of k-th it will partition all elements
indexed by k-th  of them into their sorted position at once.</p>
</dd>
<dt>axis<span class="classifier">int or None, optional</span></dt><dd><p>Axis along which to sort. If None, the array is flattened before
sorting. The default is -1, which sorts along the last axis.</p>
</dd>
<dt>kind<span class="classifier">{‘introselect’}, optional</span></dt><dd><p>Selection algorithm. Default is ‘introselect’.</p>
</dd>
<dt>order<span class="classifier">str or list of str, optional</span></dt><dd><p>When <cite>a</cite> is an array with fields defined, this argument
specifies which fields to compare first, second, etc.  A single
field can be specified as a string.  Not all fields need be
specified, but unspecified fields will still be used, in the
order in which they come up in the dtype, to break ties.</p>
</dd>
</dl>
<dl class="simple">
<dt>partitioned_array<span class="classifier">ndarray</span></dt><dd><p>Array of the same type and shape as <cite>a</cite>.</p>
</dd>
</dl>
<p>ndarray.partition : Method to sort an array in-place.
argpartition : Indirect partition.
sort : Full sorting</p>
<p>The various selection algorithms are characterized by their average
speed, worst case performance, work space size, and whether they are
stable. A stable sort keeps items with the same key in the same
relative order. The available algorithms have the following
properties:</p>
<table class="table">
<colgroup>
<col style="width: 30%" />
<col style="width: 13%" />
<col style="width: 23%" />
<col style="width: 21%" />
<col style="width: 13%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>kind</p></th>
<th class="head"><p>speed</p></th>
<th class="head"><p>worst case</p></th>
<th class="head"><p>work space</p></th>
<th class="head"><p>stable</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>‘introselect’</p></td>
<td><p>1</p></td>
<td><p>O(n)</p></td>
<td><p>0</p></td>
<td><p>no</p></td>
</tr>
</tbody>
</table>
<p>All the partition algorithms make temporary copies of the data when
partitioning along any but the last axis.  Consequently,
partitioning along the last axis is faster and uses less space than
partitioning along any other axis.</p>
<p>The sort order for complex numbers is lexicographic. If both the
real and imaginary parts are non-nan then the order is determined by
the real parts except when they are equal, in which case the order
is determined by the imaginary parts.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">array([2, 1, 3, 4])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">array([1, 2, 3, 4])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.percentile">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">percentile</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite_input</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interpolation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keepdims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.percentile" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the q-th percentile of the data along the specified axis.</p>
<p>Returns the q-th percentile(s) of the array elements.</p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input array or object that can be converted to an array.</p>
</dd>
<dt>q<span class="classifier">array_like of float</span></dt><dd><p>Percentile or sequence of percentiles to compute, which must be between
0 and 100 inclusive.</p>
</dd>
<dt>axis<span class="classifier">{int, tuple of int, None}, optional</span></dt><dd><p>Axis or axes along which the percentiles are computed. The
default is to compute the percentile(s) along a flattened
version of the array.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.9.0: </span>A tuple of axes is supported</p>
</div>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output,
but the type (of the output) will be cast if necessary.</p>
</dd>
<dt>overwrite_input<span class="classifier">bool, optional</span></dt><dd><p>If True, then allow the input array <cite>a</cite> to be modified by intermediate
calculations, to save memory. In this case, the contents of the input
<cite>a</cite> after this function completes is undefined.</p>
</dd>
<dt>interpolation<span class="classifier">{‘linear’, ‘lower’, ‘higher’, ‘midpoint’, ‘nearest’}</span></dt><dd><p>This optional parameter specifies the interpolation method to
use when the desired percentile lies between two data points
<code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">j</span></code>:</p>
<ul class="simple">
<li><p>‘linear’: <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">(j</span> <span class="pre">-</span> <span class="pre">i)</span> <span class="pre">*</span> <span class="pre">fraction</span></code>, where <code class="docutils literal notranslate"><span class="pre">fraction</span></code>
is the fractional part of the index surrounded by <code class="docutils literal notranslate"><span class="pre">i</span></code>
and <code class="docutils literal notranslate"><span class="pre">j</span></code>.</p></li>
<li><p>‘lower’: <code class="docutils literal notranslate"><span class="pre">i</span></code>.</p></li>
<li><p>‘higher’: <code class="docutils literal notranslate"><span class="pre">j</span></code>.</p></li>
<li><p>‘nearest’: <code class="docutils literal notranslate"><span class="pre">i</span></code> or <code class="docutils literal notranslate"><span class="pre">j</span></code>, whichever is nearest.</p></li>
<li><p>‘midpoint’: <code class="docutils literal notranslate"><span class="pre">(i</span> <span class="pre">+</span> <span class="pre">j)</span> <span class="pre">/</span> <span class="pre">2</span></code>.</p></li>
</ul>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.9.0.</span></p>
</div>
</dd>
<dt>keepdims<span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left in
the result as dimensions with size one. With this option, the
result will broadcast correctly against the original array <cite>a</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.9.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>percentile<span class="classifier">scalar or ndarray</span></dt><dd><p>If <cite>q</cite> is a single percentile and <cite>axis=None</cite>, then the result
is a scalar. If multiple percentiles are given, first axis of
the result corresponds to the percentiles. The other axes are
the axes that remain after the reduction of <cite>a</cite>. If the input
contains integers or floats smaller than <code class="docutils literal notranslate"><span class="pre">float64</span></code>, the output
data-type is <code class="docutils literal notranslate"><span class="pre">float64</span></code>. Otherwise, the output data-type is the
same as that of the input. If <cite>out</cite> is specified, that array is
returned instead.</p>
</dd>
</dl>
<p>mean
median : equivalent to <code class="docutils literal notranslate"><span class="pre">percentile(...,</span> <span class="pre">50)</span></code>
nanpercentile
quantile : equivalent to percentile, except with q in the range [0, 1].</p>
<p>Given a vector <code class="docutils literal notranslate"><span class="pre">V</span></code> of length <code class="docutils literal notranslate"><span class="pre">N</span></code>, the q-th percentile of
<code class="docutils literal notranslate"><span class="pre">V</span></code> is the value <code class="docutils literal notranslate"><span class="pre">q/100</span></code> of the way from the minimum to the
maximum in a sorted copy of <code class="docutils literal notranslate"><span class="pre">V</span></code>. The values and distances of
the two nearest neighbors as well as the <cite>interpolation</cite> parameter
will determine the percentile if the normalized ranking does not
match the location of <code class="docutils literal notranslate"><span class="pre">q</span></code> exactly. This function is the same as
the median if <code class="docutils literal notranslate"><span class="pre">q=50</span></code>, the same as the minimum if <code class="docutils literal notranslate"><span class="pre">q=0</span></code> and the
same as the maximum if <code class="docutils literal notranslate"><span class="pre">q=100</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[10,  7,  4],</span>
<span class="go">       [ 3,  2,  1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="go">3.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([6.5, 4.5, 2.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([7.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([[7.],</span>
<span class="go">       [2.]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
<span class="go">array([6.5, 4.5, 2.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">array([6.5, 4.5, 2.5])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([7.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>The different types of interpolation can be visualized graphically:</p>
</dd></dl>

<dl class="py function">
<dt id="numpy.piecewise">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">piecewise</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">condlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">funclist</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.piecewise" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate a piecewise-defined function.</p>
<p>Given a set of conditions and corresponding functions, evaluate each
function on the input data wherever its condition is true.</p>
<dl>
<dt>x<span class="classifier">ndarray or scalar</span></dt><dd><p>The input domain.</p>
</dd>
<dt>condlist<span class="classifier">list of bool arrays or bool scalars</span></dt><dd><p>Each boolean array corresponds to a function in <cite>funclist</cite>.  Wherever
<cite>condlist[i]</cite> is True, <cite>funclist[i](x)</cite> is used as the output value.</p>
<p>Each boolean array in <cite>condlist</cite> selects a piece of <cite>x</cite>,
and should therefore be of the same shape as <cite>x</cite>.</p>
<p>The length of <cite>condlist</cite> must correspond to that of <cite>funclist</cite>.
If one extra function is given, i.e. if
<code class="docutils literal notranslate"><span class="pre">len(funclist)</span> <span class="pre">==</span> <span class="pre">len(condlist)</span> <span class="pre">+</span> <span class="pre">1</span></code>, then that extra function
is the default value, used wherever all conditions are false.</p>
</dd>
<dt>funclist<span class="classifier">list of callables, f(x,*args,**kw), or scalars</span></dt><dd><p>Each function is evaluated over <cite>x</cite> wherever its corresponding
condition is True.  It should take a 1d array as input and give an 1d
array or a scalar value as output.  If, instead of a callable,
a scalar is provided then a constant function (<code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">x:</span> <span class="pre">scalar</span></code>) is
assumed.</p>
</dd>
<dt>args<span class="classifier">tuple, optional</span></dt><dd><p>Any further arguments given to <cite>piecewise</cite> are passed to the functions
upon execution, i.e., if called <code class="docutils literal notranslate"><span class="pre">piecewise(...,</span> <span class="pre">...,</span> <span class="pre">1,</span> <span class="pre">'a')</span></code>, then
each function is called as <code class="docutils literal notranslate"><span class="pre">f(x,</span> <span class="pre">1,</span> <span class="pre">'a')</span></code>.</p>
</dd>
<dt>kw<span class="classifier">dict, optional</span></dt><dd><p>Keyword arguments used in calling <cite>piecewise</cite> are passed to the
functions upon execution, i.e., if called
<code class="docutils literal notranslate"><span class="pre">piecewise(...,</span> <span class="pre">...,</span> <span class="pre">alpha=1)</span></code>, then each function is called as
<code class="docutils literal notranslate"><span class="pre">f(x,</span> <span class="pre">alpha=1)</span></code>.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>The output is the same shape and type as x and is found by
calling the functions in <cite>funclist</cite> on the appropriate portions of <cite>x</cite>,
as defined by the boolean arrays in <cite>condlist</cite>.  Portions not covered
by any condition have a default value of 0.</p>
</dd>
</dl>
<p>choose, select, where</p>
<p>This is similar to choose or select, except that functions are
evaluated on elements of <cite>x</cite> that satisfy the corresponding condition from
<cite>condlist</cite>.</p>
<p>The result is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>      <span class="o">|--</span>
      <span class="o">|</span><span class="n">funclist</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">x</span><span class="p">[</span><span class="n">condlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
<span class="n">out</span> <span class="o">=</span> <span class="o">|</span><span class="n">funclist</span><span class="p">[</span><span class="mi">1</span><span class="p">](</span><span class="n">x</span><span class="p">[</span><span class="n">condlist</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
      <span class="o">|...</span>
      <span class="o">|</span><span class="n">funclist</span><span class="p">[</span><span class="n">n2</span><span class="p">](</span><span class="n">x</span><span class="p">[</span><span class="n">condlist</span><span class="p">[</span><span class="n">n2</span><span class="p">]])</span>
      <span class="o">|--</span>
</pre></div>
</div>
<p>Define the sigma function, which is -1 for <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">0</span></code> and +1 for <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">piecewise</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">array([-1., -1., -1.,  1.,  1.,  1.])</span>
</pre></div>
</div>
<p>Define the absolute value, which is <code class="docutils literal notranslate"><span class="pre">-x</span></code> for <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;0</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code> for
<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">piecewise</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">x</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">])</span>
<span class="go">array([2.5,  1.5,  0.5,  0.5,  1.5,  2.5])</span>
</pre></div>
</div>
<p>Apply the same function to a scalar value.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">piecewise</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">x</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">])</span>
<span class="go">array(2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.place">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">place</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vals</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.place" title="Permalink to this definition">¶</a></dt>
<dd><p>Change elements of an array based on conditional and input values.</p>
<p>Similar to <code class="docutils literal notranslate"><span class="pre">np.copyto(arr,</span> <span class="pre">vals,</span> <span class="pre">where=mask)</span></code>, the difference is that
<cite>place</cite> uses the first N elements of <cite>vals</cite>, where N is the number of
True values in <cite>mask</cite>, while <cite>copyto</cite> uses the elements where <cite>mask</cite>
is True.</p>
<p>Note that <cite>extract</cite> does the exact opposite of <cite>place</cite>.</p>
<dl class="simple">
<dt>arr<span class="classifier">ndarray</span></dt><dd><p>Array to put data into.</p>
</dd>
<dt>mask<span class="classifier">array_like</span></dt><dd><p>Boolean mask array. Must have the same size as <cite>a</cite>.</p>
</dd>
<dt>vals<span class="classifier">1-D sequence</span></dt><dd><p>Values to put into <cite>a</cite>. Only the first N elements are used, where
N is the number of True values in <cite>mask</cite>. If <cite>vals</cite> is smaller
than N, it will be repeated, and if elements of <cite>a</cite> are to be masked,
this sequence must be non-empty.</p>
</dd>
</dl>
<p>copyto, put, take, extract</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">44</span><span class="p">,</span> <span class="mi">55</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span>
<span class="go">array([[ 0,  1,  2],</span>
<span class="go">       [44, 55, 44]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.poly">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">poly</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq_of_zeros</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.poly" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the coefficients of a polynomial with the given sequence of roots.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This forms part of the old polynomial API. Since version 1.4, the
new polynomial API defined in <cite>numpy.polynomial</cite> is preferred.
A summary of the differences can be found in the
<span class="xref std std-doc">transition guide</span>.</p>
</div>
<p>Returns the coefficients of the polynomial whose leading coefficient
is one for the given sequence of zeros (multiple roots must be included
in the sequence as many times as their multiplicity; see Examples).
A square matrix (or array, which will be treated as a matrix) can also
be given, in which case the coefficients of the characteristic polynomial
of the matrix are returned.</p>
<dl class="simple">
<dt>seq_of_zeros<span class="classifier">array_like, shape (N,) or (N, N)</span></dt><dd><p>A sequence of polynomial roots, or a square array or matrix object.</p>
</dd>
</dl>
<dl>
<dt>c<span class="classifier">ndarray</span></dt><dd><p>1D array of polynomial coefficients from highest to lowest degree:</p>
<p><code class="docutils literal notranslate"><span class="pre">c[0]</span> <span class="pre">*</span> <span class="pre">x**(N)</span> <span class="pre">+</span> <span class="pre">c[1]</span> <span class="pre">*</span> <span class="pre">x**(N-1)</span> <span class="pre">+</span> <span class="pre">...</span> <span class="pre">+</span> <span class="pre">c[N-1]</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">c[N]</span></code>
where c[0] always equals 1.</p>
</dd>
</dl>
<dl class="simple">
<dt>ValueError</dt><dd><p>If input is the wrong shape (the input must be a 1-D or square
2-D array).</p>
</dd>
</dl>
<p>polyval : Compute polynomial values.
roots : Return the roots of a polynomial.
polyfit : Least squares polynomial fit.
poly1d : A one-dimensional polynomial class.</p>
<p>Specifying the roots of a polynomial still leaves one degree of
freedom, typically represented by an undetermined leading
coefficient. <a href="#id89"><span class="problematic" id="id49">[1]_</span></a> In the case of this function, that coefficient -
the first one in the returned array - is always taken as one. (If
for some reason you have one other point, the only automatic way
presently to leverage that information is to use <code class="docutils literal notranslate"><span class="pre">polyfit</span></code>.)</p>
<p>The characteristic polynomial, <span class="math notranslate nohighlight">\(p_a(t)\)</span>, of an <cite>n</cite>-by-<cite>n</cite>
matrix <strong>A</strong> is given by</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(p_a(t) = \mathrm{det}(t\, \mathbf{I} - \mathbf{A})\)</span>,</p>
</div></blockquote>
<p>where <strong>I</strong> is the <cite>n</cite>-by-<cite>n</cite> identity matrix. <a href="#id90"><span class="problematic" id="id50">[2]_</span></a></p>
<dl class="footnote brackets">
<dt class="label" id="id51"><span class="brackets">1</span></dt>
<dd><p>M. Sullivan and M. Sullivan, III, “Algebra and Trignometry,
Enhanced With Graphing Utilities,” Prentice-Hall, pg. 318, 1996.</p>
</dd>
<dt class="label" id="id52"><span class="brackets">2</span></dt>
<dd><p>G. Strang, “Linear Algebra and Its Applications, 2nd Edition,”
Academic Press, pg. 182, 1980.</p>
</dd>
</dl>
<p>Given a sequence of a polynomial’s zeros:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">poly</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="c1"># Multiple root example</span>
<span class="go">array([1., 0., 0., 0.])</span>
</pre></div>
</div>
<p>The line above represents z**3 + 0*z**2 + 0*z + 0.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">poly</span><span class="p">((</span><span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1.</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
<span class="go">array([ 1.  ,  0.  , -0.25,  0.  ])</span>
</pre></div>
</div>
<p>The line above represents z**3 - z/4</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">poly</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span>
<span class="go">array([ 1.        , -0.77086955,  0.08618131,  0.        ]) # random</span>
</pre></div>
</div>
<p>Given a square array object:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.</span><span class="o">/</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">poly</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="go">array([1.        , 0.        , 0.16666667])</span>
</pre></div>
</div>
<p>Note how in all cases the leading coefficient is always 1.</p>
</dd></dl>

<dl class="py class">
<dt id="numpy.poly1d">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">poly1d</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">c_or_r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.poly1d" title="Permalink to this definition">¶</a></dt>
<dd><p>A one-dimensional polynomial class.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This forms part of the old polynomial API. Since version 1.4, the
new polynomial API defined in <cite>numpy.polynomial</cite> is preferred.
A summary of the differences can be found in the
<span class="xref std std-doc">transition guide</span>.</p>
</div>
<p>A convenience class, used to encapsulate “natural” operations on
polynomials so that said operations may take on their customary
form in code (see Examples).</p>
<dl class="simple">
<dt>c_or_r<span class="classifier">array_like</span></dt><dd><p>The polynomial’s coefficients, in decreasing powers, or if
the value of the second parameter is True, the polynomial’s
roots (values where the polynomial evaluates to 0).  For example,
<code class="docutils literal notranslate"><span class="pre">poly1d([1,</span> <span class="pre">2,</span> <span class="pre">3])</span></code> returns an object that represents
<span class="math notranslate nohighlight">\(x^2 + 2x + 3\)</span>, whereas <code class="docutils literal notranslate"><span class="pre">poly1d([1,</span> <span class="pre">2,</span> <span class="pre">3],</span> <span class="pre">True)</span></code> returns
one that represents <span class="math notranslate nohighlight">\((x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x -6\)</span>.</p>
</dd>
<dt>r<span class="classifier">bool, optional</span></dt><dd><p>If True, <cite>c_or_r</cite> specifies the polynomial’s roots; the default
is False.</p>
</dd>
<dt>variable<span class="classifier">str, optional</span></dt><dd><p>Changes the variable used when printing <cite>p</cite> from <cite>x</cite> to <cite>variable</cite>
(see Examples).</p>
</dd>
</dl>
<p>Construct the polynomial <span class="math notranslate nohighlight">\(x^2 + 2x + 3\)</span>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
<span class="go">   2</span>
<span class="go">1 x + 2 x + 3</span>
</pre></div>
</div>
<p>Evaluate the polynomial at <span class="math notranslate nohighlight">\(x = 0.5\)</span>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">4.25</span>
</pre></div>
</div>
<p>Find the roots:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">r</span>
<span class="go">array([-1.+1.41421356j, -1.-1.41421356j])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">r</span><span class="p">)</span>
<span class="go">array([ -4.44089210e-16+0.j,  -4.44089210e-16+0.j]) # may vary</span>
</pre></div>
</div>
<p>These numbers in the previous line represent (0, 0) to machine precision</p>
<p>Show the coefficients:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">c</span>
<span class="go">array([1, 2, 3])</span>
</pre></div>
</div>
<p>Display the order (the leading zero-coefficients are removed):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">order</span>
<span class="go">2</span>
</pre></div>
</div>
<p>Show the coefficient of the k-th power in the polynomial
(which is equivalent to <code class="docutils literal notranslate"><span class="pre">p.c[-(i+1)]</span></code>):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">2</span>
</pre></div>
</div>
<p>Polynomials can be added, subtracted, multiplied, and divided
(returns quotient and remainder):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">*</span> <span class="n">p</span>
<span class="go">poly1d([ 1,  4, 10, 12,  9])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">/</span> <span class="n">p</span>
<span class="go">(poly1d([ 1.,  4., 10., 12.,  9.]), poly1d([4.]))</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">asarray(p)</span></code> gives the coefficient array, so polynomials can be
used in all functions that accept arrays:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="c1"># square of polynomial</span>
<span class="go">poly1d([ 1,  4, 10, 12,  9])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="c1"># square of individual coefficients</span>
<span class="go">array([1, 4, 9])</span>
</pre></div>
</div>
<p>The variable used in the string representation of <cite>p</cite> can be modified,
using the <cite>variable</cite> parameter:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">variable</span><span class="o">=</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">   2</span>
<span class="go">1 z + 2 z + 3</span>
</pre></div>
</div>
<p>Construct a polynomial from its roots:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">poly1d([ 1., -3.,  2.])</span>
</pre></div>
</div>
<p>This is the same polynomial as obtained by:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">])</span>
<span class="go">poly1d([ 1, -3,  2])</span>
</pre></div>
</div>
<dl class="py method">
<dt id="numpy.poly1d.c">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">c</span></code><a class="headerlink" href="#numpy.poly1d.c" title="Permalink to this definition">¶</a></dt>
<dd><p>The polynomial coefficients</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.poly1d.coef">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">coef</span></code><a class="headerlink" href="#numpy.poly1d.coef" title="Permalink to this definition">¶</a></dt>
<dd><p>The polynomial coefficients</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.poly1d.coefficients">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">coefficients</span></code><a class="headerlink" href="#numpy.poly1d.coefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>The polynomial coefficients</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.poly1d.coeffs">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">coeffs</span></code><a class="headerlink" href="#numpy.poly1d.coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>The polynomial coefficients</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.poly1d.deriv">
<code class="sig-name descname"><span class="pre">deriv</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.poly1d.deriv" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a derivative of this polynomial.</p>
<p>Refer to <cite>polyder</cite> for full documentation.</p>
<p>polyder : equivalent function</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.poly1d.integ">
<code class="sig-name descname"><span class="pre">integ</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.poly1d.integ" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an antiderivative (indefinite integral) of this polynomial.</p>
<p>Refer to <cite>polyint</cite> for full documentation.</p>
<p>polyint : equivalent function</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.poly1d.o">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">o</span></code><a class="headerlink" href="#numpy.poly1d.o" title="Permalink to this definition">¶</a></dt>
<dd><p>The order or degree of the polynomial</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.poly1d.order">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">order</span></code><a class="headerlink" href="#numpy.poly1d.order" title="Permalink to this definition">¶</a></dt>
<dd><p>The order or degree of the polynomial</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.poly1d.r">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">r</span></code><a class="headerlink" href="#numpy.poly1d.r" title="Permalink to this definition">¶</a></dt>
<dd><p>The roots of the polynomial, where self(x) == 0</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.poly1d.roots">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">roots</span></code><a class="headerlink" href="#numpy.poly1d.roots" title="Permalink to this definition">¶</a></dt>
<dd><p>The roots of the polynomial, where self(x) == 0</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.poly1d.variable">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">variable</span></code><a class="headerlink" href="#numpy.poly1d.variable" title="Permalink to this definition">¶</a></dt>
<dd><p>The name of the polynomial variable</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="numpy.polyadd">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">polyadd</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.polyadd" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the sum of two polynomials.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This forms part of the old polynomial API. Since version 1.4, the
new polynomial API defined in <cite>numpy.polynomial</cite> is preferred.
A summary of the differences can be found in the
<span class="xref std std-doc">transition guide</span>.</p>
</div>
<p>Returns the polynomial resulting from the sum of two input polynomials.
Each input must be either a poly1d object or a 1D sequence of polynomial
coefficients, from highest to lowest degree.</p>
<dl class="simple">
<dt>a1, a2<span class="classifier">array_like or poly1d object</span></dt><dd><p>Input polynomials.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray or poly1d object</span></dt><dd><p>The sum of the inputs. If either input is a poly1d object, then the
output is also a poly1d object. Otherwise, it is a 1D array of
polynomial coefficients from highest to lowest degree.</p>
</dd>
</dl>
<p>poly1d : A one-dimensional polynomial class.
poly, polyadd, polyder, polydiv, polyfit, polyint, polysub, polyval</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">polyadd</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="go">array([9, 6, 6])</span>
</pre></div>
</div>
<p>Using poly1d objects:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>
<span class="go">1 x + 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>
<span class="go">   2</span>
<span class="go">9 x + 5 x + 4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyadd</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">))</span>
<span class="go">   2</span>
<span class="go">9 x + 6 x + 6</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.polyder">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">polyder</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.polyder" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the derivative of the specified order of a polynomial.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This forms part of the old polynomial API. Since version 1.4, the
new polynomial API defined in <cite>numpy.polynomial</cite> is preferred.
A summary of the differences can be found in the
<span class="xref std std-doc">transition guide</span>.</p>
</div>
<dl class="simple">
<dt>p<span class="classifier">poly1d or sequence</span></dt><dd><p>Polynomial to differentiate.
A sequence is interpreted as polynomial coefficients, see <cite>poly1d</cite>.</p>
</dd>
<dt>m<span class="classifier">int, optional</span></dt><dd><p>Order of differentiation (default: 1)</p>
</dd>
</dl>
<dl class="simple">
<dt>der<span class="classifier">poly1d</span></dt><dd><p>A new polynomial representing the derivative.</p>
</dd>
</dl>
<p>polyint : Anti-derivative of a polynomial.
poly1d : Class for one-dimensional polynomials.</p>
<p>The derivative of the polynomial <span class="math notranslate nohighlight">\(x^3 + x^2 + x^1 + 1\)</span> is:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyder</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span>
<span class="go">poly1d([3, 2, 1])</span>
</pre></div>
</div>
<p>which evaluates to:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span><span class="p">(</span><span class="mf">2.</span><span class="p">)</span>
<span class="go">17.0</span>
</pre></div>
</div>
<p>We can verify this, approximating the derivative with
<code class="docutils literal notranslate"><span class="pre">(f(x</span> <span class="pre">+</span> <span class="pre">h)</span> <span class="pre">-</span> <span class="pre">f(x))/h</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="mf">2.</span> <span class="o">+</span> <span class="mf">0.001</span><span class="p">)</span> <span class="o">-</span> <span class="n">p</span><span class="p">(</span><span class="mf">2.</span><span class="p">))</span> <span class="o">/</span> <span class="mf">0.001</span>
<span class="go">17.007000999997857</span>
</pre></div>
</div>
<p>The fourth-order derivative of a 3rd-order polynomial is zero:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">polyder</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">poly1d([6, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">polyder</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">poly1d([6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">polyder</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">poly1d([0])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.polydiv">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">polydiv</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.polydiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the quotient and remainder of polynomial division.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This forms part of the old polynomial API. Since version 1.4, the
new polynomial API defined in <cite>numpy.polynomial</cite> is preferred.
A summary of the differences can be found in the
<span class="xref std std-doc">transition guide</span>.</p>
</div>
<p>The input arrays are the coefficients (including any coefficients
equal to zero) of the “numerator” (dividend) and “denominator”
(divisor) polynomials, respectively.</p>
<dl class="simple">
<dt>u<span class="classifier">array_like or poly1d</span></dt><dd><p>Dividend polynomial’s coefficients.</p>
</dd>
<dt>v<span class="classifier">array_like or poly1d</span></dt><dd><p>Divisor polynomial’s coefficients.</p>
</dd>
</dl>
<dl class="simple">
<dt>q<span class="classifier">ndarray</span></dt><dd><p>Coefficients, including those equal to zero, of the quotient.</p>
</dd>
<dt>r<span class="classifier">ndarray</span></dt><dd><p>Coefficients, including those equal to zero, of the remainder.</p>
</dd>
</dl>
<p>poly, polyadd, polyder, polydiv, polyfit, polyint, polymul, polysub
polyval</p>
<p>Both <cite>u</cite> and <cite>v</cite> must be 0-d or 1-d (ndim = 0 or 1), but <cite>u.ndim</cite> need
not equal <cite>v.ndim</cite>. In other words, all four possible combinations -
<code class="docutils literal notranslate"><span class="pre">u.ndim</span> <span class="pre">=</span> <span class="pre">v.ndim</span> <span class="pre">=</span> <span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">u.ndim</span> <span class="pre">=</span> <span class="pre">v.ndim</span> <span class="pre">=</span> <span class="pre">1</span></code>,
<code class="docutils literal notranslate"><span class="pre">u.ndim</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">v.ndim</span> <span class="pre">=</span> <span class="pre">0</span></code>, and <code class="docutils literal notranslate"><span class="pre">u.ndim</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">v.ndim</span> <span class="pre">=</span> <span class="pre">1</span></code> - work.</p>
<div class="math notranslate nohighlight">
\[\frac{3x^2 + 5x + 2}{2x + 1} = 1.5x + 1.75, remainder 0.25\]</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">polydiv</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">(array([1.5 , 1.75]), array([0.25]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.polyfit">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">polyfit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cov</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.polyfit" title="Permalink to this definition">¶</a></dt>
<dd><p>Least squares polynomial fit.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This forms part of the old polynomial API. Since version 1.4, the
new polynomial API defined in <cite>numpy.polynomial</cite> is preferred.
A summary of the differences can be found in the
<span class="xref std std-doc">transition guide</span>.</p>
</div>
<p>Fit a polynomial <code class="docutils literal notranslate"><span class="pre">p(x)</span> <span class="pre">=</span> <span class="pre">p[0]</span> <span class="pre">*</span> <span class="pre">x**deg</span> <span class="pre">+</span> <span class="pre">...</span> <span class="pre">+</span> <span class="pre">p[deg]</span></code> of degree <cite>deg</cite>
to points <cite>(x, y)</cite>. Returns a vector of coefficients <cite>p</cite> that minimises
the squared error in the order <cite>deg</cite>, <cite>deg-1</cite>, … <cite>0</cite>.</p>
<p>The <cite>Polynomial.fit &lt;numpy.polynomial.polynomial.Polynomial.fit&gt;</cite> class
method is recommended for new code as it is more stable numerically. See
the documentation of the method for more information.</p>
<dl class="simple">
<dt>x<span class="classifier">array_like, shape (M,)</span></dt><dd><p>x-coordinates of the M sample points <code class="docutils literal notranslate"><span class="pre">(x[i],</span> <span class="pre">y[i])</span></code>.</p>
</dd>
<dt>y<span class="classifier">array_like, shape (M,) or (M, K)</span></dt><dd><p>y-coordinates of the sample points. Several data sets of sample
points sharing the same x-coordinates can be fitted at once by
passing in a 2D-array that contains one dataset per column.</p>
</dd>
<dt>deg<span class="classifier">int</span></dt><dd><p>Degree of the fitting polynomial</p>
</dd>
<dt>rcond<span class="classifier">float, optional</span></dt><dd><p>Relative condition number of the fit. Singular values smaller than
this relative to the largest singular value will be ignored. The
default value is len(x)*eps, where eps is the relative precision of
the float type, about 2e-16 in most cases.</p>
</dd>
<dt>full<span class="classifier">bool, optional</span></dt><dd><p>Switch determining nature of return value. When it is False (the
default) just the coefficients are returned, when True diagnostic
information from the singular value decomposition is also returned.</p>
</dd>
<dt>w<span class="classifier">array_like, shape (M,), optional</span></dt><dd><p>Weights to apply to the y-coordinates of the sample points. For
gaussian uncertainties, use 1/sigma (not 1/sigma**2).</p>
</dd>
<dt>cov<span class="classifier">bool or str, optional</span></dt><dd><p>If given and not <cite>False</cite>, return not just the estimate but also its
covariance matrix. By default, the covariance are scaled by
chi2/dof, where dof = M - (deg + 1), i.e., the weights are presumed 
to be unreliable except in a relative sense and everything is scaled 
such that the reduced chi2 is unity. This scaling is omitted if 
<code class="docutils literal notranslate"><span class="pre">cov='unscaled'</span></code>, as is relevant for the case that the weights are 
1/sigma**2, with sigma known to be a reliable estimate of the 
uncertainty.</p>
</dd>
</dl>
<dl class="simple">
<dt>p<span class="classifier">ndarray, shape (deg + 1,) or (deg + 1, K)</span></dt><dd><p>Polynomial coefficients, highest power first.  If <cite>y</cite> was 2-D, the
coefficients for <cite>k</cite>-th data set are in <code class="docutils literal notranslate"><span class="pre">p[:,k]</span></code>.</p>
</dd>
<dt>residuals, rank, singular_values, rcond</dt><dd><p>Present only if <cite>full</cite> = True.  Residuals is sum of squared residuals
of the least-squares fit, the effective rank of the scaled Vandermonde
coefficient matrix, its singular values, and the specified value of
<cite>rcond</cite>. For more details, see <cite>linalg.lstsq</cite>.</p>
</dd>
<dt>V<span class="classifier">ndarray, shape (M,M) or (M,M,K)</span></dt><dd><p>Present only if <cite>full</cite> = False and <cite>cov`=True.  The covariance
matrix of the polynomial coefficient estimates.  The diagonal of
this matrix are the variance estimates for each coefficient.  If y
is a 2-D array, then the covariance matrix for the `k</cite>-th data set
are in <code class="docutils literal notranslate"><span class="pre">V[:,:,k]</span></code></p>
</dd>
</dl>
<dl>
<dt>RankWarning</dt><dd><p>The rank of the coefficient matrix in the least-squares fit is
deficient. The warning is only raised if <cite>full</cite> = False.</p>
<p>The warnings can be turned off by</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">warnings</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">RankWarning</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
<p>polyval : Compute polynomial values.
linalg.lstsq : Computes a least-squares fit.
scipy.interpolate.UnivariateSpline : Computes spline fits.</p>
<p>The solution minimizes the squared error</p>
<div class="math notranslate nohighlight">
\[E = \sum_{j=0}^k |p(x_j) - y_j|^2\]</div>
<p>in the equations:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="n">n</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="o">...</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="n">n</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="o">...</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="o">...</span>
<span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">**</span><span class="n">n</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="o">...</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
</pre></div>
</div>
<p>The coefficient matrix of the coefficients <cite>p</cite> is a Vandermonde matrix.</p>
<p><cite>polyfit</cite> issues a <cite>RankWarning</cite> when the least-squares fit is badly
conditioned. This implies that the best fit is not well-defined due
to numerical error. The results may be improved by lowering the polynomial
degree or by replacing <cite>x</cite> by <cite>x</cite> - <cite>x</cite>.mean(). The <cite>rcond</cite> parameter
can also be set to a value smaller than its default, but the resulting
fit may be spurious: including contributions from the small singular
values can add numerical noise to the result.</p>
<p>Note that fitting polynomial coefficients is inherently badly conditioned
when the degree of the polynomial is large or the interval of sample points
is badly centered. The quality of the fit should always be checked in these
cases. When polynomial fits are not satisfactory, splines may be a good
alternative.</p>
<dl class="footnote brackets">
<dt class="label" id="id53"><span class="brackets">1</span></dt>
<dd><p>Wikipedia, “Curve fitting”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Curve_fitting">https://en.wikipedia.org/wiki/Curve_fitting</a></p>
</dd>
<dt class="label" id="id54"><span class="brackets">2</span></dt>
<dd><p>Wikipedia, “Polynomial interpolation”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Polynomial_interpolation">https://en.wikipedia.org/wiki/Polynomial_interpolation</a></p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">warnings</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span>  <span class="mf">4.0</span><span class="p">,</span>  <span class="mf">5.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.8</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span>
<span class="go">array([ 0.08703704, -0.81349206,  1.69312169, -0.03968254]) # may vary</span>
</pre></div>
</div>
<p>It is convenient to use <cite>poly1d</cite> objects for dealing with polynomials:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">0.6143849206349179 # may vary</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">(</span><span class="mf">3.5</span><span class="p">)</span>
<span class="go">-0.34732142857143039 # may vary</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">22.579365079365115 # may vary</span>
</pre></div>
</div>
<p>High-order polynomials may oscillate wildly:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
<span class="gp">... </span>    <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">RankWarning</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">p30</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">30</span><span class="p">))</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p30</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">-0.80000000000000204 # may vary</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p30</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">-0.99999999999999445 # may vary</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p30</span><span class="p">(</span><span class="mf">4.5</span><span class="p">)</span>
<span class="go">-0.10547061179440398 # may vary</span>
</pre></div>
</div>
<p>Illustration:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">p</span><span class="p">(</span><span class="n">xp</span><span class="p">),</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">p30</span><span class="p">(</span><span class="n">xp</span><span class="p">),</span> <span class="s1">&#39;--&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">(-2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.polyint">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">polyint</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.polyint" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an antiderivative (indefinite integral) of a polynomial.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This forms part of the old polynomial API. Since version 1.4, the
new polynomial API defined in <cite>numpy.polynomial</cite> is preferred.
A summary of the differences can be found in the
<span class="xref std std-doc">transition guide</span>.</p>
</div>
<p>The returned order <cite>m</cite> antiderivative <cite>P</cite> of polynomial <cite>p</cite> satisfies
<span class="math notranslate nohighlight">\(\frac{d^m}{dx^m}P(x) = p(x)\)</span> and is defined up to <cite>m - 1</cite>
integration constants <cite>k</cite>. The constants determine the low-order
polynomial part</p>
<div class="math notranslate nohighlight">
\[\frac{k_{m-1}}{0!} x^0 + \ldots + \frac{k_0}{(m-1)!}x^{m-1}\]</div>
<p>of <cite>P</cite> so that <span class="math notranslate nohighlight">\(P^{(j)}(0) = k_{m-j-1}\)</span>.</p>
<dl>
<dt>p<span class="classifier">array_like or poly1d</span></dt><dd><p>Polynomial to integrate.
A sequence is interpreted as polynomial coefficients, see <cite>poly1d</cite>.</p>
</dd>
<dt>m<span class="classifier">int, optional</span></dt><dd><p>Order of the antiderivative. (Default: 1)</p>
</dd>
<dt>k<span class="classifier">list of <cite>m</cite> scalars or scalar, optional</span></dt><dd><p>Integration constants. They are given in the order of integration:
those corresponding to highest-order terms come first.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">None</span></code> (default), all constants are assumed to be zero.
If <cite>m = 1</cite>, a single scalar can be given instead of a list.</p>
</dd>
</dl>
<p>polyder : derivative of a polynomial
poly1d.integ : equivalent method</p>
<p>The defining property of the antiderivative:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyint</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span>
<span class="go"> poly1d([ 0.33333333,  0.5       ,  1.        ,  0.        ]) # may vary</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">polyder</span><span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="o">==</span> <span class="n">p</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The integration constants default to zero, but can be specified:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyint</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">polyder</span><span class="p">(</span><span class="n">P</span><span class="p">)(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">polyder</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="mi">2</span><span class="p">)(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyint</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span>
<span class="go">poly1d([ 0.01666667,  0.04166667,  0.16666667,  3. ,  5. ,  3. ]) # may vary</span>
</pre></div>
</div>
<p>Note that 3 = 6 / 2!, and that the constants are given in the order of
integrations. Constant of the highest-order polynomial term comes first:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">polyder</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="mi">2</span><span class="p">)(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">6.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">polyder</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="mi">1</span><span class="p">)(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">5.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">3.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.polymul">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">polymul</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.polymul" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the product of two polynomials.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This forms part of the old polynomial API. Since version 1.4, the
new polynomial API defined in <cite>numpy.polynomial</cite> is preferred.
A summary of the differences can be found in the
<span class="xref std std-doc">transition guide</span>.</p>
</div>
<p>Finds the polynomial resulting from the multiplication of the two input
polynomials. Each input must be either a poly1d object or a 1D sequence
of polynomial coefficients, from highest to lowest degree.</p>
<dl class="simple">
<dt>a1, a2<span class="classifier">array_like or poly1d object</span></dt><dd><p>Input polynomials.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray or poly1d object</span></dt><dd><p>The polynomial resulting from the multiplication of the inputs. If
either inputs is a poly1d object, then the output is also a poly1d
object. Otherwise, it is a 1D array of polynomial coefficients from
highest to lowest degree.</p>
</dd>
</dl>
<p>poly1d : A one-dimensional polynomial class.
poly, polyadd, polyder, polydiv, polyfit, polyint, polysub, polyval
convolve : Array convolution. Same output as polymul, but has parameter</p>
<blockquote>
<div><p>for overlap mode.</p>
</div></blockquote>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">polymul</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">array([ 9, 23, 38, 17,  3])</span>
</pre></div>
</div>
<p>Using poly1d objects:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>
<span class="go">   2</span>
<span class="go">1 x + 2 x + 3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>
<span class="go">   2</span>
<span class="go">9 x + 5 x + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polymul</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">))</span>
<span class="go">   4      3      2</span>
<span class="go">9 x + 23 x + 38 x + 17 x + 3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.polysub">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">polysub</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.polysub" title="Permalink to this definition">¶</a></dt>
<dd><p>Difference (subtraction) of two polynomials.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This forms part of the old polynomial API. Since version 1.4, the
new polynomial API defined in <cite>numpy.polynomial</cite> is preferred.
A summary of the differences can be found in the
<span class="xref std std-doc">transition guide</span>.</p>
</div>
<p>Given two polynomials <cite>a1</cite> and <cite>a2</cite>, returns <code class="docutils literal notranslate"><span class="pre">a1</span> <span class="pre">-</span> <span class="pre">a2</span></code>.
<cite>a1</cite> and <cite>a2</cite> can be either array_like sequences of the polynomials’
coefficients (including coefficients equal to zero), or <cite>poly1d</cite> objects.</p>
<dl class="simple">
<dt>a1, a2<span class="classifier">array_like or poly1d</span></dt><dd><p>Minuend and subtrahend polynomials, respectively.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray or poly1d</span></dt><dd><p>Array or <cite>poly1d</cite> object of the difference polynomial’s coefficients.</p>
</dd>
</dl>
<p>polyval, polydiv, polymul, polyadd</p>
<div class="math notranslate nohighlight">
\[(2 x^2 + 10 x - 2) - (3 x^2 + 10 x -4) = (-x^2 + 2)\]</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">polysub</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">])</span>
<span class="go">array([-1,  0,  2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.polyval">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">polyval</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.polyval" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate a polynomial at specific values.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This forms part of the old polynomial API. Since version 1.4, the
new polynomial API defined in <cite>numpy.polynomial</cite> is preferred.
A summary of the differences can be found in the
<span class="xref std std-doc">transition guide</span>.</p>
</div>
<p>If <cite>p</cite> is of length N, this function returns the value:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">p[0]*x**(N-1)</span> <span class="pre">+</span> <span class="pre">p[1]*x**(N-2)</span> <span class="pre">+</span> <span class="pre">...</span> <span class="pre">+</span> <span class="pre">p[N-2]*x</span> <span class="pre">+</span> <span class="pre">p[N-1]</span></code></p>
</div></blockquote>
<p>If <cite>x</cite> is a sequence, then <code class="docutils literal notranslate"><span class="pre">p(x)</span></code> is returned for each element of <code class="docutils literal notranslate"><span class="pre">x</span></code>.
If <cite>x</cite> is another polynomial then the composite polynomial <code class="docutils literal notranslate"><span class="pre">p(x(t))</span></code>
is returned.</p>
<dl class="simple">
<dt>p<span class="classifier">array_like or poly1d object</span></dt><dd><p>1D array of polynomial coefficients (including coefficients equal
to zero) from highest degree to the constant term, or an
instance of poly1d.</p>
</dd>
<dt>x<span class="classifier">array_like or poly1d object</span></dt><dd><p>A number, an array of numbers, or an instance of poly1d, at
which to evaluate <cite>p</cite>.</p>
</dd>
</dl>
<dl class="simple">
<dt>values<span class="classifier">ndarray or poly1d</span></dt><dd><p>If <cite>x</cite> is a poly1d instance, the result is the composition of the two
polynomials, i.e., <cite>x</cite> is “substituted” in <cite>p</cite> and the simplified
result is returned. In addition, the type of <cite>x</cite> - array_like or
poly1d - governs the type of the output: <cite>x</cite> array_like =&gt; <cite>values</cite>
array_like, <cite>x</cite> a poly1d object =&gt; <cite>values</cite> is also.</p>
</dd>
</dl>
<p>poly1d: A polynomial class.</p>
<p>Horner’s scheme <a href="#id91"><span class="problematic" id="id55">[1]_</span></a> is used to evaluate the polynomial. Even so,
for polynomials of high degree the values may be inaccurate due to
rounding errors. Use carefully.</p>
<p>If <cite>x</cite> is a subtype of <cite>ndarray</cite> the return value will be of the same type.</p>
<dl class="footnote brackets">
<dt class="label" id="id56"><span class="brackets">1</span></dt>
<dd><p>I. N. Bronshtein, K. A. Semendyayev, and K. A. Hirsch (Eng.
trans. Ed.), <em>Handbook of Mathematics</em>, New York, Van Nostrand
Reinhold Co., 1985, pg. 720.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">5</span><span class="p">)</span>  <span class="c1"># 3 * 5**2 + 0 * 5**1 + 1</span>
<span class="go">76</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">poly1d([76])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]),</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">76</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">poly1d([76])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.printoptions">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">printoptions</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.printoptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Context manager for setting print options.</p>
<p>Set print options for the scope of the <cite>with</cite> block, and restore the old
options at the end. See <cite>set_printoptions</cite> for the full description of
available options.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy.testing</span> <span class="kn">import</span> <span class="n">assert_equal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">2.0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">3</span>
<span class="go">array([0.67])</span>
</pre></div>
</div>
<p>The <cite>as</cite>-clause of the <cite>with</cite>-statement gives the current print options:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="k">as</span> <span class="n">opts</span><span class="p">:</span>
<span class="gp">... </span>     <span class="n">assert_equal</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">get_printoptions</span><span class="p">())</span>
</pre></div>
</div>
<p>set_printoptions, get_printoptions</p>
</dd></dl>

<dl class="py function">
<dt id="numpy.prod">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">prod</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">a</span></em>, <em class="sig-param"><span class="pre">axis=None</span></em>, <em class="sig-param"><span class="pre">dtype=None</span></em>, <em class="sig-param"><span class="pre">out=None</span></em>, <em class="sig-param"><span class="pre">keepdims=&lt;no</span> <span class="pre">value&gt;</span></em>, <em class="sig-param"><span class="pre">initial=&lt;no</span> <span class="pre">value&gt;</span></em>, <em class="sig-param"><span class="pre">where=&lt;no</span> <span class="pre">value&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.prod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the product of array elements over a given axis.</p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input data.</p>
</dd>
<dt>axis<span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Axis or axes along which a product is performed.  The default,
axis=None, will calculate the product of all the elements in the
input array. If axis is negative it counts from the last to the
first axis.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<p>If axis is a tuple of ints, a product is performed on all of the
axes specified in the tuple instead of a single axis or all the
axes as before.</p>
</dd>
<dt>dtype<span class="classifier">dtype, optional</span></dt><dd><p>The type of the returned array, as well as of the accumulator in
which the elements are multiplied.  The dtype of <cite>a</cite> is used by
default unless <cite>a</cite> has an integer dtype of less precision than the
default platform integer.  In that case, if <cite>a</cite> is signed then the
platform integer is used while if <cite>a</cite> is unsigned then an unsigned
integer of the same precision as the platform integer is used.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Alternative output array in which to place the result. It must have
the same shape as the expected output, but the type of the output
values will be cast if necessary.</p>
</dd>
<dt>keepdims<span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left in the
result as dimensions with size one. With this option, the result
will broadcast correctly against the input array.</p>
<p>If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>prod</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
<dt>initial<span class="classifier">scalar, optional</span></dt><dd><p>The starting value for this product. See <cite>~numpy.ufunc.reduce</cite> for details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.15.0.</span></p>
</div>
</dd>
<dt>where<span class="classifier">array_like of bool, optional</span></dt><dd><p>Elements to include in the product. See <cite>~numpy.ufunc.reduce</cite> for details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.17.0.</span></p>
</div>
</dd>
</dl>
<dl>
<dt>product_along_axis<span class="classifier">ndarray, see <cite>dtype</cite> parameter above.</span></dt><dd><p>An array shaped as <cite>a</cite> but with the specified axis removed.
Returns a reference to <cite>out</cite> if specified.</p>
</dd>
</dl>
<p>ndarray.prod : equivalent method
<span class="xref std std-ref">ufuncs-output-type</span></p>
<p>Arithmetic is modular when using integer types, and no error is
raised on overflow.  That means that, on a 32-bit platform:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">536870910</span><span class="p">,</span> <span class="mi">536870910</span><span class="p">,</span> <span class="mi">536870910</span><span class="p">,</span> <span class="mi">536870910</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">16 # may vary</span>
</pre></div>
</div>
<p>The product of an empty array is the neutral element 1:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([])</span>
<span class="go">1.0</span>
</pre></div>
</div>
<p>By default, calculate the product of all elements:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">])</span>
<span class="go">2.0</span>
</pre></div>
</div>
<p>Even when the input array is two-dimensional:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">4.</span><span class="p">]])</span>
<span class="go">24.0</span>
</pre></div>
</div>
<p>But we can also specify the axis over which to multiply:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">4.</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([  2.,  12.])</span>
</pre></div>
</div>
<p>Or select specific elements to include:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mf">3.</span><span class="p">],</span> <span class="n">where</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span>
<span class="go">3.0</span>
</pre></div>
</div>
<p>If the type of <cite>x</cite> is unsigned, then the output type is
the unsigned platform integer:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">uint</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If <cite>x</cite> is of a signed integer type, then the output type
is the default platform integer:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">int</span>
<span class="go">True</span>
</pre></div>
</div>
<p>You can also start the product with a value other than one:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">initial</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">10</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.product">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">product</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the product of array elements over a given axis.</p>
<p>prod : equivalent function; see for details.</p>
</dd></dl>

<dl class="py function">
<dt id="numpy.promote_types">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">promote_types</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.promote_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the data type with the smallest size and smallest scalar
kind to which both <code class="docutils literal notranslate"><span class="pre">type1</span></code> and <code class="docutils literal notranslate"><span class="pre">type2</span></code> may be safely cast.
The returned data type is always in native byte order.</p>
<p>This function is symmetric, but rarely associative.</p>
<dl class="simple">
<dt>type1<span class="classifier">dtype or dtype specifier</span></dt><dd><p>First data type.</p>
</dd>
<dt>type2<span class="classifier">dtype or dtype specifier</span></dt><dd><p>Second data type.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">dtype</span></dt><dd><p>The promoted data type.</p>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.6.0.</span></p>
</div>
<p>Starting in NumPy 1.9, promote_types function now returns a valid string
length when given an integer or float dtype as one argument and a string
dtype as another argument. Previously it always returned the input string
dtype, even if it wasn’t long enough to store the max integer/float value
converted to a string.</p>
<p>result_type, dtype, can_cast</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">promote_types</span><span class="p">(</span><span class="s1">&#39;f4&#39;</span><span class="p">,</span> <span class="s1">&#39;f8&#39;</span><span class="p">)</span>
<span class="go">dtype(&#39;float64&#39;)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">promote_types</span><span class="p">(</span><span class="s1">&#39;i8&#39;</span><span class="p">,</span> <span class="s1">&#39;f4&#39;</span><span class="p">)</span>
<span class="go">dtype(&#39;float64&#39;)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">promote_types</span><span class="p">(</span><span class="s1">&#39;&gt;i8&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;c8&#39;</span><span class="p">)</span>
<span class="go">dtype(&#39;complex128&#39;)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">promote_types</span><span class="p">(</span><span class="s1">&#39;i4&#39;</span><span class="p">,</span> <span class="s1">&#39;S8&#39;</span><span class="p">)</span>
<span class="go">dtype(&#39;S11&#39;)</span>
</pre></div>
</div>
<p>An example of a non-associative case:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">promote_types</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="n">p</span><span class="p">(</span><span class="s1">&#39;i1&#39;</span><span class="p">,</span> <span class="s1">&#39;u1&#39;</span><span class="p">))</span>
<span class="go">dtype(&#39;S6&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="s1">&#39;i1&#39;</span><span class="p">),</span> <span class="s1">&#39;u1&#39;</span><span class="p">)</span>
<span class="go">dtype(&#39;S4&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.ptp">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">ptp</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">a</span></em>, <em class="sig-param"><span class="pre">axis=None</span></em>, <em class="sig-param"><span class="pre">out=None</span></em>, <em class="sig-param"><span class="pre">keepdims=&lt;no</span> <span class="pre">value&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ptp" title="Permalink to this definition">¶</a></dt>
<dd><p>Range of values (maximum - minimum) along an axis.</p>
<p>The name of the function comes from the acronym for ‘peak to peak’.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><cite>ptp</cite> preserves the data type of the array. This means the
return value for an input of signed integers with n bits
(e.g. <cite>np.int8</cite>, <cite>np.int16</cite>, etc) is also a signed integer
with n bits.  In that case, peak-to-peak values greater than
<code class="docutils literal notranslate"><span class="pre">2**(n-1)-1</span></code> will be returned as negative values. An example
with a work-around is shown below.</p>
</div>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input values.</p>
</dd>
<dt>axis<span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Axis along which to find the peaks.  By default, flatten the
array.  <cite>axis</cite> may be negative, in
which case it counts from the last to the first axis.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.15.0.</span></p>
</div>
<p>If this is a tuple of ints, a reduction is performed on multiple
axes, instead of a single axis or all the axes as before.</p>
</dd>
<dt>out<span class="classifier">array_like</span></dt><dd><p>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output,
but the type of the output values will be cast if necessary.</p>
</dd>
<dt>keepdims<span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p>If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>ptp</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
</dl>
<dl class="simple">
<dt>ptp<span class="classifier">ndarray</span></dt><dd><p>A new array holding the result, unless <cite>out</cite> was
specified, in which case a reference to <cite>out</cite> is returned.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">12</span><span class="p">]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([8, 6])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([2, 0, 5, 2])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">10</span>
</pre></div>
</div>
<p>This example shows that a negative value can be returned when
the input is an array of signed integers.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">127</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">127</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">127</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">127</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 126,  127, -128, -127], dtype=int8)</span>
</pre></div>
</div>
<p>A work-around is to use the <cite>view()</cite> method to view the result as
unsigned integers with the same bit width:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="go">array([126, 127, 128, 129], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.put">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">put</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ind</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'raise'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.put" title="Permalink to this definition">¶</a></dt>
<dd><p>Replaces specified elements of an array with given values.</p>
<p>The indexing works on the flattened target array. <cite>put</cite> is roughly
equivalent to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
</pre></div>
</div>
<dl>
<dt>a<span class="classifier">ndarray</span></dt><dd><p>Target array.</p>
</dd>
<dt>ind<span class="classifier">array_like</span></dt><dd><p>Target indices, interpreted as integers.</p>
</dd>
<dt>v<span class="classifier">array_like</span></dt><dd><p>Values to place in <cite>a</cite> at target indices. If <cite>v</cite> is shorter than
<cite>ind</cite> it will be repeated as necessary.</p>
</dd>
<dt>mode<span class="classifier">{‘raise’, ‘wrap’, ‘clip’}, optional</span></dt><dd><p>Specifies how out-of-bounds indices will behave.</p>
<ul class="simple">
<li><p>‘raise’ – raise an error (default)</p></li>
<li><p>‘wrap’ – wrap around</p></li>
<li><p>‘clip’ – clip to the range</p></li>
</ul>
<p>‘clip’ mode means that all indices that are too large are replaced
by the index that addresses the last element along that axis. Note
that this disables indexing with negative numbers. In ‘raise’ mode,
if an exception occurs the target array may still be modified.</p>
</dd>
</dl>
<p>putmask, place
put_along_axis : Put elements by matching the array and the index arrays</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">44</span><span class="p">,</span> <span class="o">-</span><span class="mi">55</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([-44,   1, -55,   3,   4])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;clip&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([ 0,  1,  2,  3, -5])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.put_along_axis">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">put_along_axis</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.put_along_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Put values into the destination array by matching 1d index and data slices.</p>
<p>This iterates over matching 1d slices oriented along the specified axis in
the index and data arrays, and uses the former to place values into the
latter. These slices can be different lengths.</p>
<p>Functions returning an index along an axis, like <cite>argsort</cite> and
<cite>argpartition</cite>, produce suitable indices for this function.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.15.0.</span></p>
</div>
<dl class="simple">
<dt>arr<span class="classifier">ndarray (Ni…, M, Nk…)</span></dt><dd><p>Destination array.</p>
</dd>
<dt>indices<span class="classifier">ndarray (Ni…, J, Nk…)</span></dt><dd><p>Indices to change along each 1d slice of <cite>arr</cite>. This must match the
dimension of arr, but dimensions in Ni and Nj may be 1 to broadcast
against <cite>arr</cite>.</p>
</dd>
<dt>values<span class="classifier">array_like (Ni…, J, Nk…)</span></dt><dd><p>values to insert at those indices. Its shape and dimension are
broadcast to match that of <cite>indices</cite>.</p>
</dd>
<dt>axis<span class="classifier">int</span></dt><dd><p>The axis to take 1d slices along. If axis is None, the destination
array is treated as if a flattened 1d view had been created of it.</p>
</dd>
</dl>
<p>This is equivalent to (but faster than) the following use of <cite>ndindex</cite> and
<cite>s_</cite>, which sets each of <code class="docutils literal notranslate"><span class="pre">ii</span></code> and <code class="docutils literal notranslate"><span class="pre">kk</span></code> to a tuple of indices:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ni</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">Nk</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">],</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
<span class="n">J</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>  <span class="c1"># Need not equal M</span>

<span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Ni</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Nk</span><span class="p">):</span>
        <span class="n">a_1d</span>       <span class="o">=</span> <span class="n">a</span>      <span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">s_</span><span class="p">[:,]</span> <span class="o">+</span> <span class="n">kk</span><span class="p">]</span>
        <span class="n">indices_1d</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">s_</span><span class="p">[:,]</span> <span class="o">+</span> <span class="n">kk</span><span class="p">]</span>
        <span class="n">values_1d</span>  <span class="o">=</span> <span class="n">values</span> <span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">s_</span><span class="p">[:,]</span> <span class="o">+</span> <span class="n">kk</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">J</span><span class="p">):</span>
            <span class="n">a_1d</span><span class="p">[</span><span class="n">indices_1d</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">values_1d</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
</pre></div>
</div>
<p>Equivalently, eliminating the inner loop, the last two lines would be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a_1d</span><span class="p">[</span><span class="n">indices_1d</span><span class="p">]</span> <span class="o">=</span> <span class="n">values_1d</span>
</pre></div>
</div>
<dl class="simple">
<dt>take_along_axis :</dt><dd><p>Take values from the input array by matching 1d index and data slices</p>
</dd>
</dl>
<p>For this sample array</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span> <span class="p">[</span><span class="mi">60</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">]])</span>
</pre></div>
</div>
<p>We can replace the maximum values with:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ai</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ai</span>
<span class="go">array([[1],</span>
<span class="go">       [0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">put_along_axis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ai</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[10, 99, 20],</span>
<span class="go">       [99, 40, 50]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.putmask">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">putmask</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.putmask" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes elements of an array based on conditional and input values.</p>
<p>Sets <code class="docutils literal notranslate"><span class="pre">a.flat[n]</span> <span class="pre">=</span> <span class="pre">values[n]</span></code> for each n where <code class="docutils literal notranslate"><span class="pre">mask.flat[n]==True</span></code>.</p>
<p>If <cite>values</cite> is not the same size as <cite>a</cite> and <cite>mask</cite> then it will repeat.
This gives behavior different from <code class="docutils literal notranslate"><span class="pre">a[mask]</span> <span class="pre">=</span> <span class="pre">values</span></code>.</p>
<dl class="simple">
<dt>a<span class="classifier">ndarray</span></dt><dd><p>Target array.</p>
</dd>
<dt>mask<span class="classifier">array_like</span></dt><dd><p>Boolean mask array. It has to be the same shape as <cite>a</cite>.</p>
</dd>
<dt>values<span class="classifier">array_like</span></dt><dd><p>Values to put into <cite>a</cite> where <cite>mask</cite> is True. If <cite>values</cite> is smaller
than <cite>a</cite> it will be repeated.</p>
</dd>
</dl>
<p>place, put, take, copyto</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[ 0,  1,  2],</span>
<span class="go">       [ 9, 16, 25]])</span>
</pre></div>
</div>
<p>If <cite>values</cite> is smaller than <cite>a</cite> it is repeated:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">33</span><span class="p">,</span> <span class="o">-</span><span class="mi">44</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([  0,   1, -33, -44, -33])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.quantile">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">quantile</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite_input</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interpolation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keepdims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.quantile" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the q-th quantile of the data along the specified axis.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.15.0.</span></p>
</div>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input array or object that can be converted to an array.</p>
</dd>
<dt>q<span class="classifier">array_like of float</span></dt><dd><p>Quantile or sequence of quantiles to compute, which must be between
0 and 1 inclusive.</p>
</dd>
<dt>axis<span class="classifier">{int, tuple of int, None}, optional</span></dt><dd><p>Axis or axes along which the quantiles are computed. The
default is to compute the quantile(s) along a flattened
version of the array.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output,
but the type (of the output) will be cast if necessary.</p>
</dd>
<dt>overwrite_input<span class="classifier">bool, optional</span></dt><dd><p>If True, then allow the input array <cite>a</cite> to be modified by intermediate
calculations, to save memory. In this case, the contents of the input
<cite>a</cite> after this function completes is undefined.</p>
</dd>
<dt>interpolation<span class="classifier">{‘linear’, ‘lower’, ‘higher’, ‘midpoint’, ‘nearest’}</span></dt><dd><p>This optional parameter specifies the interpolation method to
use when the desired quantile lies between two data points
<code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">j</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><p>linear: <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">(j</span> <span class="pre">-</span> <span class="pre">i)</span> <span class="pre">*</span> <span class="pre">fraction</span></code>, where <code class="docutils literal notranslate"><span class="pre">fraction</span></code>
is the fractional part of the index surrounded by <code class="docutils literal notranslate"><span class="pre">i</span></code>
and <code class="docutils literal notranslate"><span class="pre">j</span></code>.</p></li>
<li><p>lower: <code class="docutils literal notranslate"><span class="pre">i</span></code>.</p></li>
<li><p>higher: <code class="docutils literal notranslate"><span class="pre">j</span></code>.</p></li>
<li><p>nearest: <code class="docutils literal notranslate"><span class="pre">i</span></code> or <code class="docutils literal notranslate"><span class="pre">j</span></code>, whichever is nearest.</p></li>
<li><p>midpoint: <code class="docutils literal notranslate"><span class="pre">(i</span> <span class="pre">+</span> <span class="pre">j)</span> <span class="pre">/</span> <span class="pre">2</span></code>.</p></li>
</ul>
</div></blockquote>
</dd>
<dt>keepdims<span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left in
the result as dimensions with size one. With this option, the
result will broadcast correctly against the original array <cite>a</cite>.</p>
</dd>
</dl>
<dl class="simple">
<dt>quantile<span class="classifier">scalar or ndarray</span></dt><dd><p>If <cite>q</cite> is a single quantile and <cite>axis=None</cite>, then the result
is a scalar. If multiple quantiles are given, first axis of
the result corresponds to the quantiles. The other axes are
the axes that remain after the reduction of <cite>a</cite>. If the input
contains integers or floats smaller than <code class="docutils literal notranslate"><span class="pre">float64</span></code>, the output
data-type is <code class="docutils literal notranslate"><span class="pre">float64</span></code>. Otherwise, the output data-type is the
same as that of the input. If <cite>out</cite> is specified, that array is
returned instead.</p>
</dd>
</dl>
<p>mean
percentile : equivalent to quantile, but with q in the range [0, 100].
median : equivalent to <code class="docutils literal notranslate"><span class="pre">quantile(...,</span> <span class="pre">0.5)</span></code>
nanquantile</p>
<p>Given a vector <code class="docutils literal notranslate"><span class="pre">V</span></code> of length <code class="docutils literal notranslate"><span class="pre">N</span></code>, the q-th quantile of
<code class="docutils literal notranslate"><span class="pre">V</span></code> is the value <code class="docutils literal notranslate"><span class="pre">q</span></code> of the way from the minimum to the
maximum in a sorted copy of <code class="docutils literal notranslate"><span class="pre">V</span></code>. The values and distances of
the two nearest neighbors as well as the <cite>interpolation</cite> parameter
will determine the quantile if the normalized ranking does not
match the location of <code class="docutils literal notranslate"><span class="pre">q</span></code> exactly. This function is the same as
the median if <code class="docutils literal notranslate"><span class="pre">q=0.5</span></code>, the same as the minimum if <code class="docutils literal notranslate"><span class="pre">q=0.0</span></code> and the
same as the maximum if <code class="docutils literal notranslate"><span class="pre">q=1.0</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[10,  7,  4],</span>
<span class="go">       [ 3,  2,  1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="go">3.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([6.5, 4.5, 2.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([7.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([[7.],</span>
<span class="go">       [2.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
<span class="go">array([6.5, 4.5, 2.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">array([6.5, 4.5, 2.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([7.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.ravel">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">ravel</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'C'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ravel" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a contiguous flattened array.</p>
<p>A 1-D array, containing the elements of the input, is returned.  A copy is
made only if needed.</p>
<p>As of NumPy 1.10, the returned array will have the same type as the input
array. (for example, a masked array will be returned for a masked array
input)</p>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input array.  The elements in <cite>a</cite> are read in the order specified by
<cite>order</cite>, and packed as a 1-D array.</p>
</dd>
</dl>
<p>order : {‘C’,’F’, ‘A’, ‘K’}, optional</p>
<blockquote>
<div><p>The elements of <cite>a</cite> are read using this index order. ‘C’ means
to index the elements in row-major, C-style order,
with the last axis index changing fastest, back to the first
axis index changing slowest.  ‘F’ means to index the elements
in column-major, Fortran-style order, with the
first index changing fastest, and the last index changing
slowest. Note that the ‘C’ and ‘F’ options take no account of
the memory layout of the underlying array, and only refer to
the order of axis indexing.  ‘A’ means to read the elements in
Fortran-like index order if <cite>a</cite> is Fortran <em>contiguous</em> in
memory, C-like order otherwise.  ‘K’ means to read the
elements in the order they occur in memory, except for
reversing the data when strides are negative.  By default, ‘C’
index order is used.</p>
</div></blockquote>
<dl class="simple">
<dt>y<span class="classifier">array_like</span></dt><dd><p>y is an array of the same subtype as <cite>a</cite>, with shape <code class="docutils literal notranslate"><span class="pre">(a.size,)</span></code>.
Note that matrices are special cased for backward compatibility, if <cite>a</cite>
is a matrix, then y is a 1-D ndarray.</p>
</dd>
</dl>
<p>ndarray.flat : 1-D iterator over an array.
ndarray.flatten : 1-D array copy of the elements of an array</p>
<blockquote>
<div><p>in row-major order.</p>
</div></blockquote>
<p>ndarray.reshape : Change the shape of an array without changing its data.</p>
<p>In row-major, C-style order, in two dimensions, the row index
varies the slowest, and the column index the quickest.  This can
be generalized to multiple dimensions, where row-major order
implies that the index along the first axis varies slowest, and
the index along the last quickest.  The opposite holds for
column-major, Fortran-style index ordering.</p>
<p>When a view is desired in as many cases as possible, <code class="docutils literal notranslate"><span class="pre">arr.reshape(-1)</span></code>
may be preferable.</p>
<p>It is equivalent to <code class="docutils literal notranslate"><span class="pre">reshape(-1,</span> <span class="pre">order=order)</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([1, 2, 3, 4, 5, 6])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([1, 2, 3, 4, 5, 6])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
<span class="go">array([1, 4, 2, 5, 3, 6])</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">order</span></code> is ‘A’, it will preserve the array’s ‘C’ or ‘F’ ordering:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="go">array([1, 4, 2, 5, 3, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="go">array([1, 2, 3, 4, 5, 6])</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">order</span></code> is ‘K’, it will preserve orderings that are neither ‘C’
nor ‘F’, but won’t reverse axes:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span> <span class="n">a</span>
<span class="go">array([2, 1, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="go">array([2, 1, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;K&#39;</span><span class="p">)</span>
<span class="go">array([2, 1, 0])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span> <span class="n">a</span>
<span class="go">array([[[ 0,  2,  4],</span>
<span class="go">        [ 1,  3,  5]],</span>
<span class="go">       [[ 6,  8, 10],</span>
<span class="go">        [ 7,  9, 11]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="go">array([ 0,  2,  4,  1,  3,  5,  6,  8, 10,  7,  9, 11])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;K&#39;</span><span class="p">)</span>
<span class="go">array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.ravel_multi_index">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">ravel_multi_index</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">multi_index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'raise'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'C'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ravel_multi_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a tuple of index arrays into an array of flat
indices, applying boundary modes to the multi-index.</p>
<dl>
<dt>multi_index<span class="classifier">tuple of array_like</span></dt><dd><p>A tuple of integer arrays, one array for each dimension.</p>
</dd>
<dt>dims<span class="classifier">tuple of ints</span></dt><dd><p>The shape of array into which the indices from <code class="docutils literal notranslate"><span class="pre">multi_index</span></code> apply.</p>
</dd>
<dt>mode<span class="classifier">{‘raise’, ‘wrap’, ‘clip’}, optional</span></dt><dd><p>Specifies how out-of-bounds indices are handled.  Can specify
either one mode or a tuple of modes, one mode per index.</p>
<ul class="simple">
<li><p>‘raise’ – raise an error (default)</p></li>
<li><p>‘wrap’ – wrap around</p></li>
<li><p>‘clip’ – clip to the range</p></li>
</ul>
<p>In ‘clip’ mode, a negative index which would normally
wrap will clip to 0 instead.</p>
</dd>
<dt>order<span class="classifier">{‘C’, ‘F’}, optional</span></dt><dd><p>Determines whether the multi-index should be viewed as
indexing in row-major (C-style) or column-major
(Fortran-style) order.</p>
</dd>
</dl>
<dl class="simple">
<dt>raveled_indices<span class="classifier">ndarray</span></dt><dd><p>An array of indices into the flattened version of an array
of dimensions <code class="docutils literal notranslate"><span class="pre">dims</span></code>.</p>
</dd>
</dl>
<p>unravel_index</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.6.0.</span></p>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="go">array([22, 41, 37])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
<span class="go">array([31, 41, 13])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;clip&#39;</span><span class="p">)</span>
<span class="go">array([22, 23, 19])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;clip&#39;</span><span class="p">,</span><span class="s1">&#39;wrap&#39;</span><span class="p">))</span>
<span class="go">array([12, 13, 13])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">))</span>
<span class="go">1621</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.real">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">real</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">val</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.real" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the real part of the complex argument.</p>
<dl class="simple">
<dt>val<span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray or scalar</span></dt><dd><p>The real component of the complex argument. If <cite>val</cite> is real, the type
of <cite>val</cite> is used for the output.  If <cite>val</cite> has complex elements, the
returned type is float.</p>
</dd>
</dl>
<p>real_if_close, imag, angle</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="o">+</span><span class="mi">4</span><span class="n">j</span><span class="p">,</span> <span class="mi">5</span><span class="o">+</span><span class="mi">6</span><span class="n">j</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">real</span>
<span class="go">array([1.,  3.,  5.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="mi">9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([9.+2.j,  9.+4.j,  9.+6.j])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([9.+2.j,  8.+4.j,  7.+6.j])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.real_if_close">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">real_if_close</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.real_if_close" title="Permalink to this definition">¶</a></dt>
<dd><p>If input is complex with all imaginary parts close to zero, return 
real parts.</p>
<p>“Close to zero” is defined as <cite>tol</cite> * (machine epsilon of the type for
<cite>a</cite>).</p>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt>tol<span class="classifier">float</span></dt><dd><p>Tolerance in machine epsilons for the complex part of the elements
in the array.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>If <cite>a</cite> is real, the type of <cite>a</cite> is used for the output.  If <cite>a</cite>
has complex elements, the returned type is float.</p>
</dd>
</dl>
<p>real, imag, angle</p>
<p>Machine epsilon varies from machine to machine and between data types
but Python floats on most platforms have a machine epsilon equal to
2.2204460492503131e-16.  You can use ‘np.finfo(float).eps’ to print
out the machine epsilon for floats.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
<span class="go">2.2204460492503131e-16 # may vary</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">real_if_close</span><span class="p">([</span><span class="mf">2.1</span> <span class="o">+</span> <span class="mf">4e-14j</span><span class="p">,</span> <span class="mf">5.2</span> <span class="o">+</span> <span class="mf">3e-15j</span><span class="p">],</span> <span class="n">tol</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="go">array([2.1, 5.2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">real_if_close</span><span class="p">([</span><span class="mf">2.1</span> <span class="o">+</span> <span class="mf">4e-13j</span><span class="p">,</span> <span class="mf">5.2</span> <span class="o">+</span> <span class="mf">3e-15j</span><span class="p">],</span> <span class="n">tol</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="go">array([2.1+4.e-13j, 5.2 + 3e-15j])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt id="numpy.recarray">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">recarray</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strides</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">formats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">names</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">titles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">byteorder</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aligned</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'C'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.recarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct an ndarray that allows field access using attributes.</p>
<p>Arrays may have a data-types containing fields, analogous
to columns in a spread sheet.  An example is <code class="docutils literal notranslate"><span class="pre">[(x,</span> <span class="pre">int),</span> <span class="pre">(y,</span> <span class="pre">float)]</span></code>,
where each entry in the array is a pair of <code class="docutils literal notranslate"><span class="pre">(int,</span> <span class="pre">float)</span></code>.  Normally,
these attributes are accessed using dictionary lookups such as <code class="docutils literal notranslate"><span class="pre">arr['x']</span></code>
and <code class="docutils literal notranslate"><span class="pre">arr['y']</span></code>.  Record arrays allow the fields to be accessed as members
of the array, using <code class="docutils literal notranslate"><span class="pre">arr.x</span></code> and <code class="docutils literal notranslate"><span class="pre">arr.y</span></code>.</p>
<dl class="simple">
<dt>shape<span class="classifier">tuple</span></dt><dd><p>Shape of output array.</p>
</dd>
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>The desired data-type.  By default, the data-type is determined
from <cite>formats</cite>, <cite>names</cite>, <cite>titles</cite>, <cite>aligned</cite> and <cite>byteorder</cite>.</p>
</dd>
<dt>formats<span class="classifier">list of data-types, optional</span></dt><dd><p>A list containing the data-types for the different columns, e.g.
<code class="docutils literal notranslate"><span class="pre">['i4',</span> <span class="pre">'f8',</span> <span class="pre">'i4']</span></code>.  <cite>formats</cite> does <em>not</em> support the new
convention of using types directly, i.e. <code class="docutils literal notranslate"><span class="pre">(int,</span> <span class="pre">float,</span> <span class="pre">int)</span></code>.
Note that <cite>formats</cite> must be a list, not a tuple.
Given that <cite>formats</cite> is somewhat limited, we recommend specifying
<cite>dtype</cite> instead.</p>
</dd>
<dt>names<span class="classifier">tuple of str, optional</span></dt><dd><p>The name of each column, e.g. <code class="docutils literal notranslate"><span class="pre">('x',</span> <span class="pre">'y',</span> <span class="pre">'z')</span></code>.</p>
</dd>
<dt>buf<span class="classifier">buffer, optional</span></dt><dd><p>By default, a new array is created of the given shape and data-type.
If <cite>buf</cite> is specified and is an object exposing the buffer interface,
the array will use the memory from the existing buffer.  In this case,
the <cite>offset</cite> and <cite>strides</cite> keywords are available.</p>
</dd>
</dl>
<dl class="simple">
<dt>titles<span class="classifier">tuple of str, optional</span></dt><dd><p>Aliases for column names.  For example, if <cite>names</cite> were
<code class="docutils literal notranslate"><span class="pre">('x',</span> <span class="pre">'y',</span> <span class="pre">'z')</span></code> and <cite>titles</cite> is
<code class="docutils literal notranslate"><span class="pre">('x_coordinate',</span> <span class="pre">'y_coordinate',</span> <span class="pre">'z_coordinate')</span></code>, then
<code class="docutils literal notranslate"><span class="pre">arr['x']</span></code> is equivalent to both <code class="docutils literal notranslate"><span class="pre">arr.x</span></code> and <code class="docutils literal notranslate"><span class="pre">arr.x_coordinate</span></code>.</p>
</dd>
<dt>byteorder<span class="classifier">{‘&lt;’, ‘&gt;’, ‘=’}, optional</span></dt><dd><p>Byte-order for all fields.</p>
</dd>
<dt>aligned<span class="classifier">bool, optional</span></dt><dd><p>Align the fields in memory as the C-compiler would.</p>
</dd>
<dt>strides<span class="classifier">tuple of ints, optional</span></dt><dd><p>Buffer (<cite>buf</cite>) is interpreted according to these strides (strides
define how many bytes each array element, row, column, etc.
occupy in memory).</p>
</dd>
<dt>offset<span class="classifier">int, optional</span></dt><dd><p>Start reading buffer (<cite>buf</cite>) from this offset onwards.</p>
</dd>
<dt>order<span class="classifier">{‘C’, ‘F’}, optional</span></dt><dd><p>Row-major (C-style) or column-major (Fortran-style) order.</p>
</dd>
</dl>
<dl class="simple">
<dt>rec<span class="classifier">recarray</span></dt><dd><p>Empty array of the given shape and type.</p>
</dd>
</dl>
<p>core.records.fromrecords : Construct a record array from data.
record : fundamental data-type for <cite>recarray</cite>.
format_parser : determine a data-type from formats, names, titles.</p>
<p>This constructor can be compared to <code class="docutils literal notranslate"><span class="pre">empty</span></code>: it creates a new record
array but does not fill it with data.  To create a record array from data,
use one of the following methods:</p>
<ol class="arabic simple">
<li><p>Create a standard ndarray and convert it to a record array,
using <code class="docutils literal notranslate"><span class="pre">arr.view(np.recarray)</span></code></p></li>
<li><p>Use the <cite>buf</cite> keyword.</p></li>
<li><p>Use <cite>np.rec.fromrecords</cite>.</p></li>
</ol>
<p>Create an array with two fields, <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;f8&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i8&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([(1., 2), (3., 4)], dtype=[(&#39;x&#39;, &#39;&lt;f8&#39;), (&#39;y&#39;, &#39;&lt;i8&#39;)])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
<span class="go">array([1., 3.])</span>
</pre></div>
</div>
<p>View the array as a record array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">x</span>
<span class="go">array([1., 3.])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">y</span>
<span class="go">array([2, 4])</span>
</pre></div>
</div>
<p>Create a new, empty record array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">((</span><span class="mi">2</span><span class="p">,),</span>
<span class="gp">... </span><span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)])</span> 
<span class="go">rec.array([(-1073741821, 1.2249118382103472e-301, 24547520),</span>
<span class="go">       (3471280, 1.2134086255804012e-316, 0)],</span>
<span class="go">      dtype=[(&#39;x&#39;, &#39;&lt;i4&#39;), (&#39;y&#39;, &#39;&lt;f8&#39;), (&#39;z&#39;, &#39;&lt;i4&#39;)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.recfromcsv">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">recfromcsv</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.recfromcsv" title="Permalink to this definition">¶</a></dt>
<dd><p>Load ASCII data stored in a comma-separated file.</p>
<p>The returned array is a record array (if <code class="docutils literal notranslate"><span class="pre">usemask=False</span></code>, see
<cite>recarray</cite>) or a masked record array (if <code class="docutils literal notranslate"><span class="pre">usemask=True</span></code>,
see <cite>ma.mrecords.MaskedRecords</cite>).</p>
<p>fname, kwargs : For a description of input parameters, see <cite>genfromtxt</cite>.</p>
<p>numpy.genfromtxt : generic function to load ASCII data.</p>
<p>By default, <cite>dtype</cite> is None, which means that the data-type of the output
array will be determined from the data.</p>
</dd></dl>

<dl class="py function">
<dt id="numpy.recfromtxt">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">recfromtxt</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.recfromtxt" title="Permalink to this definition">¶</a></dt>
<dd><p>Load ASCII data from a file and return it in a record array.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">usemask=False</span></code> a standard <cite>recarray</cite> is returned,
if <code class="docutils literal notranslate"><span class="pre">usemask=True</span></code> a MaskedRecords array is returned.</p>
<p>fname, kwargs : For a description of input parameters, see <cite>genfromtxt</cite>.</p>
<p>numpy.genfromtxt : generic function</p>
<p>By default, <cite>dtype</cite> is None, which means that the data-type of the output
array will be determined from the data.</p>
</dd></dl>

<dl class="py class">
<dt id="numpy.record">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">record</span></code><a class="headerlink" href="#numpy.record" title="Permalink to this definition">¶</a></dt>
<dd><p>A data-type scalar that allows field access as attribute lookup.</p>
<dl class="py method">
<dt id="numpy.record.pprint">
<code class="sig-name descname"><span class="pre">pprint</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.record.pprint" title="Permalink to this definition">¶</a></dt>
<dd><p>Pretty-print all fields.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="numpy.repeat">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">repeat</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repeats</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.repeat" title="Permalink to this definition">¶</a></dt>
<dd><p>Repeat elements of an array.</p>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt>repeats<span class="classifier">int or array of ints</span></dt><dd><p>The number of repetitions for each element.  <cite>repeats</cite> is broadcasted
to fit the shape of the given axis.</p>
</dd>
<dt>axis<span class="classifier">int, optional</span></dt><dd><p>The axis along which to repeat values.  By default, use the
flattened input array, and return a flat output array.</p>
</dd>
</dl>
<dl class="simple">
<dt>repeated_array<span class="classifier">ndarray</span></dt><dd><p>Output array which has the same shape as <cite>a</cite>, except along
the given axis.</p>
</dd>
</dl>
<p>tile : Tile an array.
unique : Find the unique elements of an array.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">array([3, 3, 3, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([1, 1, 2, 2, 3, 3, 4, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[1, 1, 1, 2, 2, 2],</span>
<span class="go">       [3, 3, 3, 4, 4, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.require">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">require</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">requirements</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">like</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.require" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an ndarray of the provided type that satisfies requirements.</p>
<p>This function is useful to be sure that an array with the correct flags
is returned for passing to compiled code (perhaps through ctypes).</p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>The object to be converted to a type-and-requirement-satisfying array.</p>
</dd>
<dt>dtype<span class="classifier">data-type</span></dt><dd><p>The required data-type. If None preserve the current dtype. If your
application requires the data to be in native byteorder, include
a byteorder specification as a part of the dtype specification.</p>
</dd>
<dt>requirements<span class="classifier">str or list of str</span></dt><dd><p>The requirements list can be any of the following</p>
<ul class="simple">
<li><p>‘F_CONTIGUOUS’ (‘F’) - ensure a Fortran-contiguous array</p></li>
<li><p>‘C_CONTIGUOUS’ (‘C’) - ensure a C-contiguous array</p></li>
<li><p>‘ALIGNED’ (‘A’)      - ensure a data-type aligned array</p></li>
<li><p>‘WRITEABLE’ (‘W’)    - ensure a writable array</p></li>
<li><p>‘OWNDATA’ (‘O’)      - ensure an array that owns its own data</p></li>
<li><p>‘ENSUREARRAY’, (‘E’) - ensure a base array, instead of a subclass</p></li>
</ul>
</dd>
<dt>like<span class="classifier">array_like</span></dt><dd><p>Reference object to allow the creation of arrays which are not
NumPy arrays. If an array-like passed in as <code class="docutils literal notranslate"><span class="pre">like</span></code> supports
the <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> protocol, the result will be defined
by it. In this case, it ensures the creation of an array object
compatible with that passed in via this argument.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.20.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>Array with specified requirements and type if given.</p>
</dd>
</dl>
<p>asarray : Convert input to an ndarray.
asanyarray : Convert to an ndarray, but pass through ndarray subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfortranarray : Convert input to an ndarray with column-major</p>
<blockquote>
<div><p>memory order.</p>
</div></blockquote>
<p>ndarray.flags : Information about the memory layout of the array.</p>
<p>The returned array will be guaranteed to have the listed requirements
by making a copy if needed.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">flags</span>
<span class="go">  C_CONTIGUOUS : True</span>
<span class="go">  F_CONTIGUOUS : False</span>
<span class="go">  OWNDATA : False</span>
<span class="go">  WRITEABLE : True</span>
<span class="go">  ALIGNED : True</span>
<span class="go">  WRITEBACKIFCOPY : False</span>
<span class="go">  UPDATEIFCOPY : False</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">requirements</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">flags</span>
<span class="go">  C_CONTIGUOUS : False</span>
<span class="go">  F_CONTIGUOUS : True</span>
<span class="go">  OWNDATA : True</span>
<span class="go">  WRITEABLE : True</span>
<span class="go">  ALIGNED : True</span>
<span class="go">  WRITEBACKIFCOPY : False</span>
<span class="go">  UPDATEIFCOPY : False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.reshape">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">reshape</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">newshape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'C'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.reshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives a new shape to an array without changing its data.</p>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>Array to be reshaped.</p>
</dd>
<dt>newshape<span class="classifier">int or tuple of ints</span></dt><dd><p>The new shape should be compatible with the original shape. If
an integer, then the result will be a 1-D array of that length.
One shape dimension can be -1. In this case, the value is
inferred from the length of the array and remaining dimensions.</p>
</dd>
<dt>order<span class="classifier">{‘C’, ‘F’, ‘A’}, optional</span></dt><dd><p>Read the elements of <cite>a</cite> using this index order, and place the
elements into the reshaped array using this index order.  ‘C’
means to read / write the elements using C-like index order,
with the last axis index changing fastest, back to the first
axis index changing slowest. ‘F’ means to read / write the
elements using Fortran-like index order, with the first index
changing fastest, and the last index changing slowest. Note that
the ‘C’ and ‘F’ options take no account of the memory layout of
the underlying array, and only refer to the order of indexing.
‘A’ means to read / write the elements in Fortran-like index
order if <cite>a</cite> is Fortran <em>contiguous</em> in memory, C-like order
otherwise.</p>
</dd>
</dl>
<dl class="simple">
<dt>reshaped_array<span class="classifier">ndarray</span></dt><dd><p>This will be a new view object if possible; otherwise, it will
be a copy.  Note there is no guarantee of the <em>memory layout</em> (C- or
Fortran- contiguous) of the returned array.</p>
</dd>
</dl>
<p>ndarray.reshape : Equivalent method.</p>
<p>It is not always possible to change the shape of an array without
copying the data. If you want an error to be raised when the data is copied,
you should assign the new shape to the shape attribute of the array:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

<span class="go"># A transpose makes the array non-contiguous</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">T</span>

<span class="go"># Taking a view makes it possible to modify the shape without modifying</span>
<span class="go"># the initial object.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
   <span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">Incompatible shape for in-place modification. Use</span>
<span class="go">`.reshape()` to make a copy with the desired shape.</span>
</pre></div>
</div>
<p>The <cite>order</cite> keyword gives the index ordering both for <em>fetching</em> the values
from <cite>a</cite>, and then <em>placing</em> the values into the output array.
For example, let’s say you have an array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3],</span>
<span class="go">       [4, 5]])</span>
</pre></div>
</div>
<p>You can think of reshaping as first raveling the array (using the given
index order), then inserting the elements from the raveled array into the
new array using the same kind of index ordering as was used for the
raveling.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="c1"># C-like index ordering</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="c1"># equivalent to C ravel then C reshape</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span> <span class="c1"># Fortran-like index ordering</span>
<span class="go">array([[0, 4, 3],</span>
<span class="go">       [2, 1, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
<span class="go">array([[0, 4, 3],</span>
<span class="go">       [2, 1, 5]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="go">array([1, 2, 3, 4, 5, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
<span class="go">array([1, 4, 2, 5, 3, 6])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>       <span class="c1"># the unspecified value is inferred to be 2</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4],</span>
<span class="go">       [5, 6]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.resize">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">resize</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.resize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new array with the specified shape.</p>
<p>If the new array is larger than the original array, then the new
array is filled with repeated copies of <cite>a</cite>.  Note that this behavior
is different from a.resize(new_shape) which fills with zeros instead
of repeated copies of <cite>a</cite>.</p>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>Array to be resized.</p>
</dd>
<dt>new_shape<span class="classifier">int or tuple of int</span></dt><dd><p>Shape of resized array.</p>
</dd>
</dl>
<dl class="simple">
<dt>reshaped_array<span class="classifier">ndarray</span></dt><dd><p>The new array is formed from the data in the old array, repeated
if necessary to fill out the required number of elements.  The
data are repeated iterating over the array in C-order.</p>
</dd>
</dl>
<p>np.reshape : Reshape an array without changing the total size.
np.pad : Enlarge and pad an array.
np.repeat : Repeat elements of an array.
ndarray.resize : resize an array in-place.</p>
<p>When the total size of the array does not change <cite>~numpy.reshape</cite> should
be used.  In most other cases either indexing (to reduce the size)
or padding (to increase the size) may be a more appropriate solution.</p>
<p>Warning: This functionality does <strong>not</strong> consider axes separately,
i.e. it does not apply interpolation/extrapolation.
It fills the return array with the required number of elements, iterating
over <cite>a</cite> in C-order, disregarding axes (and cycling back from the start if
the new shape is larger).  This functionality is therefore not suitable to
resize images, or data where each axis represents a separate and distinct
entity.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">a</span><span class="p">,(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 0, 1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">a</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="go">array([[0, 1, 2, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">a</span><span class="p">,(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="go">array([[0, 1, 2, 3],</span>
<span class="go">       [0, 1, 2, 3]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.result_type">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">result_type</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">arrays_and_dtypes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.result_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the type that results from applying the NumPy
type promotion rules to the arguments.</p>
<p>Type promotion in NumPy works similarly to the rules in languages
like C++, with some slight differences.  When both scalars and
arrays are used, the array’s type takes precedence and the actual value
of the scalar is taken into account.</p>
<p>For example, calculating 3*a, where a is an array of 32-bit floats,
intuitively should result in a 32-bit float output.  If the 3 is a
32-bit integer, the NumPy rules indicate it can’t convert losslessly
into a 32-bit float, so a 64-bit float should be the result type.
By examining the value of the constant, ‘3’, we see that it fits in
an 8-bit integer, which can be cast losslessly into the 32-bit float.</p>
<dl class="simple">
<dt>arrays_and_dtypes<span class="classifier">list of arrays and dtypes</span></dt><dd><p>The operands of some operation whose result type is needed.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">dtype</span></dt><dd><p>The result type.</p>
</dd>
</dl>
<p>dtype, promote_types, min_scalar_type, can_cast</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.6.0.</span></p>
</div>
<p>The specific algorithm used is as follows.</p>
<p>Categories are determined by first checking which of boolean,
integer (int/uint), or floating point (float/complex) the maximum
kind of all the arrays and the scalars are.</p>
<p>If there are only scalars or the maximum category of the scalars
is higher than the maximum category of the arrays,
the data types are combined with <a class="reference internal" href="#numpy.promote_types" title="numpy.promote_types"><code class="xref py py-func docutils literal notranslate"><span class="pre">promote_types()</span></code></a>
to produce the return value.</p>
<p>Otherwise, <cite>min_scalar_type</cite> is called on each array, and
the resulting data types are all combined with <a class="reference internal" href="#numpy.promote_types" title="numpy.promote_types"><code class="xref py py-func docutils literal notranslate"><span class="pre">promote_types()</span></code></a>
to produce the return value.</p>
<p>The set of int values is not a subset of the uint values for types
with the same number of bits, something not reflected in
<a class="reference internal" href="#numpy.min_scalar_type" title="numpy.min_scalar_type"><code class="xref py py-func docutils literal notranslate"><span class="pre">min_scalar_type()</span></code></a>, but handled as a special case in <cite>result_type</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;i1&#39;</span><span class="p">))</span>
<span class="go">dtype(&#39;int8&#39;)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="s1">&#39;i4&#39;</span><span class="p">,</span> <span class="s1">&#39;c8&#39;</span><span class="p">)</span>
<span class="go">dtype(&#39;complex128&#39;)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">dtype(&#39;float64&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.roll">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">roll</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.roll" title="Permalink to this definition">¶</a></dt>
<dd><p>Roll array elements along a given axis.</p>
<p>Elements that roll beyond the last position are re-introduced at
the first.</p>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt>shift<span class="classifier">int or tuple of ints</span></dt><dd><p>The number of places by which elements are shifted.  If a tuple,
then <cite>axis</cite> must be a tuple of the same size, and each of the
given axes is shifted by the corresponding number.  If an int
while <cite>axis</cite> is a tuple of ints, then the same value is used for
all given axes.</p>
</dd>
<dt>axis<span class="classifier">int or tuple of ints, optional</span></dt><dd><p>Axis or axes along which elements are shifted.  By default, the
array is flattened before shifting, after which the original
shape is restored.</p>
</dd>
</dl>
<dl class="simple">
<dt>res<span class="classifier">ndarray</span></dt><dd><p>Output array, with the same shape as <cite>a</cite>.</p>
</dd>
</dl>
<dl class="simple">
<dt>rollaxis<span class="classifier">Roll the specified axis backwards, until it lies in a</span></dt><dd><p>given position.</p>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.12.0.</span></p>
</div>
<p>Supports rolling over multiple dimensions simultaneously.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([8, 9, 0, 1, 2, 3, 4, 5, 6, 7])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([2, 3, 4, 5, 6, 7, 8, 9, 0, 1])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span>
<span class="go">array([[0, 1, 2, 3, 4],</span>
<span class="go">       [5, 6, 7, 8, 9]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">array([[9, 0, 1, 2, 3],</span>
<span class="go">       [4, 5, 6, 7, 8]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[1, 2, 3, 4, 5],</span>
<span class="go">       [6, 7, 8, 9, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[5, 6, 7, 8, 9],</span>
<span class="go">       [0, 1, 2, 3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[5, 6, 7, 8, 9],</span>
<span class="go">       [0, 1, 2, 3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[4, 0, 1, 2, 3],</span>
<span class="go">       [9, 5, 6, 7, 8]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[1, 2, 3, 4, 0],</span>
<span class="go">       [6, 7, 8, 9, 5]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.rollaxis">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">rollaxis</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.rollaxis" title="Permalink to this definition">¶</a></dt>
<dd><p>Roll the specified axis backwards, until it lies in a given position.</p>
<p>This function continues to be supported for backward compatibility, but you
should prefer <cite>moveaxis</cite>. The <cite>moveaxis</cite> function was added in NumPy
1.11.</p>
<dl>
<dt>a<span class="classifier">ndarray</span></dt><dd><p>Input array.</p>
</dd>
<dt>axis<span class="classifier">int</span></dt><dd><p>The axis to be rolled. The positions of the other axes do not
change relative to one another.</p>
</dd>
<dt>start<span class="classifier">int, optional</span></dt><dd><p>When <code class="docutils literal notranslate"><span class="pre">start</span> <span class="pre">&lt;=</span> <span class="pre">axis</span></code>, the axis is rolled back until it lies in
this position. When <code class="docutils literal notranslate"><span class="pre">start</span> <span class="pre">&gt;</span> <span class="pre">axis</span></code>, the axis is rolled until it
lies before this position. The default, 0, results in a “complete”
roll. The following table describes how negative values of <code class="docutils literal notranslate"><span class="pre">start</span></code>
are interpreted:</p>
<table class="table">
<colgroup>
<col style="width: 46%" />
<col style="width: 54%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><code class="docutils literal notranslate"><span class="pre">start</span></code></p></th>
<th class="head"><p>Normalized <code class="docutils literal notranslate"><span class="pre">start</span></code></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-(arr.ndim+1)</span></code></p></td>
<td><p>raise <code class="docutils literal notranslate"><span class="pre">AxisError</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-arr.ndim</span></code></p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>⋮</p></td>
<td><p>⋮</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-1</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">arr.ndim-1</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">0</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">0</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>⋮</p></td>
<td><p>⋮</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">arr.ndim</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">arr.ndim</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">arr.ndim</span> <span class="pre">+</span> <span class="pre">1</span></code></p></td>
<td><p>raise <code class="docutils literal notranslate"><span class="pre">AxisError</span></code></p></td>
</tr>
</tbody>
</table>
</dd>
</dl>
<dl class="simple">
<dt>res<span class="classifier">ndarray</span></dt><dd><p>For NumPy &gt;= 1.10.0 a view of <cite>a</cite> is always returned. For earlier
NumPy versions a view of <cite>a</cite> is returned only if the order of the
axes is changed, otherwise the input array is returned.</p>
</dd>
</dl>
<p>moveaxis : Move array axes to new positions.
roll : Roll the elements of an array by a number of positions along a</p>
<blockquote>
<div><p>given axis.</p>
</div></blockquote>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 6, 4, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 3, 4, 6)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 5, 6, 4)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.roots">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">roots</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the roots of a polynomial with coefficients given in p.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This forms part of the old polynomial API. Since version 1.4, the
new polynomial API defined in <cite>numpy.polynomial</cite> is preferred.
A summary of the differences can be found in the
<span class="xref std std-doc">transition guide</span>.</p>
</div>
<p>The values in the rank-1 array <cite>p</cite> are coefficients of a polynomial.
If the length of <cite>p</cite> is n+1 then the polynomial is described by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="n">n</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="o">...</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</pre></div>
</div>
<dl class="simple">
<dt>p<span class="classifier">array_like</span></dt><dd><p>Rank-1 array of polynomial coefficients.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>An array containing the roots of the polynomial.</p>
</dd>
</dl>
<dl class="simple">
<dt>ValueError</dt><dd><p>When <cite>p</cite> cannot be converted to a rank-1 array.</p>
</dd>
</dl>
<dl class="simple">
<dt>poly<span class="classifier">Find the coefficients of a polynomial with a given sequence</span></dt><dd><p>of roots.</p>
</dd>
</dl>
<p>polyval : Compute polynomial values.
polyfit : Least squares polynomial fit.
poly1d : A one-dimensional polynomial class.</p>
<p>The algorithm relies on computing the eigenvalues of the
companion matrix <a href="#id92"><span class="problematic" id="id57">[1]_</span></a>.</p>
<dl class="footnote brackets">
<dt class="label" id="id58"><span class="brackets">1</span></dt>
<dd><p>R. A. Horn &amp; C. R. Johnson, <em>Matrix Analysis</em>.  Cambridge, UK:
Cambridge University Press, 1999, pp. 146-7.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coeff</span> <span class="o">=</span> <span class="p">[</span><span class="mf">3.2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">roots</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>
<span class="go">array([-0.3125+0.46351241j, -0.3125-0.46351241j])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.rot90">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">rot90</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">1)</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.rot90" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate an array by 90 degrees in the plane specified by axes.</p>
<p>Rotation direction is from the first towards the second axis.</p>
<dl>
<dt>m<span class="classifier">array_like</span></dt><dd><p>Array of two or more dimensions.</p>
</dd>
<dt>k<span class="classifier">integer</span></dt><dd><p>Number of times the array is rotated by 90 degrees.</p>
</dd>
<dt>axes: (2,) array_like</dt><dd><p>The array is rotated in the plane defined by the axes.
Axes must be different.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.12.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>y<span class="classifier">ndarray</span></dt><dd><p>A rotated view of <cite>m</cite>.</p>
</dd>
</dl>
<p>flip : Reverse the order of elements in an array along the given axis.
fliplr : Flip an array horizontally.
flipud : Flip an array vertically.</p>
<p>rot90(m, k=1, axes=(1,0)) is the reverse of rot90(m, k=1, axes=(0,1))
rot90(m, k=1, axes=(1,0)) is equivalent to rot90(m, k=-1, axes=(0,1))</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]],</span> <span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">rot90</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">array([[2, 4],</span>
<span class="go">       [1, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">rot90</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([[4, 3],</span>
<span class="go">       [2, 1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">rot90</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="go">array([[[1, 3],</span>
<span class="go">        [0, 2]],</span>
<span class="go">       [[5, 7],</span>
<span class="go">        [4, 6]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.round_">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">round_</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decimals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.round_" title="Permalink to this definition">¶</a></dt>
<dd><p>Round an array to the given number of decimals.</p>
<p>around : equivalent function; see for details.</p>
</dd></dl>

<dl class="py function">
<dt id="numpy.row_stack">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">row_stack</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tup</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.row_stack" title="Permalink to this definition">¶</a></dt>
<dd><p>Stack arrays in sequence vertically (row wise).</p>
<p>This is equivalent to concatenation along the first axis after 1-D arrays
of shape <cite>(N,)</cite> have been reshaped to <cite>(1,N)</cite>. Rebuilds arrays divided by
<cite>vsplit</cite>.</p>
<p>This function makes most sense for arrays with up to 3 dimensions. For
instance, for pixel-data with a height (first axis), width (second axis),
and r/g/b channels (third axis). The functions <cite>concatenate</cite>, <cite>stack</cite> and
<cite>block</cite> provide more general stacking and concatenation operations.</p>
<dl class="simple">
<dt>tup<span class="classifier">sequence of ndarrays</span></dt><dd><p>The arrays must have the same shape along all but the first axis.
1-D arrays must have the same length.</p>
</dd>
</dl>
<dl class="simple">
<dt>stacked<span class="classifier">ndarray</span></dt><dd><p>The array formed by stacking the given arrays, will be at least 2-D.</p>
</dd>
</dl>
<p>concatenate : Join a sequence of arrays along an existing axis.
stack : Join a sequence of arrays along a new axis.
block : Assemble an nd-array from nested lists of blocks.
hstack : Stack arrays in sequence horizontally (column wise).
dstack : Stack arrays in sequence depth wise (along third axis).
column_stack : Stack 1-D arrays as columns into a 2-D array.
vsplit : Split an array into multiple sub-arrays vertically (row-wise).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [4, 5, 6]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
<span class="go">array([[1],</span>
<span class="go">       [2],</span>
<span class="go">       [3],</span>
<span class="go">       [4],</span>
<span class="go">       [5],</span>
<span class="go">       [6]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.safe_eval">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">safe_eval</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.safe_eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Protected string evaluation.</p>
<p>Evaluate a string containing a Python literal expression without
allowing the execution of arbitrary non-literal code.</p>
<dl class="simple">
<dt>source<span class="classifier">str</span></dt><dd><p>The string to evaluate.</p>
</dd>
</dl>
<dl class="simple">
<dt>obj<span class="classifier">object</span></dt><dd><p>The result of evaluating <cite>source</cite>.</p>
</dd>
</dl>
<dl class="simple">
<dt>SyntaxError</dt><dd><p>If the code has invalid Python syntax, or if it contains
non-literal code.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">safe_eval</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">safe_eval</span><span class="p">(</span><span class="s1">&#39;[1, 2, 3]&#39;</span><span class="p">)</span>
<span class="go">[1, 2, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">safe_eval</span><span class="p">(</span><span class="s1">&#39;{&quot;foo&quot;: (&quot;bar&quot;, 10.0)}&#39;</span><span class="p">)</span>
<span class="go">{&#39;foo&#39;: (&#39;bar&#39;, 10.0)}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">safe_eval</span><span class="p">(</span><span class="s1">&#39;import os&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">SyntaxError</span>: <span class="n">invalid syntax</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">safe_eval</span><span class="p">(</span><span class="s1">&#39;open(&quot;/home/user/.ssh/id_dsa&quot;).read()&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">malformed node or string: &lt;_ast.Call object at 0x...&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.save">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">save</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_pickle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fix_imports</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save an array to a binary file in NumPy <code class="docutils literal notranslate"><span class="pre">.npy</span></code> format.</p>
<dl class="simple">
<dt>file<span class="classifier">file, str, or pathlib.Path</span></dt><dd><p>File or filename to which the data is saved.  If file is a file-object,
then the filename is unchanged.  If file is a string or Path, a <code class="docutils literal notranslate"><span class="pre">.npy</span></code>
extension will be appended to the filename if it does not already
have one.</p>
</dd>
<dt>arr<span class="classifier">array_like</span></dt><dd><p>Array data to be saved.</p>
</dd>
<dt>allow_pickle<span class="classifier">bool, optional</span></dt><dd><p>Allow saving object arrays using Python pickles. Reasons for disallowing
pickles include security (loading pickled data can execute arbitrary
code) and portability (pickled objects may not be loadable on different
Python installations, for example if the stored objects require libraries
that are not available, and not all pickled data is compatible between
Python 2 and Python 3).
Default: True</p>
</dd>
<dt>fix_imports<span class="classifier">bool, optional</span></dt><dd><p>Only useful in forcing objects in object arrays on Python 3 to be
pickled in a Python 2 compatible way. If <cite>fix_imports</cite> is True, pickle
will try to map the new Python 3 names to the old module names used in
Python 2, so that the pickle data stream is readable with Python 2.</p>
</dd>
</dl>
<p>savez : Save several arrays into a <code class="docutils literal notranslate"><span class="pre">.npz</span></code> archive
savetxt, load</p>
<p>For a description of the <code class="docutils literal notranslate"><span class="pre">.npy</span></code> format, see <code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy.lib.format</span></code>.</p>
<p>Any data saved to the file is appended to the end of the file.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">tempfile</span> <span class="kn">import</span> <span class="n">TemporaryFile</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">outfile</span> <span class="o">=</span> <span class="n">TemporaryFile</span><span class="p">()</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">outfile</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># Only needed here to simulate closing &amp; reopening file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">outfile</span><span class="p">)</span>
<span class="go">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;test.npy&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="gp">... </span>    <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;test.npy&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go"># [1 2] [1 3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.savetxt">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">savetxt</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'%.18e'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delimiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'</span> <span class="pre">'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">newline</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'\n'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">header</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">footer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'#</span> <span class="pre">'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.savetxt" title="Permalink to this definition">¶</a></dt>
<dd><p>Save an array to a text file.</p>
<dl>
<dt>fname<span class="classifier">filename or file handle</span></dt><dd><p>If the filename ends in <code class="docutils literal notranslate"><span class="pre">.gz</span></code>, the file is automatically saved in
compressed gzip format.  <cite>loadtxt</cite> understands gzipped files
transparently.</p>
</dd>
<dt>X<span class="classifier">1D or 2D array_like</span></dt><dd><p>Data to be saved to a text file.</p>
</dd>
<dt>fmt<span class="classifier">str or sequence of strs, optional</span></dt><dd><p>A single format (%10.5f), a sequence of formats, or a
multi-format string, e.g. ‘Iteration %d – %10.5f’, in which
case <cite>delimiter</cite> is ignored. For complex <cite>X</cite>, the legal options
for <cite>fmt</cite> are:</p>
<ul class="simple">
<li><p>a single specifier, <cite>fmt=’%.4e’</cite>, resulting in numbers formatted
like <cite>‘ (%s+%sj)’ % (fmt, fmt)</cite></p></li>
<li><p>a full string specifying every real and imaginary part, e.g.
<cite>‘ %.4e %+.4ej %.4e %+.4ej %.4e %+.4ej’</cite> for 3 columns</p></li>
<li><p>a list of specifiers, one per column - in this case, the real
and imaginary part must have separate specifiers,
e.g. <cite>[‘%.3e + %.3ej’, ‘(%.15e%+.15ej)’]</cite> for 2 columns</p></li>
</ul>
</dd>
<dt>delimiter<span class="classifier">str, optional</span></dt><dd><p>String or character separating columns.</p>
</dd>
<dt>newline<span class="classifier">str, optional</span></dt><dd><p>String or character separating lines.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.5.0.</span></p>
</div>
</dd>
<dt>header<span class="classifier">str, optional</span></dt><dd><p>String that will be written at the beginning of the file.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
</dd>
<dt>footer<span class="classifier">str, optional</span></dt><dd><p>String that will be written at the end of the file.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
</dd>
<dt>comments<span class="classifier">str, optional</span></dt><dd><p>String that will be prepended to the <code class="docutils literal notranslate"><span class="pre">header</span></code> and <code class="docutils literal notranslate"><span class="pre">footer</span></code> strings,
to mark them as comments. Default: ‘# ‘,  as expected by e.g.
<code class="docutils literal notranslate"><span class="pre">numpy.loadtxt</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
</dd>
<dt>encoding<span class="classifier">{None, str}, optional</span></dt><dd><p>Encoding used to encode the outputfile. Does not apply to output
streams. If the encoding is something other than ‘bytes’ or ‘latin1’
you will not be able to load the file in NumPy versions &lt; 1.14. Default
is ‘latin1’.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.14.0.</span></p>
</div>
</dd>
</dl>
<p>save : Save an array to a binary file in NumPy <code class="docutils literal notranslate"><span class="pre">.npy</span></code> format
savez : Save several arrays into an uncompressed <code class="docutils literal notranslate"><span class="pre">.npz</span></code> archive
savez_compressed : Save several arrays into a compressed <code class="docutils literal notranslate"><span class="pre">.npz</span></code> archive</p>
<p>Further explanation of the <cite>fmt</cite> parameter
(<code class="docutils literal notranslate"><span class="pre">%[flag]width[.precision]specifier</span></code>):</p>
<dl>
<dt>flags:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">-</span></code> : left justify</p>
<p><code class="docutils literal notranslate"><span class="pre">+</span></code> : Forces to precede result with + or -.</p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> : Left pad the number with zeros instead of space (see width).</p>
</dd>
<dt>width:</dt><dd><p>Minimum number of characters to be printed. The value is not truncated
if it has more characters.</p>
</dd>
<dt>precision:</dt><dd><ul class="simple">
<li><p>For integer specifiers (eg. <code class="docutils literal notranslate"><span class="pre">d,i,o,x</span></code>), the minimum number of
digits.</p></li>
<li><p>For <code class="docutils literal notranslate"><span class="pre">e,</span> <span class="pre">E</span></code> and <code class="docutils literal notranslate"><span class="pre">f</span></code> specifiers, the number of digits to print
after the decimal point.</p></li>
<li><p>For <code class="docutils literal notranslate"><span class="pre">g</span></code> and <code class="docutils literal notranslate"><span class="pre">G</span></code>, the maximum number of significant digits.</p></li>
<li><p>For <code class="docutils literal notranslate"><span class="pre">s</span></code>, the maximum number of characters.</p></li>
</ul>
</dd>
<dt>specifiers:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">c</span></code> : character</p>
<p><code class="docutils literal notranslate"><span class="pre">d</span></code> or <code class="docutils literal notranslate"><span class="pre">i</span></code> : signed decimal integer</p>
<p><code class="docutils literal notranslate"><span class="pre">e</span></code> or <code class="docutils literal notranslate"><span class="pre">E</span></code> : scientific notation with <code class="docutils literal notranslate"><span class="pre">e</span></code> or <code class="docutils literal notranslate"><span class="pre">E</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">f</span></code> : decimal floating point</p>
<p><code class="docutils literal notranslate"><span class="pre">g,G</span></code> : use the shorter of <code class="docutils literal notranslate"><span class="pre">e,E</span></code> or <code class="docutils literal notranslate"><span class="pre">f</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">o</span></code> : signed octal</p>
<p><code class="docutils literal notranslate"><span class="pre">s</span></code> : string of characters</p>
<p><code class="docutils literal notranslate"><span class="pre">u</span></code> : unsigned decimal integer</p>
<p><code class="docutils literal notranslate"><span class="pre">x,X</span></code> : unsigned hexadecimal integer</p>
</dd>
</dl>
<p>This explanation of <code class="docutils literal notranslate"><span class="pre">fmt</span></code> is not complete, for an exhaustive
specification see <a href="#id93"><span class="problematic" id="id59">[1]_</span></a>.</p>
<dl class="footnote brackets">
<dt class="label" id="id60"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://docs.python.org/library/string.html#format-specification-mini-language">Format Specification Mini-Language</a>,
Python Documentation.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="o">=</span> <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">5.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="s1">&#39;test.out&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>   <span class="c1"># X is an array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="s1">&#39;test.out&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">))</span>   <span class="c1"># x,y,z equal sized 1D arrays</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="s1">&#39;test.out&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%1.4e</span><span class="s1">&#39;</span><span class="p">)</span>   <span class="c1"># use exponential notation</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.savez">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">savez</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.savez" title="Permalink to this definition">¶</a></dt>
<dd><p>Save several arrays into a single file in uncompressed <code class="docutils literal notranslate"><span class="pre">.npz</span></code> format.</p>
<p>Provide arrays as keyword arguments to store them under the
corresponding name in the output file: <code class="docutils literal notranslate"><span class="pre">savez(fn,</span> <span class="pre">x=x,</span> <span class="pre">y=y)</span></code>.</p>
<p>If arrays are specified as positional arguments, i.e., <code class="docutils literal notranslate"><span class="pre">savez(fn,</span>
<span class="pre">x,</span> <span class="pre">y)</span></code>, their names will be <cite>arr_0</cite>, <cite>arr_1</cite>, etc.</p>
<dl class="simple">
<dt>file<span class="classifier">str or file</span></dt><dd><p>Either the filename (string) or an open file (file-like object)
where the data will be saved. If file is a string or a Path, the
<code class="docutils literal notranslate"><span class="pre">.npz</span></code> extension will be appended to the filename if it is not
already there.</p>
</dd>
<dt>args<span class="classifier">Arguments, optional</span></dt><dd><p>Arrays to save to the file. Please use keyword arguments (see
<cite>kwds</cite> below) to assign names to arrays.  Arrays specified as
args will be named “arr_0”, “arr_1”, and so on.</p>
</dd>
<dt>kwds<span class="classifier">Keyword arguments, optional</span></dt><dd><p>Arrays to save to the file. Each array will be saved to the
output file with its corresponding keyword name.</p>
</dd>
</dl>
<p>None</p>
<p>save : Save a single array to a binary file in NumPy format.
savetxt : Save an array to a file as plain text.
savez_compressed : Save several arrays into a compressed <code class="docutils literal notranslate"><span class="pre">.npz</span></code> archive</p>
<p>The <code class="docutils literal notranslate"><span class="pre">.npz</span></code> file format is a zipped archive of files named after the
variables they contain.  The archive is not compressed and each file
in the archive contains one variable in <code class="docutils literal notranslate"><span class="pre">.npy</span></code> format. For a
description of the <code class="docutils literal notranslate"><span class="pre">.npy</span></code> format, see <code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy.lib.format</span></code>.</p>
<p>When opening the saved <code class="docutils literal notranslate"><span class="pre">.npz</span></code> file with <cite>load</cite> a <cite>NpzFile</cite> object is
returned. This is a dictionary-like object which can be queried for
its list of arrays (with the <code class="docutils literal notranslate"><span class="pre">.files</span></code> attribute), and for the arrays
themselves.</p>
<p>When saving dictionaries, the dictionary keys become filenames
inside the ZIP archive. Therefore, keys should be valid filenames.
E.g., avoid keys that begin with <code class="docutils literal notranslate"><span class="pre">/</span></code> or contain <code class="docutils literal notranslate"><span class="pre">.</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">tempfile</span> <span class="kn">import</span> <span class="n">TemporaryFile</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">outfile</span> <span class="o">=</span> <span class="n">TemporaryFile</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Using <cite>savez</cite> with *args, the arrays are saved with default names.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">outfile</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># Only needed here to simulate closing &amp; reopening file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">npzfile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">outfile</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">npzfile</span><span class="o">.</span><span class="n">files</span>
<span class="go">[&#39;arr_0&#39;, &#39;arr_1&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">npzfile</span><span class="p">[</span><span class="s1">&#39;arr_0&#39;</span><span class="p">]</span>
<span class="go">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
</pre></div>
</div>
<p>Using <cite>savez</cite> with **kwds, the arrays are saved with the keyword names.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">outfile</span> <span class="o">=</span> <span class="n">TemporaryFile</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">outfile</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">npzfile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">outfile</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">npzfile</span><span class="o">.</span><span class="n">files</span><span class="p">)</span>
<span class="go">[&#39;x&#39;, &#39;y&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">npzfile</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
<span class="go">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.savez_compressed">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">savez_compressed</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.savez_compressed" title="Permalink to this definition">¶</a></dt>
<dd><p>Save several arrays into a single file in compressed <code class="docutils literal notranslate"><span class="pre">.npz</span></code> format.</p>
<p>Provide arrays as keyword arguments to store them under the
corresponding name in the output file: <code class="docutils literal notranslate"><span class="pre">savez(fn,</span> <span class="pre">x=x,</span> <span class="pre">y=y)</span></code>.</p>
<p>If arrays are specified as positional arguments, i.e., <code class="docutils literal notranslate"><span class="pre">savez(fn,</span>
<span class="pre">x,</span> <span class="pre">y)</span></code>, their names will be <cite>arr_0</cite>, <cite>arr_1</cite>, etc.</p>
<dl class="simple">
<dt>file<span class="classifier">str or file</span></dt><dd><p>Either the filename (string) or an open file (file-like object)
where the data will be saved. If file is a string or a Path, the
<code class="docutils literal notranslate"><span class="pre">.npz</span></code> extension will be appended to the filename if it is not
already there.</p>
</dd>
<dt>args<span class="classifier">Arguments, optional</span></dt><dd><p>Arrays to save to the file. Please use keyword arguments (see
<cite>kwds</cite> below) to assign names to arrays.  Arrays specified as
args will be named “arr_0”, “arr_1”, and so on.</p>
</dd>
<dt>kwds<span class="classifier">Keyword arguments, optional</span></dt><dd><p>Arrays to save to the file. Each array will be saved to the
output file with its corresponding keyword name.</p>
</dd>
</dl>
<p>None</p>
<p>numpy.save : Save a single array to a binary file in NumPy format.
numpy.savetxt : Save an array to a file as plain text.
numpy.savez : Save several arrays into an uncompressed <code class="docutils literal notranslate"><span class="pre">.npz</span></code> file format
numpy.load : Load the files created by savez_compressed.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">.npz</span></code> file format is a zipped archive of files named after the
variables they contain.  The archive is compressed with
<code class="docutils literal notranslate"><span class="pre">zipfile.ZIP_DEFLATED</span></code> and each file in the archive contains one variable
in <code class="docutils literal notranslate"><span class="pre">.npy</span></code> format. For a description of the <code class="docutils literal notranslate"><span class="pre">.npy</span></code> format, see
<code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy.lib.format</span></code>.</p>
<p>When opening the saved <code class="docutils literal notranslate"><span class="pre">.npz</span></code> file with <cite>load</cite> a <cite>NpzFile</cite> object is
returned. This is a dictionary-like object which can be queried for
its list of arrays (with the <code class="docutils literal notranslate"><span class="pre">.files</span></code> attribute), and for the arrays
themselves.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">test_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">savez_compressed</span><span class="p">(</span><span class="s1">&#39;/tmp/123&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">test_array</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">test_vector</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">loaded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;/tmp/123.npz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">test_array</span><span class="p">,</span> <span class="n">loaded</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">test_vector</span><span class="p">,</span> <span class="n">loaded</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.sctype2char">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">sctype2char</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sctype</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.sctype2char" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the string representation of a scalar dtype.</p>
<dl class="simple">
<dt>sctype<span class="classifier">scalar dtype or object</span></dt><dd><p>If a scalar dtype, the corresponding string character is
returned. If an object, <cite>sctype2char</cite> tries to infer its scalar type
and then return the corresponding string character.</p>
</dd>
</dl>
<dl class="simple">
<dt>typechar<span class="classifier">str</span></dt><dd><p>The string character corresponding to the scalar type.</p>
</dd>
</dl>
<dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>sctype</cite> is an object for which the type can not be inferred.</p>
</dd>
</dl>
<p>obj2sctype, issctype, issubsctype, mintypecode</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">sctype</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complex_</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">string_</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sctype2char</span><span class="p">(</span><span class="n">sctype</span><span class="p">))</span>
<span class="go">l # may vary</span>
<span class="go">d</span>
<span class="go">D</span>
<span class="go">S</span>
<span class="go">O</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mi">2</span><span class="o">-</span><span class="mf">1.</span><span class="n">j</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sctype2char</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">&#39;D&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sctype2char</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
<span class="go">&#39;O&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.searchsorted">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">searchsorted</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">side</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'left'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sorter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.searchsorted" title="Permalink to this definition">¶</a></dt>
<dd><p>Find indices where elements should be inserted to maintain order.</p>
<p>Find the indices into a sorted array <cite>a</cite> such that, if the
corresponding elements in <cite>v</cite> were inserted before the indices, the
order of <cite>a</cite> would be preserved.</p>
<p>Assuming that <cite>a</cite> is sorted:</p>
<table class="table">
<colgroup>
<col style="width: 18%" />
<col style="width: 82%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><cite>side</cite></p></th>
<th class="head"><p>returned index <cite>i</cite> satisfies</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>left</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a[i-1]</span> <span class="pre">&lt;</span> <span class="pre">v</span> <span class="pre">&lt;=</span> <span class="pre">a[i]</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>right</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a[i-1]</span> <span class="pre">&lt;=</span> <span class="pre">v</span> <span class="pre">&lt;</span> <span class="pre">a[i]</span></code></p></td>
</tr>
</tbody>
</table>
<dl>
<dt>a<span class="classifier">1-D array_like</span></dt><dd><p>Input array. If <cite>sorter</cite> is None, then it must be sorted in
ascending order, otherwise <cite>sorter</cite> must be an array of indices
that sort it.</p>
</dd>
<dt>v<span class="classifier">array_like</span></dt><dd><p>Values to insert into <cite>a</cite>.</p>
</dd>
<dt>side<span class="classifier">{‘left’, ‘right’}, optional</span></dt><dd><p>If ‘left’, the index of the first suitable location found is given.
If ‘right’, return the last such index.  If there is no suitable
index, return either 0 or N (where N is the length of <cite>a</cite>).</p>
</dd>
<dt>sorter<span class="classifier">1-D array_like, optional</span></dt><dd><p>Optional array of integer indices that sort array a into ascending
order. They are typically the result of argsort.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>indices<span class="classifier">array of ints</span></dt><dd><p>Array of insertion points with the same shape as <cite>v</cite>.</p>
</dd>
</dl>
<p>sort : Return a sorted copy of an array.
histogram : Produce histogram from 1-D data.</p>
<p>Binary search is used to find the required insertion points.</p>
<p>As of NumPy 1.4.0 <cite>searchsorted</cite> works with real/complex arrays containing
<cite>nan</cite> values. The enhanced sort order is documented in <cite>sort</cite>.</p>
<p>This function uses the same algorithm as the builtin python <cite>bisect.bisect_left</cite>
(<code class="docutils literal notranslate"><span class="pre">side='left'</span></code>) and <cite>bisect.bisect_right</cite> (<code class="docutils literal notranslate"><span class="pre">side='right'</span></code>) functions,
which is also vectorized in the <cite>v</cite> argument.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">array([0, 5, 1, 2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.select">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">select</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">condlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">choicelist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.select" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array drawn from elements in choicelist, depending on conditions.</p>
<dl class="simple">
<dt>condlist<span class="classifier">list of bool ndarrays</span></dt><dd><p>The list of conditions which determine from which array in <cite>choicelist</cite>
the output elements are taken. When multiple conditions are satisfied,
the first one encountered in <cite>condlist</cite> is used.</p>
</dd>
<dt>choicelist<span class="classifier">list of ndarrays</span></dt><dd><p>The list of arrays from which the output elements are taken. It has
to be of the same length as <cite>condlist</cite>.</p>
</dd>
<dt>default<span class="classifier">scalar, optional</span></dt><dd><p>The element inserted in <cite>output</cite> when all conditions evaluate to False.</p>
</dd>
</dl>
<dl class="simple">
<dt>output<span class="classifier">ndarray</span></dt><dd><p>The output at position m is the m-th element of the array in
<cite>choicelist</cite> where the m-th element of the corresponding array in
<cite>condlist</cite> is True.</p>
</dd>
</dl>
<p>where : Return elements from one of two arrays depending on condition.
take, choose, compress, diag, diagonal</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">condlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="n">x</span><span class="o">&gt;</span><span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">choicelist</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">condlist</span><span class="p">,</span> <span class="n">choicelist</span><span class="p">)</span>
<span class="go">array([ 0,  1,  2, ..., 49, 64, 81])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.set_numeric_ops">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">set_numeric_ops</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">op1=func1</span></em>, <em class="sig-param"><span class="pre">op2=func2</span></em>, <em class="sig-param"><span class="pre">...</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.set_numeric_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Set numerical operators for array objects.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 1.16: </span>For the general case, use <code class="xref c c-func docutils literal notranslate"><span class="pre">PyUFunc_ReplaceLoopBySignature()</span></code>.
For ndarray subclasses, define the <code class="docutils literal notranslate"><span class="pre">__array_ufunc__</span></code> method and
override the relevant ufunc.</p>
</div>
<dl class="simple">
<dt>op1, op2, …<span class="classifier">callable</span></dt><dd><p>Each <code class="docutils literal notranslate"><span class="pre">op</span> <span class="pre">=</span> <span class="pre">func</span></code> pair describes an operator to be replaced.
For example, <code class="docutils literal notranslate"><span class="pre">add</span> <span class="pre">=</span> <span class="pre">lambda</span> <span class="pre">x,</span> <span class="pre">y:</span> <span class="pre">np.add(x,</span> <span class="pre">y)</span> <span class="pre">%</span> <span class="pre">5</span></code> would replace
addition by modulus 5 addition.</p>
</dd>
</dl>
<dl class="simple">
<dt>saved_ops<span class="classifier">list of callables</span></dt><dd><p>A list of all operators, stored before making replacements.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Use with care!  Incorrect usage may lead to memory errors.</p>
</div>
<p>A function replacing an operator cannot make use of that operator.
For example, when replacing add, you may not use <code class="docutils literal notranslate"><span class="pre">+</span></code>.  Instead,
directly call ufuncs.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">add_mod5</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">%</span> <span class="mi">5</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">old_funcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">set_numeric_ops</span><span class="p">(</span><span class="n">add</span><span class="o">=</span><span class="n">add_mod5</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span>
<span class="go">array([[0, 2, 4, 1],</span>
<span class="go">       [3, 0, 2, 4],</span>
<span class="go">       [1, 3, 0, 2]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ignore</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">set_numeric_ops</span><span class="p">(</span><span class="o">**</span><span class="n">old_funcs</span><span class="p">)</span> <span class="c1"># restore operators</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.set_printoptions">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">set_printoptions</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edgeitems</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linewidth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suppress</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nanstr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">infstr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">formatter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sign</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">floatmode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legacy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.set_printoptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Set printing options.</p>
<p>These options determine the way floating point numbers, arrays and
other NumPy objects are displayed.</p>
<dl>
<dt>precision<span class="classifier">int or None, optional</span></dt><dd><p>Number of digits of precision for floating point output (default 8).
May be None if <cite>floatmode</cite> is not <cite>fixed</cite>, to print as many digits as
necessary to uniquely specify the value.</p>
</dd>
<dt>threshold<span class="classifier">int, optional</span></dt><dd><p>Total number of array elements which trigger summarization
rather than full repr (default 1000).
To always use the full repr without summarization, pass <cite>sys.maxsize</cite>.</p>
</dd>
<dt>edgeitems<span class="classifier">int, optional</span></dt><dd><p>Number of array items in summary at beginning and end of
each dimension (default 3).</p>
</dd>
<dt>linewidth<span class="classifier">int, optional</span></dt><dd><p>The number of characters per line for the purpose of inserting
line breaks (default 75).</p>
</dd>
<dt>suppress<span class="classifier">bool, optional</span></dt><dd><p>If True, always print floating point numbers using fixed point
notation, in which case numbers equal to zero in the current precision
will print as zero.  If False, then scientific notation is used when
absolute value of the smallest number is &lt; 1e-4 or the ratio of the
maximum absolute value to the minimum is &gt; 1e3. The default is False.</p>
</dd>
<dt>nanstr<span class="classifier">str, optional</span></dt><dd><p>String representation of floating point not-a-number (default nan).</p>
</dd>
<dt>infstr<span class="classifier">str, optional</span></dt><dd><p>String representation of floating point infinity (default inf).</p>
</dd>
<dt>sign<span class="classifier">string, either ‘-‘, ‘+’, or ‘ ‘, optional</span></dt><dd><p>Controls printing of the sign of floating-point types. If ‘+’, always
print the sign of positive values. If ‘ ‘, always prints a space
(whitespace character) in the sign position of positive values.  If
‘-‘, omit the sign character of positive values. (default ‘-‘)</p>
</dd>
<dt>formatter<span class="classifier">dict of callables, optional</span></dt><dd><p>If not None, the keys should indicate the type(s) that the respective
formatting function applies to.  Callables should return a string.
Types that are not specified (by their corresponding keys) are handled
by the default formatters.  Individual types for which a formatter
can be set are:</p>
<ul class="simple">
<li><p>‘bool’</p></li>
<li><p>‘int’</p></li>
<li><p>‘timedelta’ : a <cite>numpy.timedelta64</cite></p></li>
<li><p>‘datetime’ : a <cite>numpy.datetime64</cite></p></li>
<li><p>‘float’</p></li>
<li><p>‘longfloat’ : 128-bit floats</p></li>
<li><p>‘complexfloat’</p></li>
<li><p>‘longcomplexfloat’ : composed of two 128-bit floats</p></li>
<li><p>‘numpystr’ : types <cite>numpy.string_</cite> and <cite>numpy.unicode_</cite></p></li>
<li><p>‘object’ : <cite>np.object_</cite> arrays</p></li>
</ul>
<p>Other keys that can be used to set a group of types at once are:</p>
<ul class="simple">
<li><p>‘all’ : sets all types</p></li>
<li><p>‘int_kind’ : sets ‘int’</p></li>
<li><p>‘float_kind’ : sets ‘float’ and ‘longfloat’</p></li>
<li><p>‘complex_kind’ : sets ‘complexfloat’ and ‘longcomplexfloat’</p></li>
<li><p>‘str_kind’ : sets ‘numpystr’</p></li>
</ul>
</dd>
<dt>floatmode<span class="classifier">str, optional</span></dt><dd><p>Controls the interpretation of the <cite>precision</cite> option for
floating-point types. Can take the following values
(default maxprec_equal):</p>
<ul class="simple">
<li><dl class="simple">
<dt>‘fixed’: Always print exactly <cite>precision</cite> fractional digits,</dt><dd><p>even if this would print more or fewer digits than
necessary to specify the value uniquely.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘unique’: Print the minimum number of fractional digits necessary</dt><dd><p>to represent each value uniquely. Different elements may
have a different number of digits. The value of the
<cite>precision</cite> option is ignored.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘maxprec’: Print at most <cite>precision</cite> fractional digits, but if</dt><dd><p>an element can be uniquely represented with fewer digits
only print it with that many.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘maxprec_equal’: Print at most <cite>precision</cite> fractional digits,</dt><dd><p>but if every element in the array can be uniquely
represented with an equal number of fewer digits, use that
many digits for all elements.</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt>legacy<span class="classifier">string or <cite>False</cite>, optional</span></dt><dd><p>If set to the string <cite>‘1.13’</cite> enables 1.13 legacy printing mode. This
approximates numpy 1.13 print output by including a space in the sign
position of floats and different behavior for 0d arrays. If set to
<cite>False</cite>, disables legacy mode. Unrecognized strings will be ignored
with a warning for forward compatibility.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.14.0.</span></p>
</div>
</dd>
</dl>
<p>get_printoptions, printoptions, set_string_function, array2string</p>
<p><cite>formatter</cite> is always reset with a call to <cite>set_printoptions</cite>.</p>
<p>Use <cite>printoptions</cite> as a context manager to set the values temporarily.</p>
<p>Floating point precision can be set:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.123456789</span><span class="p">])</span>
<span class="go">[1.1235]</span>
</pre></div>
</div>
<p>Long arrays can be summarised:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">array([0, 1, 2, ..., 7, 8, 9])</span>
</pre></div>
</div>
<p>Small results can be suppressed:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">4.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="go">array([-4.9304e-32, -4.4409e-16,  0.0000e+00,  0.0000e+00])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">suppress</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="go">array([-0., -0.,  0.,  0.])</span>
</pre></div>
</div>
<p>A custom formatter can be used to display array elements as desired:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;all&#39;</span><span class="p">:</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s1">&#39;int: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([int: 0, int: -1, int: -2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">()</span>  <span class="c1"># formatter gets reset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([0, 1, 2])</span>
</pre></div>
</div>
<p>To put back the default options, you can use:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">edgeitems</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">infstr</span><span class="o">=</span><span class="s1">&#39;inf&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="n">linewidth</span><span class="o">=</span><span class="mi">75</span><span class="p">,</span> <span class="n">nanstr</span><span class="o">=</span><span class="s1">&#39;nan&#39;</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
<span class="gp">... </span><span class="n">suppress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">formatter</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
<p>Also to temporarily override options, use <cite>printoptions</cite> as a context manager:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">suppress</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="go">array([ 0.  ,  1.11,  2.22, ...,  7.78,  8.89, 10.  ])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.set_string_function">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">set_string_function</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.set_string_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a Python function to be used when pretty printing arrays.</p>
<dl class="simple">
<dt>f<span class="classifier">function or None</span></dt><dd><p>Function to be used to pretty print arrays. The function should expect
a single array argument and return a string of the representation of
the array. If None, the function is reset to the default NumPy function
to print arrays.</p>
</dd>
<dt>repr<span class="classifier">bool, optional</span></dt><dd><p>If True (default), the function for pretty printing (<code class="docutils literal notranslate"><span class="pre">__repr__</span></code>)
is set, if False the function that returns the default string
representation (<code class="docutils literal notranslate"><span class="pre">__str__</span></code>) is set.</p>
</dd>
</dl>
<p>set_printoptions, get_printoptions</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">pprint</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="s1">&#39;HA! - What are you going to do now?&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">set_string_function</span><span class="p">(</span><span class="n">pprint</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">HA! - What are you going to do now?</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># [0 1 2 3 4 5 6 7 8 9]</span>
</pre></div>
</div>
<p>We can reset the function to the default:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">set_string_function</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
</pre></div>
</div>
<p><cite>repr</cite> affects either pretty printing or normal string representation.
Note that <code class="docutils literal notranslate"><span class="pre">__repr__</span></code> is still affected by setting <code class="docutils literal notranslate"><span class="pre">__str__</span></code>
because the width of each array element in the returned string becomes
equal to the length of the result of <code class="docutils literal notranslate"><span class="pre">__str__()</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">set_string_function</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="s1">&#39;random&#39;</span><span class="p">,</span> <span class="nb">repr</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>
<span class="go">&#39;random&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
<span class="go">&#39;array([0, 1, 2, 3])&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.setbufsize">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">setbufsize</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.setbufsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the size of the buffer used in ufuncs.</p>
<dl class="simple">
<dt>size<span class="classifier">int</span></dt><dd><p>Size of buffer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="numpy.setdiff1d">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">setdiff1d</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ar1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ar2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">assume_unique</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.setdiff1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the set difference of two arrays.</p>
<p>Return the unique values in <cite>ar1</cite> that are not in <cite>ar2</cite>.</p>
<dl class="simple">
<dt>ar1<span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt>ar2<span class="classifier">array_like</span></dt><dd><p>Input comparison array.</p>
</dd>
<dt>assume_unique<span class="classifier">bool</span></dt><dd><p>If True, the input arrays are both assumed to be unique, which
can speed up the calculation.  Default is False.</p>
</dd>
</dl>
<dl class="simple">
<dt>setdiff1d<span class="classifier">ndarray</span></dt><dd><p>1D array of values in <cite>ar1</cite> that are not in <cite>ar2</cite>. The result
is sorted when <cite>assume_unique=False</cite>, but otherwise only sorted
if the input is sorted.</p>
</dd>
</dl>
<dl class="simple">
<dt>numpy.lib.arraysetops<span class="classifier">Module with a number of other functions for</span></dt><dd><p>performing set operations on arrays.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([1, 2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.seterr">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">seterr</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">divide</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">over</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">under</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invalid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.seterr" title="Permalink to this definition">¶</a></dt>
<dd><p>Set how floating-point errors are handled.</p>
<p>Note that operations on integer scalar types (such as <cite>int16</cite>) are
handled like floating point, and are affected by these settings.</p>
<dl>
<dt>all<span class="classifier">{‘ignore’, ‘warn’, ‘raise’, ‘call’, ‘print’, ‘log’}, optional</span></dt><dd><p>Set treatment for all types of floating-point errors at once:</p>
<ul class="simple">
<li><p>ignore: Take no action when the exception occurs.</p></li>
<li><p>warn: Print a <cite>RuntimeWarning</cite> (via the Python <cite>warnings</cite> module).</p></li>
<li><p>raise: Raise a <cite>FloatingPointError</cite>.</p></li>
<li><p>call: Call a function specified using the <cite>seterrcall</cite> function.</p></li>
<li><p>print: Print a warning directly to <code class="docutils literal notranslate"><span class="pre">stdout</span></code>.</p></li>
<li><p>log: Record error in a Log object specified by <cite>seterrcall</cite>.</p></li>
</ul>
<p>The default is not to change the current behavior.</p>
</dd>
<dt>divide<span class="classifier">{‘ignore’, ‘warn’, ‘raise’, ‘call’, ‘print’, ‘log’}, optional</span></dt><dd><p>Treatment for division by zero.</p>
</dd>
<dt>over<span class="classifier">{‘ignore’, ‘warn’, ‘raise’, ‘call’, ‘print’, ‘log’}, optional</span></dt><dd><p>Treatment for floating-point overflow.</p>
</dd>
<dt>under<span class="classifier">{‘ignore’, ‘warn’, ‘raise’, ‘call’, ‘print’, ‘log’}, optional</span></dt><dd><p>Treatment for floating-point underflow.</p>
</dd>
<dt>invalid<span class="classifier">{‘ignore’, ‘warn’, ‘raise’, ‘call’, ‘print’, ‘log’}, optional</span></dt><dd><p>Treatment for invalid floating-point operation.</p>
</dd>
</dl>
<dl class="simple">
<dt>old_settings<span class="classifier">dict</span></dt><dd><p>Dictionary containing the old settings.</p>
</dd>
</dl>
<p>seterrcall : Set a callback function for the ‘call’ mode.
geterr, geterrcall, errstate</p>
<p>The floating-point exceptions are defined in the IEEE 754 standard <a href="#id94"><span class="problematic" id="id61">[1]_</span></a>:</p>
<ul class="simple">
<li><p>Division by zero: infinite result obtained from finite numbers.</p></li>
<li><p>Overflow: result too large to be expressed.</p></li>
<li><p>Underflow: result so close to zero that some precision
was lost.</p></li>
<li><p>Invalid operation: result is not an expressible number, typically
indicates that a NaN was produced.</p></li>
</ul>
<dl class="footnote brackets">
<dt class="label" id="id62"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/IEEE_754">https://en.wikipedia.org/wiki/IEEE_754</a></p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">old_settings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>  <span class="c1">#seterr to known value</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="n">over</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">)</span>
<span class="go">{&#39;divide&#39;: &#39;ignore&#39;, &#39;over&#39;: &#39;ignore&#39;, &#39;under&#39;: &#39;ignore&#39;, &#39;invalid&#39;: &#39;ignore&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="o">**</span><span class="n">old_settings</span><span class="p">)</span>  <span class="c1"># reset to default</span>
<span class="go">{&#39;divide&#39;: &#39;ignore&#39;, &#39;over&#39;: &#39;raise&#39;, &#39;under&#39;: &#39;ignore&#39;, &#39;invalid&#39;: &#39;ignore&#39;}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">(</span><span class="mi">32000</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">30464</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">old_settings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;warn&#39;</span><span class="p">,</span> <span class="n">over</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">(</span><span class="mi">32000</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">FloatingPointError</span>: <span class="n">overflow encountered in short_scalars</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">old_settings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;print&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geterr</span><span class="p">()</span>
<span class="go">{&#39;divide&#39;: &#39;print&#39;, &#39;over&#39;: &#39;print&#39;, &#39;under&#39;: &#39;print&#39;, &#39;invalid&#39;: &#39;print&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">(</span><span class="mi">32000</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">30464</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.seterrcall">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">seterrcall</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.seterrcall" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the floating-point error callback function or log object.</p>
<p>There are two ways to capture floating-point error messages.  The first
is to set the error-handler to ‘call’, using <cite>seterr</cite>.  Then, set
the function to call using this function.</p>
<p>The second is to set the error-handler to ‘log’, using <cite>seterr</cite>.
Floating-point errors then trigger a call to the ‘write’ method of
the provided object.</p>
<dl>
<dt>func<span class="classifier">callable f(err, flag) or object with write method</span></dt><dd><p>Function to call upon floating-point errors (‘call’-mode) or
object whose ‘write’ method is used to log such message (‘log’-mode).</p>
<p>The call function takes two arguments. The first is a string describing
the type of error (such as “divide by zero”, “overflow”, “underflow”,
or “invalid value”), and the second is the status flag.  The flag is a
byte, whose four least-significant bits indicate the type of error, one
of “divide”, “over”, “under”, “invalid”:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="n">divide</span> <span class="n">over</span> <span class="n">under</span> <span class="n">invalid</span><span class="p">]</span>
</pre></div>
</div>
<p>In other words, <code class="docutils literal notranslate"><span class="pre">flags</span> <span class="pre">=</span> <span class="pre">divide</span> <span class="pre">+</span> <span class="pre">2*over</span> <span class="pre">+</span> <span class="pre">4*under</span> <span class="pre">+</span> <span class="pre">8*invalid</span></code>.</p>
<p>If an object is provided, its write method should take one argument,
a string.</p>
</dd>
</dl>
<dl class="simple">
<dt>h<span class="classifier">callable, log instance or None</span></dt><dd><p>The old error handler.</p>
</dd>
</dl>
<p>seterr, geterr, geterrcall</p>
<p>Callback upon error:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">err_handler</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">flag</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Floating point error (</span><span class="si">%s</span><span class="s2">), with flag </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">flag</span><span class="p">))</span>
<span class="gp">...</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">saved_handler</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterrcall</span><span class="p">(</span><span class="n">err_handler</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">save_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;call&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="mf">0.0</span>
<span class="go">Floating point error (divide by zero), with flag 1</span>
<span class="go">array([inf, inf, inf])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">seterrcall</span><span class="p">(</span><span class="n">saved_handler</span><span class="p">)</span>
<span class="go">&lt;function err_handler at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="o">**</span><span class="n">save_err</span><span class="p">)</span>
<span class="go">{&#39;divide&#39;: &#39;call&#39;, &#39;over&#39;: &#39;call&#39;, &#39;under&#39;: &#39;call&#39;, &#39;invalid&#39;: &#39;call&#39;}</span>
</pre></div>
</div>
<p>Log error message:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Log</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;LOG: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">msg</span><span class="p">)</span>
<span class="gp">...</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">log</span> <span class="o">=</span> <span class="n">Log</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">saved_handler</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterrcall</span><span class="p">(</span><span class="n">log</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">save_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="mf">0.0</span>
<span class="go">LOG: Warning: divide by zero encountered in true_divide</span>
<span class="go">array([inf, inf, inf])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">seterrcall</span><span class="p">(</span><span class="n">saved_handler</span><span class="p">)</span>
<span class="go">&lt;numpy.core.numeric.Log object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="o">**</span><span class="n">save_err</span><span class="p">)</span>
<span class="go">{&#39;divide&#39;: &#39;log&#39;, &#39;over&#39;: &#39;log&#39;, &#39;under&#39;: &#39;log&#39;, &#39;invalid&#39;: &#39;log&#39;}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.seterrobj">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">seterrobj</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">errobj</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.seterrobj" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the object that defines floating-point error handling.</p>
<p>The error object contains all information that defines the error handling
behavior in NumPy. <cite>seterrobj</cite> is used internally by the other
functions that set error handling behavior (<cite>seterr</cite>, <cite>seterrcall</cite>).</p>
<dl>
<dt>errobj<span class="classifier">list</span></dt><dd><p>The error object, a list containing three elements:
[internal numpy buffer size, error mask, error callback function].</p>
<p>The error mask is a single integer that holds the treatment information
on all four floating point errors. The information for each error type
is contained in three bits of the integer. If we print it in base 8, we
can see what treatment is set for “invalid”, “under”, “over”, and
“divide” (in that order). The printed string can be interpreted with</p>
<ul class="simple">
<li><p>0 : ‘ignore’</p></li>
<li><p>1 : ‘warn’</p></li>
<li><p>2 : ‘raise’</p></li>
<li><p>3 : ‘call’</p></li>
<li><p>4 : ‘print’</p></li>
<li><p>5 : ‘log’</p></li>
</ul>
</dd>
</dl>
<p>geterrobj, seterr, geterr, seterrcall, geterrcall
getbufsize, setbufsize</p>
<p>For complete documentation of the types of floating-point exceptions and
treatment options, see <cite>seterr</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">old_errobj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">geterrobj</span><span class="p">()</span>  <span class="c1"># first get the defaults</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">old_errobj</span>
<span class="go">[8192, 521, None]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">err_handler</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">flag</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Floating point error (</span><span class="si">%s</span><span class="s2">), with flag </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">flag</span><span class="p">))</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_errobj</span> <span class="o">=</span> <span class="p">[</span><span class="mi">20000</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="n">err_handler</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">seterrobj</span><span class="p">(</span><span class="n">new_errobj</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">base_repr</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>  <span class="c1"># int for divide=4 (&#39;print&#39;) and over=1 (&#39;warn&#39;)</span>
<span class="go">&#39;14&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geterr</span><span class="p">()</span>
<span class="go">{&#39;over&#39;: &#39;warn&#39;, &#39;divide&#39;: &#39;print&#39;, &#39;invalid&#39;: &#39;ignore&#39;, &#39;under&#39;: &#39;ignore&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geterrcall</span><span class="p">()</span> <span class="ow">is</span> <span class="n">err_handler</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.setxor1d">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">setxor1d</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ar1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ar2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">assume_unique</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.setxor1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the set exclusive-or of two arrays.</p>
<p>Return the sorted, unique values that are in only one (not both) of the
input arrays.</p>
<dl class="simple">
<dt>ar1, ar2<span class="classifier">array_like</span></dt><dd><p>Input arrays.</p>
</dd>
<dt>assume_unique<span class="classifier">bool</span></dt><dd><p>If True, the input arrays are both assumed to be unique, which
can speed up the calculation.  Default is False.</p>
</dd>
</dl>
<dl class="simple">
<dt>setxor1d<span class="classifier">ndarray</span></dt><dd><p>Sorted 1D array of unique values that are in only one of the input
arrays.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">setxor1d</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="go">array([1, 4, 5, 7])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.shape">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">shape</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the shape of an array.</p>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
</dl>
<dl class="simple">
<dt>shape<span class="classifier">tuple of ints</span></dt><dd><p>The elements of the shape tuple give the lengths of the
corresponding array dimensions.</p>
</dd>
</dl>
<p>len
ndarray.shape : Equivalent array method.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">(3, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="go">(1, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="go">(1,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">()</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;i4&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;i4&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">(2,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2,)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.shares_memory">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">shares_memory</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_work</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.shares_memory" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if two arrays share memory.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This function can be exponentially slow for some inputs, unless
<cite>max_work</cite> is set to a finite number or <code class="docutils literal notranslate"><span class="pre">MAY_SHARE_BOUNDS</span></code>.
If in doubt, use <cite>numpy.may_share_memory</cite> instead.</p>
</div>
<dl>
<dt>a, b<span class="classifier">ndarray</span></dt><dd><p>Input arrays</p>
</dd>
<dt>max_work<span class="classifier">int, optional</span></dt><dd><p>Effort to spend on solving the overlap problem (maximum number
of candidate solutions to consider). The following special
values are recognized:</p>
<dl class="simple">
<dt>max_work=MAY_SHARE_EXACT  (default)</dt><dd><p>The problem is solved exactly. In this case, the function returns
True only if there is an element shared between the arrays. Finding
the exact solution may take extremely long in some cases.</p>
</dd>
<dt>max_work=MAY_SHARE_BOUNDS</dt><dd><p>Only the memory bounds of a and b are checked.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="simple">
<dt>numpy.TooHardError</dt><dd><p>Exceeded max_work.</p>
</dd>
</dl>
<p>out : bool</p>
<p>may_share_memory</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">shares_memory</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]))</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">shares_memory</span><span class="p">(</span><span class="n">x</span><span class="p">[::</span><span class="mi">2</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">shares_memory</span><span class="p">(</span><span class="n">x</span><span class="p">[::</span><span class="mi">2</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Checking whether two arrays share memory is NP-complete, and
runtime may increase exponentially in the number of
dimensions. Hence, <cite>max_work</cite> should generally be set to a finite
number, as it is possible to construct examples that take
extremely long to run:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy.lib.stride_tricks</span> <span class="kn">import</span> <span class="n">as_strided</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">192163377</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span> <span class="o">=</span> <span class="n">as_strided</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="p">(</span><span class="mi">36674</span><span class="p">,</span> <span class="mi">61119</span><span class="p">,</span> <span class="mi">85569</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1049</span><span class="p">,</span> <span class="mi">1049</span><span class="p">,</span> <span class="mi">1049</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="n">as_strided</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">64023025</span><span class="p">:],</span> <span class="n">strides</span><span class="o">=</span><span class="p">(</span><span class="mi">12223</span><span class="p">,</span> <span class="mi">12224</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1049</span><span class="p">,</span> <span class="mi">1049</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">shares_memory</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">max_work</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">numpy.TooHardError</span>: <span class="n">Exceeded max_work</span>
</pre></div>
</div>
<p>Running <code class="docutils literal notranslate"><span class="pre">np.shares_memory(x1,</span> <span class="pre">x2)</span></code> without <cite>max_work</cite> set takes
around 1 minute for this case. It is possible to find problems
that take still significantly longer.</p>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.short">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">short</span></code><a class="headerlink" href="#numpy.short" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.int16" title="numpy.int16"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.int16</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="numpy.show_config">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">show_config</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.show_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Show libraries in the system on which NumPy was built.</p>
<p>Print information about various resources (libraries, library
directories, include directories, etc.) in the system on which
NumPy was built.</p>
<dl class="simple">
<dt>get_include<span class="classifier">Returns the directory containing NumPy C</span></dt><dd><p>header files.</p>
</dd>
</dl>
<p>Classes specifying the information to be printed are defined
in the <cite>numpy.distutils.system_info</cite> module.</p>
<p>Information may include:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">language</span></code>: language used to write the libraries (mostly
C or f77)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">libraries</span></code>: names of libraries found in the system</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">library_dirs</span></code>: directories containing the libraries</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">include_dirs</span></code>: directories containing library header files</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">src_dirs</span></code>: directories containing library source files</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">define_macros</span></code>: preprocessor macros used by
<code class="docutils literal notranslate"><span class="pre">distutils.setup</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">baseline</span></code>: minimum CPU features required</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">found</span></code>: dispatched features supported in the system</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">found</span></code>: dispatched features that are not supported
in the system</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">show_config</span><span class="p">()</span>
<span class="go">blas_opt_info:</span>
<span class="go">    language = c</span>
<span class="go">    define_macros = [(&#39;HAVE_CBLAS&#39;, None)]</span>
<span class="go">    libraries = [&#39;openblas&#39;, &#39;openblas&#39;]</span>
<span class="go">    library_dirs = [&#39;/usr/local/lib&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt id="numpy.signedinteger">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">signedinteger</span></code><a class="headerlink" href="#numpy.signedinteger" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class of all signed integer scalar types.</p>
</dd></dl>

<dl class="py function">
<dt id="numpy.sinc">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">sinc</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.sinc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the normalized sinc function.</p>
<p>The sinc function is <span class="math notranslate nohighlight">\(\sin(\pi x)/(\pi x)\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Note the normalization factor of <code class="docutils literal notranslate"><span class="pre">pi</span></code> used in the definition.
This is the most commonly used definition in signal processing.
Use <code class="docutils literal notranslate"><span class="pre">sinc(x</span> <span class="pre">/</span> <span class="pre">np.pi)</span></code> to obtain the unnormalized sinc function
<span class="math notranslate nohighlight">\(\sin(x)/(x)\)</span> that is more common in mathematics.</p>
</div>
<dl class="simple">
<dt>x<span class="classifier">ndarray</span></dt><dd><p>Array (possibly multi-dimensional) of values for which to to
calculate <code class="docutils literal notranslate"><span class="pre">sinc(x)</span></code>.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">sinc(x)</span></code>, which has the same shape as the input.</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">sinc(0)</span></code> is the limit value 1.</p>
<p>The name sinc is short for “sine cardinal” or “sinus cardinalis”.</p>
<p>The sinc function is used in various signal processing applications,
including in anti-aliasing, in the construction of a Lanczos resampling
filter, and in interpolation.</p>
<p>For bandlimited interpolation of discrete-time signals, the ideal
interpolation kernel is proportional to the sinc function.</p>
<dl class="footnote brackets">
<dt class="label" id="id63"><span class="brackets">1</span></dt>
<dd><p>Weisstein, Eric W. “Sinc Function.” From MathWorld–A Wolfram Web
Resource. <a class="reference external" href="http://mathworld.wolfram.com/SincFunction.html">http://mathworld.wolfram.com/SincFunction.html</a></p>
</dd>
<dt class="label" id="id64"><span class="brackets">2</span></dt>
<dd><p>Wikipedia, “Sinc function”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Sinc_function">https://en.wikipedia.org/wiki/Sinc_function</a></p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">41</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go"> array([-3.89804309e-17,  -4.92362781e-02,  -8.40918587e-02, # may vary</span>
<span class="go">        -8.90384387e-02,  -5.84680802e-02,   3.89804309e-17,</span>
<span class="go">        6.68206631e-02,   1.16434881e-01,   1.26137788e-01,</span>
<span class="go">        8.50444803e-02,  -3.89804309e-17,  -1.03943254e-01,</span>
<span class="go">        -1.89206682e-01,  -2.16236208e-01,  -1.55914881e-01,</span>
<span class="go">        3.89804309e-17,   2.33872321e-01,   5.04551152e-01,</span>
<span class="go">        7.56826729e-01,   9.35489284e-01,   1.00000000e+00,</span>
<span class="go">        9.35489284e-01,   7.56826729e-01,   5.04551152e-01,</span>
<span class="go">        2.33872321e-01,   3.89804309e-17,  -1.55914881e-01,</span>
<span class="go">       -2.16236208e-01,  -1.89206682e-01,  -1.03943254e-01,</span>
<span class="go">       -3.89804309e-17,   8.50444803e-02,   1.26137788e-01,</span>
<span class="go">        1.16434881e-01,   6.68206631e-02,   3.89804309e-17,</span>
<span class="go">        -5.84680802e-02,  -8.90384387e-02,  -8.40918587e-02,</span>
<span class="go">        -4.92362781e-02,  -3.89804309e-17])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Sinc Function&quot;</span><span class="p">)</span>
<span class="go">Text(0.5, 1.0, &#39;Sinc Function&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Amplitude&quot;</span><span class="p">)</span>
<span class="go">Text(0, 0.5, &#39;Amplitude&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">)</span>
<span class="go">Text(0.5, 0, &#39;X&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.single">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">single</span></code><a class="headerlink" href="#numpy.single" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.float32" title="numpy.float32"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.float32</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.singlecomplex">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">singlecomplex</span></code><a class="headerlink" href="#numpy.singlecomplex" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.complex64" title="numpy.complex64"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.complex64</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="numpy.size">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">size</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of elements along a given axis.</p>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input data.</p>
</dd>
<dt>axis<span class="classifier">int, optional</span></dt><dd><p>Axis along which the elements are counted.  By default, give
the total number of elements.</p>
</dd>
</dl>
<dl class="simple">
<dt>element_count<span class="classifier">int</span></dt><dd><p>Number of elements along the specified axis.</p>
</dd>
</dl>
<p>shape : dimensions of array
ndarray.shape : dimensions of array
ndarray.size : number of elements in array</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.sometrue">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">sometrue</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.sometrue" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether some values are true.</p>
<p>Refer to <cite>any</cite> for full documentation.</p>
<p>any : equivalent function; see for details.</p>
</dd></dl>

<dl class="py function">
<dt id="numpy.sort">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">sort</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a sorted copy of an array.</p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Array to be sorted.</p>
</dd>
<dt>axis<span class="classifier">int or None, optional</span></dt><dd><p>Axis along which to sort. If None, the array is flattened before
sorting. The default is -1, which sorts along the last axis.</p>
</dd>
<dt>kind<span class="classifier">{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional</span></dt><dd><p>Sorting algorithm. The default is ‘quicksort’. Note that both ‘stable’
and ‘mergesort’ use timsort or radix sort under the covers and, in general,
the actual implementation will vary with data type. The ‘mergesort’ option
is retained for backwards compatibility.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.15.0.: </span>The ‘stable’ option was added.</p>
</div>
</dd>
<dt>order<span class="classifier">str or list of str, optional</span></dt><dd><p>When <cite>a</cite> is an array with fields defined, this argument specifies
which fields to compare first, second, etc.  A single field can
be specified as a string, and not all fields need be specified,
but unspecified fields will still be used, in the order in which
they come up in the dtype, to break ties.</p>
</dd>
</dl>
<dl class="simple">
<dt>sorted_array<span class="classifier">ndarray</span></dt><dd><p>Array of the same type and shape as <cite>a</cite>.</p>
</dd>
</dl>
<p>ndarray.sort : Method to sort an array in-place.
argsort : Indirect sort.
lexsort : Indirect stable sort on multiple keys.
searchsorted : Find elements in a sorted array.
partition : Partial sort.</p>
<p>The various sorting algorithms are characterized by their average speed,
worst case performance, work space size, and whether they are stable. A
stable sort keeps items with the same key in the same relative
order. The four algorithms implemented in NumPy have the following
properties:</p>
<table class="table">
<colgroup>
<col style="width: 22%" />
<col style="width: 14%" />
<col style="width: 25%" />
<col style="width: 24%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>kind</p></th>
<th class="head"><p>speed</p></th>
<th class="head"><p>worst case</p></th>
<th class="head"><p>work space</p></th>
<th class="head"><p>stable</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>‘quicksort’</p></td>
<td><p>1</p></td>
<td><p>O(n^2)</p></td>
<td><p>0</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-odd"><td><p>‘heapsort’</p></td>
<td><p>3</p></td>
<td><p>O(n*log(n))</p></td>
<td><p>0</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-even"><td><p>‘mergesort’</p></td>
<td><p>2</p></td>
<td><p>O(n*log(n))</p></td>
<td><p>~n/2</p></td>
<td><p>yes</p></td>
</tr>
<tr class="row-odd"><td><p>‘timsort’</p></td>
<td><p>2</p></td>
<td><p>O(n*log(n))</p></td>
<td><p>~n/2</p></td>
<td><p>yes</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The datatype determines which of ‘mergesort’ or ‘timsort’
is actually used, even if ‘mergesort’ is specified. User selection
at a finer scale is not currently available.</p>
</div>
<p>All the sort algorithms make temporary copies of the data when
sorting along any but the last axis.  Consequently, sorting along
the last axis is faster and uses less space than sorting along
any other axis.</p>
<p>The sort order for complex numbers is lexicographic. If both the real
and imaginary parts are non-nan then the order is determined by the
real parts except when they are equal, in which case the order is
determined by the imaginary parts.</p>
<p>Previous to numpy 1.4.0 sorting real and complex arrays containing nan
values led to undefined behaviour. In numpy versions &gt;= 1.4.0 nan
values are sorted to the end. The extended sort order is:</p>
<blockquote>
<div><ul class="simple">
<li><p>Real: [R, nan]</p></li>
<li><p>Complex: [R + Rj, R + nanj, nan + Rj, nan + nanj]</p></li>
</ul>
</div></blockquote>
<p>where R is a non-nan real value. Complex values with the same nan
placements are sorted according to the non-nan part if it exists.
Non-nan values are sorted as before.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.12.0.</span></p>
</div>
<p>quicksort has been changed to <a class="reference external" href="https://en.wikipedia.org/wiki/Introsort">introsort</a>.
When sorting does not make enough progress it switches to
<a class="reference external" href="https://en.wikipedia.org/wiki/Heapsort">heapsort</a>.
This implementation makes quicksort O(n*log(n)) in the worst case.</p>
<p>‘stable’ automatically chooses the best stable sorting algorithm
for the data type being sorted.
It, along with ‘mergesort’ is currently mapped to
<a class="reference external" href="https://en.wikipedia.org/wiki/Timsort">timsort</a>
or <a class="reference external" href="https://en.wikipedia.org/wiki/Radix_sort">radix sort</a>
depending on the data type.
API forward compatibility currently limits the
ability to select the implementation and it is hardwired for the different
data types.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.17.0.</span></p>
</div>
<p>Timsort is added for better performance on already or nearly
sorted data. On random data timsort is almost identical to
mergesort. It is now used for stable sort while quicksort is still the
default sort if none is chosen. For timsort details, refer to
<a class="reference external" href="https://github.com/python/cpython/blob/3.7/Objects/listsort.txt">CPython listsort.txt</a>.
‘mergesort’ and ‘stable’ are mapped to radix sort for integer data types. Radix sort is an
O(n) sort instead of O(n log n).</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.18.0.</span></p>
</div>
<p>NaT now sorts to the end of arrays for consistency with NaN.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>                <span class="c1"># sort along the last axis</span>
<span class="go">array([[1, 4],</span>
<span class="go">       [1, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>     <span class="c1"># sort the flattened array</span>
<span class="go">array([1, 1, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>        <span class="c1"># sort along the first axis</span>
<span class="go">array([[1, 1],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
<p>Use the <cite>order</cite> keyword to specify a field to use when sorting a
structured array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dtype</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;S10&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;Arthur&#39;</span><span class="p">,</span> <span class="mf">1.8</span><span class="p">,</span> <span class="mi">41</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Lancelot&#39;</span><span class="p">,</span> <span class="mf">1.9</span><span class="p">,</span> <span class="mi">38</span><span class="p">),</span>
<span class="gp">... </span>          <span class="p">(</span><span class="s1">&#39;Galahad&#39;</span><span class="p">,</span> <span class="mf">1.7</span><span class="p">,</span> <span class="mi">38</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>       <span class="c1"># create a structured array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;height&#39;</span><span class="p">)</span>                        
<span class="go">array([(&#39;Galahad&#39;, 1.7, 38), (&#39;Arthur&#39;, 1.8, 41),</span>
<span class="go">       (&#39;Lancelot&#39;, 1.8999999999999999, 38)],</span>
<span class="go">      dtype=[(&#39;name&#39;, &#39;|S10&#39;), (&#39;height&#39;, &#39;&lt;f8&#39;), (&#39;age&#39;, &#39;&lt;i4&#39;)])</span>
</pre></div>
</div>
<p>Sort by age, then height if ages are equal:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="s1">&#39;height&#39;</span><span class="p">])</span>               
<span class="go">array([(&#39;Galahad&#39;, 1.7, 38), (&#39;Lancelot&#39;, 1.8999999999999999, 38),</span>
<span class="go">       (&#39;Arthur&#39;, 1.8, 41)],</span>
<span class="go">      dtype=[(&#39;name&#39;, &#39;|S10&#39;), (&#39;height&#39;, &#39;&lt;f8&#39;), (&#39;age&#39;, &#39;&lt;i4&#39;)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.sort_complex">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">sort_complex</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.sort_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort a complex array using the real part first, then the imaginary part.</p>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input array</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">complex ndarray</span></dt><dd><p>Always returns a sorted complex array.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sort_complex</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">array([1.+0.j, 2.+0.j, 3.+0.j, 5.+0.j, 6.+0.j])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sort_complex</span><span class="p">([</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span> <span class="o">-</span> <span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span> <span class="o">-</span> <span class="mi">3</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">5</span><span class="n">j</span><span class="p">])</span>
<span class="go">array([1.+2.j,  2.-1.j,  3.-3.j,  3.-2.j,  3.+5.j])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.source">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">source</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">object</span></em>, <em class="sig-param"><span class="pre">output=&lt;_io.TextIOWrapper</span> <span class="pre">name='&lt;stdout&gt;'</span> <span class="pre">mode='w'</span> <span class="pre">encoding='utf-8'&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.source" title="Permalink to this definition">¶</a></dt>
<dd><p>Print or write to a file the source code for a NumPy object.</p>
<p>The source code is only returned for objects written in Python. Many
functions and classes are defined in C and will therefore not return
useful information.</p>
<dl class="simple">
<dt>object<span class="classifier">numpy object</span></dt><dd><p>Input object. This can be any object (function, class, module,
…).</p>
</dd>
<dt>output<span class="classifier">file object, optional</span></dt><dd><p>If <cite>output</cite> not supplied then source code is printed to screen
(sys.stdout).  File object must be created with either write ‘w’ or
append ‘a’ modes.</p>
</dd>
</dl>
<p>lookfor, info</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">source</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">)</span>                        
<span class="go">In file: /usr/lib/python2.6/dist-packages/numpy/lib/function_base.py</span>
<span class="go">def interp(x, xp, fp, left=None, right=None):</span>
<span class="go">    &quot;&quot;&quot;.... (full docstring printed)&quot;&quot;&quot;</span>
<span class="go">    if isinstance(x, (float, int, number)):</span>
<span class="go">        return compiled_interp([x], xp, fp, left, right).item()</span>
<span class="go">    else:</span>
<span class="go">        return compiled_interp(x, xp, fp, left, right)</span>
</pre></div>
</div>
<p>The source code is only returned for objects written in Python.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">source</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>                         
<span class="go">Not available for this object.</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.split">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">split</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ary</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices_or_sections</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Split an array into multiple sub-arrays as views into <cite>ary</cite>.</p>
<dl>
<dt>ary<span class="classifier">ndarray</span></dt><dd><p>Array to be divided into sub-arrays.</p>
</dd>
<dt>indices_or_sections<span class="classifier">int or 1-D array</span></dt><dd><p>If <cite>indices_or_sections</cite> is an integer, N, the array will be divided
into N equal arrays along <cite>axis</cite>.  If such a split is not possible,
an error is raised.</p>
<p>If <cite>indices_or_sections</cite> is a 1-D array of sorted integers, the entries
indicate where along <cite>axis</cite> the array is split.  For example,
<code class="docutils literal notranslate"><span class="pre">[2,</span> <span class="pre">3]</span></code> would, for <code class="docutils literal notranslate"><span class="pre">axis=0</span></code>, result in</p>
<blockquote>
<div><ul class="simple">
<li><p>ary[:2]</p></li>
<li><p>ary[2:3]</p></li>
<li><p>ary[3:]</p></li>
</ul>
</div></blockquote>
<p>If an index exceeds the dimension of the array along <cite>axis</cite>,
an empty sub-array is returned correspondingly.</p>
</dd>
<dt>axis<span class="classifier">int, optional</span></dt><dd><p>The axis along which to split, default is 0.</p>
</dd>
</dl>
<dl class="simple">
<dt>sub-arrays<span class="classifier">list of ndarrays</span></dt><dd><p>A list of sub-arrays as views into <cite>ary</cite>.</p>
</dd>
</dl>
<dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>indices_or_sections</cite> is given as an integer, but
a split does not result in equal division.</p>
</dd>
</dl>
<dl class="simple">
<dt>array_split<span class="classifier">Split an array into multiple sub-arrays of equal or</span></dt><dd><p>near-equal size.  Does not raise an exception if
an equal division cannot be made.</p>
</dd>
</dl>
<p>hsplit : Split array into multiple sub-arrays horizontally (column-wise).
vsplit : Split array into multiple sub-arrays vertically (row wise).
dsplit : Split array into multiple sub-arrays along the 3rd axis (depth).
concatenate : Join a sequence of arrays along an existing axis.
stack : Join a sequence of arrays along a new axis.
hstack : Stack arrays in sequence horizontally (column wise).
vstack : Stack arrays in sequence vertically (row wise).
dstack : Stack arrays in sequence depth wise (along third dimension).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">9.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[array([0.,  1.,  2.]), array([3.,  4.,  5.]), array([6.,  7.,  8.])]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">8.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="go">[array([0.,  1.,  2.]),</span>
<span class="go"> array([3.,  4.]),</span>
<span class="go"> array([5.]),</span>
<span class="go"> array([6.,  7.]),</span>
<span class="go"> array([], dtype=float64)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.squeeze">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">squeeze</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove axes of length one from <cite>a</cite>.</p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input data.</p>
</dd>
<dt>axis<span class="classifier">None or int or tuple of ints, optional</span></dt><dd><div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<p>Selects a subset of the entries of length one in the
shape. If an axis is selected with shape entry greater than
one, an error is raised.</p>
</dd>
</dl>
<dl class="simple">
<dt>squeezed<span class="classifier">ndarray</span></dt><dd><p>The input array, but with all or a subset of the
dimensions of length 1 removed. This is always <cite>a</cite> itself
or a view into <cite>a</cite>. Note that if all axes are squeezed,
the result is a 0d array and not a scalar.</p>
</dd>
</dl>
<dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>axis</cite> is not None, and an axis being squeezed is not of length 1</p>
</dd>
</dl>
<p>expand_dims : The inverse operation, adding entries of length one
reshape : Insert, remove, and combine dimensions, and resize existing ones</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 3, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">cannot select an axis to squeeze out which has size not equal to one</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1234</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array(1234)  # 0d array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">x</span><span class="p">)[()]</span>
<span class="go">1234</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.stack">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">stack</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arrays</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.stack" title="Permalink to this definition">¶</a></dt>
<dd><p>Join a sequence of arrays along a new axis.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">axis</span></code> parameter specifies the index of the new axis in the
dimensions of the result. For example, if <code class="docutils literal notranslate"><span class="pre">axis=0</span></code> it will be the first
dimension and if <code class="docutils literal notranslate"><span class="pre">axis=-1</span></code> it will be the last dimension.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.0.</span></p>
</div>
<dl class="simple">
<dt>arrays<span class="classifier">sequence of array_like</span></dt><dd><p>Each array must have the same shape.</p>
</dd>
<dt>axis<span class="classifier">int, optional</span></dt><dd><p>The axis in the result array along which the input arrays are stacked.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>If provided, the destination to place the result. The shape must be
correct, matching that of what stack would have returned if no
out argument were specified.</p>
</dd>
</dl>
<dl class="simple">
<dt>stacked<span class="classifier">ndarray</span></dt><dd><p>The stacked array has one more dimension than the input arrays.</p>
</dd>
</dl>
<p>concatenate : Join a sequence of arrays along an existing axis.
block : Assemble an nd-array from nested lists of blocks.
split : Split array into a list of multiple sub-arrays of equal size.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(10, 3, 4)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 10, 4)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 4, 10)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [4, 5, 6]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[1, 4],</span>
<span class="go">       [2, 5],</span>
<span class="go">       [3, 6]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.std">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">std</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">a</span></em>, <em class="sig-param"><span class="pre">axis=None</span></em>, <em class="sig-param"><span class="pre">dtype=None</span></em>, <em class="sig-param"><span class="pre">out=None</span></em>, <em class="sig-param"><span class="pre">ddof=0</span></em>, <em class="sig-param"><span class="pre">keepdims=&lt;no</span> <span class="pre">value&gt;</span></em>, <em class="sig-param"><span class="pre">*</span></em>, <em class="sig-param"><span class="pre">where=&lt;no</span> <span class="pre">value&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.std" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the standard deviation along the specified axis.</p>
<p>Returns the standard deviation, a measure of the spread of a distribution,
of the array elements. The standard deviation is computed for the
flattened array by default, otherwise over the specified axis.</p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Calculate the standard deviation of these values.</p>
</dd>
<dt>axis<span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Axis or axes along which the standard deviation is computed. The
default is to compute the standard deviation of the flattened array.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<p>If this is a tuple of ints, a standard deviation is performed over
multiple axes, instead of a single axis or all the axes as before.</p>
</dd>
<dt>dtype<span class="classifier">dtype, optional</span></dt><dd><p>Type to use in computing the standard deviation. For arrays of
integer type the default is float64, for arrays of float types it is
the same as the array type.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Alternative output array in which to place the result. It must have
the same shape as the expected output but the type (of the calculated
values) will be cast if necessary.</p>
</dd>
<dt>ddof<span class="classifier">int, optional</span></dt><dd><p>Means Delta Degrees of Freedom.  The divisor used in calculations
is <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">ddof</span></code>, where <code class="docutils literal notranslate"><span class="pre">N</span></code> represents the number of elements.
By default <cite>ddof</cite> is zero.</p>
</dd>
<dt>keepdims<span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p>If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>std</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
<dt>where<span class="classifier">array_like of bool, optional</span></dt><dd><p>Elements to include in the standard deviation.
See <cite>~numpy.ufunc.reduce</cite> for details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.20.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>standard_deviation<span class="classifier">ndarray, see dtype parameter above.</span></dt><dd><p>If <cite>out</cite> is None, return a new array containing the standard deviation,
otherwise return a reference to the output array.</p>
</dd>
</dl>
<p>var, mean, nanmean, nanstd, nanvar
<span class="xref std std-ref">ufuncs-output-type</span></p>
<p>The standard deviation is the square root of the average of the squared
deviations from the mean, i.e., <code class="docutils literal notranslate"><span class="pre">std</span> <span class="pre">=</span> <span class="pre">sqrt(mean(x))</span></code>, where
<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">abs(a</span> <span class="pre">-</span> <span class="pre">a.mean())**2</span></code>.</p>
<p>The average squared deviation is typically calculated as <code class="docutils literal notranslate"><span class="pre">x.sum()</span> <span class="pre">/</span> <span class="pre">N</span></code>,
where <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">len(x)</span></code>. If, however, <cite>ddof</cite> is specified, the divisor
<code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">ddof</span></code> is used instead. In standard statistical practice, <code class="docutils literal notranslate"><span class="pre">ddof=1</span></code>
provides an unbiased estimator of the variance of the infinite population.
<code class="docutils literal notranslate"><span class="pre">ddof=0</span></code> provides a maximum likelihood estimate of the variance for
normally distributed variables. The standard deviation computed in this
function is the square root of the estimated variance, so even with
<code class="docutils literal notranslate"><span class="pre">ddof=1</span></code>, it will not be an unbiased estimate of the standard deviation
per se.</p>
<p>Note that, for complex numbers, <cite>std</cite> takes the absolute
value before squaring, so that the result is always real and nonnegative.</p>
<p>For floating-point input, the <em>std</em> is computed using the same
precision the input has. Depending on the input data, this can cause
the results to be inaccurate, especially for float32 (see example below).
Specifying a higher-accuracy accumulator using the <cite>dtype</cite> keyword can
alleviate this issue.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1.1180339887498949 # may vary</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([1.,  1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([0.5,  0.5])</span>
</pre></div>
</div>
<p>In single precision, std() can be inaccurate:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">512</span><span class="o">*</span><span class="mi">512</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">0.45000005</span>
</pre></div>
</div>
<p>Computing the standard deviation in float64 is more accurate:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="go">0.44999999925494177 # may vary</span>
</pre></div>
</div>
<p>Specifying a where argument:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">14</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">2.614064523559687 # may vary</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="p">[[</span><span class="kc">True</span><span class="p">],</span> <span class="p">[</span><span class="kc">True</span><span class="p">],</span> <span class="p">[</span><span class="kc">False</span><span class="p">]])</span>
<span class="go">2.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.str0">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">str0</span></code><a class="headerlink" href="#numpy.str0" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.str_" title="numpy.str_"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.str_</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt id="numpy.str_">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">str_</span></code><a class="headerlink" href="#numpy.str_" title="Permalink to this definition">¶</a></dt>
<dd><p>A unicode string.</p>
<p>When used in arrays, this type strips trailing null codepoints.</p>
<p>Unlike the builtin <cite>str</cite>, this supports the <span class="xref std std-ref">python:bufferobjects</span>, exposing its
contents as UCS4:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">str_</span><span class="p">(</span><span class="s2">&quot;abc&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">format</span>
<span class="go">&#39;3w&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">b&#39;a\x00\x00\x00b\x00\x00\x00c\x00\x00\x00&#39;</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Character code</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">'U'</span></code></p>
</dd>
<dt class="field-even">Alias</dt>
<dd class="field-even"><p><cite>numpy.unicode_</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.string_">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">string_</span></code><a class="headerlink" href="#numpy.string_" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.bytes_" title="numpy.bytes_"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.bytes_</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="numpy.sum">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">sum</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">a</span></em>, <em class="sig-param"><span class="pre">axis=None</span></em>, <em class="sig-param"><span class="pre">dtype=None</span></em>, <em class="sig-param"><span class="pre">out=None</span></em>, <em class="sig-param"><span class="pre">keepdims=&lt;no</span> <span class="pre">value&gt;</span></em>, <em class="sig-param"><span class="pre">initial=&lt;no</span> <span class="pre">value&gt;</span></em>, <em class="sig-param"><span class="pre">where=&lt;no</span> <span class="pre">value&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Sum of array elements over a given axis.</p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Elements to sum.</p>
</dd>
<dt>axis<span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Axis or axes along which a sum is performed.  The default,
axis=None, will sum all of the elements of the input array.  If
axis is negative it counts from the last to the first axis.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<p>If axis is a tuple of ints, a sum is performed on all of the axes
specified in the tuple instead of a single axis or all the axes as
before.</p>
</dd>
<dt>dtype<span class="classifier">dtype, optional</span></dt><dd><p>The type of the returned array and of the accumulator in which the
elements are summed.  The dtype of <cite>a</cite> is used by default unless <cite>a</cite>
has an integer dtype of less precision than the default platform
integer.  In that case, if <cite>a</cite> is signed then the platform integer
is used while if <cite>a</cite> is unsigned then an unsigned integer of the
same precision as the platform integer is used.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Alternative output array in which to place the result. It must have
the same shape as the expected output, but the type of the output
values will be cast if necessary.</p>
</dd>
<dt>keepdims<span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p>If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>sum</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
<dt>initial<span class="classifier">scalar, optional</span></dt><dd><p>Starting value for the sum. See <cite>~numpy.ufunc.reduce</cite> for details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.15.0.</span></p>
</div>
</dd>
<dt>where<span class="classifier">array_like of bool, optional</span></dt><dd><p>Elements to include in the sum. See <cite>~numpy.ufunc.reduce</cite> for details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.17.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>sum_along_axis<span class="classifier">ndarray</span></dt><dd><p>An array with the same shape as <cite>a</cite>, with the specified
axis removed.   If <cite>a</cite> is a 0-d array, or if <cite>axis</cite> is None, a scalar
is returned.  If an output array is specified, a reference to
<cite>out</cite> is returned.</p>
</dd>
</dl>
<p>ndarray.sum : Equivalent method.</p>
<p>add.reduce : Equivalent functionality of <cite>add</cite>.</p>
<p>cumsum : Cumulative sum of array elements.</p>
<p>trapz : Integration of array values using the composite trapezoidal rule.</p>
<p>mean, average</p>
<p>Arithmetic is modular when using integer types, and no error is
raised on overflow.</p>
<p>The sum of an empty array is the neutral element 0:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([])</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p>For floating point numbers the numerical precision of sum (and
<code class="docutils literal notranslate"><span class="pre">np.add.reduce</span></code>) is in general limited by directly adding each number
individually to the result causing rounding errors in every step.
However, often numpy will use a  numerically better approach (partial
pairwise summation) leading to improved precision in many use-cases.
This improved precision is always provided when no <code class="docutils literal notranslate"><span class="pre">axis</span></code> is given.
When <code class="docutils literal notranslate"><span class="pre">axis</span></code> is given, it will depend on which axis is summed.
Technically, to provide the best speed possible, the improved precision
is only used when the summation is along the fast axis in memory.
Note that the exact precision may vary depending on other parameters.
In contrast to NumPy, Python’s <code class="docutils literal notranslate"><span class="pre">math.fsum</span></code> function uses a slower but
more precise approach to summation.
Especially when summing a large number of lower precision floating point
numbers, such as <code class="docutils literal notranslate"><span class="pre">float32</span></code>, numerical errors can become significant.
In such cases it can be advisable to use <cite>dtype=”float64”</cite> to use a higher
precision for the output.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">])</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([0, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([1, 5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="n">where</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([1., 5.])</span>
</pre></div>
</div>
<p>If the accumulator is too small, overflow occurs:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
<span class="go">-128</span>
</pre></div>
</div>
<p>You can also start the sum with a value other than zero:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="mi">10</span><span class="p">],</span> <span class="n">initial</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">15</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.swapaxes">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">swapaxes</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.swapaxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Interchange two axes of an array.</p>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt>axis1<span class="classifier">int</span></dt><dd><p>First axis.</p>
</dd>
<dt>axis2<span class="classifier">int</span></dt><dd><p>Second axis.</p>
</dd>
</dl>
<dl class="simple">
<dt>a_swapped<span class="classifier">ndarray</span></dt><dd><p>For NumPy &gt;= 1.10.0, if <cite>a</cite> is an ndarray, then a view of <cite>a</cite> is
returned; otherwise a new array is created. For earlier NumPy
versions a view of <cite>a</cite> is returned only if the order of the
axes is changed, otherwise the input array is returned.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[1],</span>
<span class="go">       [2],</span>
<span class="go">       [3]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]],[[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[[0, 1],</span>
<span class="go">        [2, 3]],</span>
<span class="go">       [[4, 5],</span>
<span class="go">        [6, 7]]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([[[0, 4],</span>
<span class="go">        [2, 6]],</span>
<span class="go">       [[1, 5],</span>
<span class="go">        [3, 7]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.take">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">take</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'raise'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.take" title="Permalink to this definition">¶</a></dt>
<dd><p>Take elements from an array along an axis.</p>
<p>When axis is not None, this function does the same thing as “fancy”
indexing (indexing arrays using arrays); however, it can be easier to use
if you need elements along a given axis. A call such as
<code class="docutils literal notranslate"><span class="pre">np.take(arr,</span> <span class="pre">indices,</span> <span class="pre">axis=3)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">arr[:,:,:,indices,...]</span></code>.</p>
<p>Explained without fancy indexing, this is equivalent to the following use
of <cite>ndindex</cite>, which sets each of <code class="docutils literal notranslate"><span class="pre">ii</span></code>, <code class="docutils literal notranslate"><span class="pre">jj</span></code>, and <code class="docutils literal notranslate"><span class="pre">kk</span></code> to a tuple of
indices:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ni</span><span class="p">,</span> <span class="n">Nk</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">],</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
<span class="n">Nj</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">shape</span>
<span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Ni</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Nj</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Nk</span><span class="p">):</span>
            <span class="n">out</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">jj</span> <span class="o">+</span> <span class="n">kk</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">jj</span><span class="p">],)</span> <span class="o">+</span> <span class="n">kk</span><span class="p">]</span>
</pre></div>
</div>
<dl>
<dt>a<span class="classifier">array_like (Ni…, M, Nk…)</span></dt><dd><p>The source array.</p>
</dd>
<dt>indices<span class="classifier">array_like (Nj…)</span></dt><dd><p>The indices of the values to extract.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
<p>Also allow scalars for indices.</p>
</dd>
<dt>axis<span class="classifier">int, optional</span></dt><dd><p>The axis over which to select values. By default, the flattened
input array is used.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional (Ni…, Nj…, Nk…)</span></dt><dd><p>If provided, the result will be placed in this array. It should
be of the appropriate shape and dtype. Note that <cite>out</cite> is always
buffered if <cite>mode=’raise’</cite>; use other modes for better performance.</p>
</dd>
<dt>mode<span class="classifier">{‘raise’, ‘wrap’, ‘clip’}, optional</span></dt><dd><p>Specifies how out-of-bounds indices will behave.</p>
<ul class="simple">
<li><p>‘raise’ – raise an error (default)</p></li>
<li><p>‘wrap’ – wrap around</p></li>
<li><p>‘clip’ – clip to the range</p></li>
</ul>
<p>‘clip’ mode means that all indices that are too large are replaced
by the index that addresses the last element along that axis. Note
that this disables indexing with negative numbers.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray (Ni…, Nj…, Nk…)</span></dt><dd><p>The returned array has the same type as <cite>a</cite>.</p>
</dd>
</dl>
<p>compress : Take elements using a boolean mask
ndarray.take : equivalent method
take_along_axis : Take elements by matching the array and the index arrays</p>
<p>By eliminating the inner loop in the description above, and using <cite>s_</cite> to
build simple slice objects, <cite>take</cite> can be expressed  in terms of applying
fancy indexing to each 1-d slice:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ni</span><span class="p">,</span> <span class="n">Nk</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">],</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
<span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Ni</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Nj</span><span class="p">):</span>
        <span class="n">out</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">s_</span><span class="p">[</span><span class="o">...</span><span class="p">,]</span> <span class="o">+</span> <span class="n">kk</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">s_</span><span class="p">[:,]</span> <span class="o">+</span> <span class="n">kk</span><span class="p">][</span><span class="n">indices</span><span class="p">]</span>
</pre></div>
</div>
<p>For this reason, it is equivalent to (but faster than) the following use
of <cite>apply_along_axis</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a_1d</span><span class="p">:</span> <span class="n">a_1d</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="n">axis</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
<span class="go">array([4, 3, 6])</span>
</pre></div>
</div>
<p>In this example if <cite>a</cite> is an ndarray, “fancy” indexing can be used.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
<span class="go">array([4, 3, 6])</span>
</pre></div>
</div>
<p>If <cite>indices</cite> is not one dimensional, the output also has these dimensions.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="go">array([[4, 3],</span>
<span class="go">       [5, 7]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.take_along_axis">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">take_along_axis</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.take_along_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Take values from the input array by matching 1d index and data slices.</p>
<p>This iterates over matching 1d slices oriented along the specified axis in
the index and data arrays, and uses the former to look up values in the
latter. These slices can be different lengths.</p>
<p>Functions returning an index along an axis, like <cite>argsort</cite> and
<cite>argpartition</cite>, produce suitable indices for this function.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.15.0.</span></p>
</div>
<dl class="simple">
<dt>arr<span class="classifier">ndarray (Ni…, M, Nk…)</span></dt><dd><p>Source array</p>
</dd>
<dt>indices<span class="classifier">ndarray (Ni…, J, Nk…)</span></dt><dd><p>Indices to take along each 1d slice of <cite>arr</cite>. This must match the
dimension of arr, but dimensions Ni and Nj only need to broadcast
against <cite>arr</cite>.</p>
</dd>
<dt>axis<span class="classifier">int</span></dt><dd><p>The axis to take 1d slices along. If axis is None, the input array is
treated as if it had first been flattened to 1d, for consistency with
<cite>sort</cite> and <cite>argsort</cite>.</p>
</dd>
</dl>
<dl class="simple">
<dt>out: ndarray (Ni…, J, Nk…)</dt><dd><p>The indexed result.</p>
</dd>
</dl>
<p>This is equivalent to (but faster than) the following use of <cite>ndindex</cite> and
<cite>s_</cite>, which sets each of <code class="docutils literal notranslate"><span class="pre">ii</span></code> and <code class="docutils literal notranslate"><span class="pre">kk</span></code> to a tuple of indices:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ni</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">Nk</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">],</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
<span class="n">J</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>  <span class="c1"># Need not equal M</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">Ni</span> <span class="o">+</span> <span class="p">(</span><span class="n">J</span><span class="p">,)</span> <span class="o">+</span> <span class="n">Nk</span><span class="p">)</span>

<span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Ni</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Nk</span><span class="p">):</span>
        <span class="n">a_1d</span>       <span class="o">=</span> <span class="n">a</span>      <span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">s_</span><span class="p">[:,]</span> <span class="o">+</span> <span class="n">kk</span><span class="p">]</span>
        <span class="n">indices_1d</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">s_</span><span class="p">[:,]</span> <span class="o">+</span> <span class="n">kk</span><span class="p">]</span>
        <span class="n">out_1d</span>     <span class="o">=</span> <span class="n">out</span>    <span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">s_</span><span class="p">[:,]</span> <span class="o">+</span> <span class="n">kk</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">J</span><span class="p">):</span>
            <span class="n">out_1d</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">a_1d</span><span class="p">[</span><span class="n">indices_1d</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
</pre></div>
</div>
<p>Equivalently, eliminating the inner loop, the last two lines would be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">out_1d</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">a_1d</span><span class="p">[</span><span class="n">indices_1d</span><span class="p">]</span>
</pre></div>
</div>
<p>take : Take along an axis, using the same indices for every 1d slice
put_along_axis :</p>
<blockquote>
<div><p>Put values into the destination array by matching 1d index and data slices</p>
</div></blockquote>
<p>For this sample array</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span> <span class="p">[</span><span class="mi">60</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">]])</span>
</pre></div>
</div>
<p>We can sort either by using sort directly, or argsort and this function</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[10, 20, 30],</span>
<span class="go">       [40, 50, 60]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ai</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span> <span class="n">ai</span>
<span class="go">array([[0, 2, 1],</span>
<span class="go">       [1, 2, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ai</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[10, 20, 30],</span>
<span class="go">       [40, 50, 60]])</span>
</pre></div>
</div>
<p>The same works for max and min, if you expand the dimensions:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[30],</span>
<span class="go">       [60]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ai</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ai</span>
<span class="go">array([[1],</span>
<span class="go">       [0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ai</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[30],</span>
<span class="go">       [60]])</span>
</pre></div>
</div>
<p>If we want to get the max and min at the same time, we can stack the
indices first</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ai_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ai_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ai</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">ai_min</span><span class="p">,</span> <span class="n">ai_max</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ai</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [1, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ai</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[10, 30],</span>
<span class="go">       [40, 60]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.tensordot">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">tensordot</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.tensordot" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute tensor dot product along specified axes.</p>
<p>Given two tensors, <cite>a</cite> and <cite>b</cite>, and an array_like object containing
two array_like objects, <code class="docutils literal notranslate"><span class="pre">(a_axes,</span> <span class="pre">b_axes)</span></code>, sum the products of
<cite>a</cite>’s and <cite>b</cite>’s elements (components) over the axes specified by
<code class="docutils literal notranslate"><span class="pre">a_axes</span></code> and <code class="docutils literal notranslate"><span class="pre">b_axes</span></code>. The third argument can be a single non-negative
integer_like scalar, <code class="docutils literal notranslate"><span class="pre">N</span></code>; if it is such, then the last <code class="docutils literal notranslate"><span class="pre">N</span></code> dimensions
of <cite>a</cite> and the first <code class="docutils literal notranslate"><span class="pre">N</span></code> dimensions of <cite>b</cite> are summed over.</p>
<dl class="simple">
<dt>a, b<span class="classifier">array_like</span></dt><dd><p>Tensors to “dot”.</p>
</dd>
<dt>axes<span class="classifier">int or (2,) array_like</span></dt><dd><ul class="simple">
<li><p>integer_like
If an int N, sum over the last N axes of <cite>a</cite> and the first N axes
of <cite>b</cite> in order. The sizes of the corresponding axes must match.</p></li>
<li><p>(2,) array_like
Or, a list of axes to be summed over, first sequence applying to <cite>a</cite>,
second to <cite>b</cite>. Both elements array_like must be of the same length.</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>output<span class="classifier">ndarray</span></dt><dd><p>The tensor dot product of the input.</p>
</dd>
</dl>
<p>dot, einsum</p>
<dl class="simple">
<dt>Three common use cases are:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">axes</span> <span class="pre">=</span> <span class="pre">0</span></code> : tensor product <span class="math notranslate nohighlight">\(a\otimes b\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">axes</span> <span class="pre">=</span> <span class="pre">1</span></code> : tensor dot product <span class="math notranslate nohighlight">\(a\cdot b\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">axes</span> <span class="pre">=</span> <span class="pre">2</span></code> : (default) tensor double contraction <span class="math notranslate nohighlight">\(a:b\)</span></p></li>
</ul>
</dd>
</dl>
<p>When <cite>axes</cite> is integer_like, the sequence for evaluation will be: first
the -Nth axis in <cite>a</cite> and 0th axis in <cite>b</cite>, and the -1th axis in <cite>a</cite> and
Nth axis in <cite>b</cite> last.</p>
<p>When there is more than one axis to sum over - and they are not the last
(first) axes of <cite>a</cite> (<cite>b</cite>) - the argument <cite>axes</cite> should consist of
two sequences of the same length, with the first axis to sum over given
first in both sequences, the second axis second, and so forth.</p>
<p>The shape of the result consists of the non-contracted axes of the
first tensor, followed by the non-contracted axes of the second.</p>
<p>A “traditional” example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">60.</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">24.</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">array([[4400., 4730.],</span>
<span class="go">       [4532., 4874.],</span>
<span class="go">       [4664., 5018.],</span>
<span class="go">       [4796., 5162.],</span>
<span class="go">       [4928., 5306.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># A slower but equivalent way of computing the same...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
<span class="gp">... </span>  <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
<span class="gp">... </span>      <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">==</span> <span class="n">d</span>
<span class="go">array([[ True,  True],</span>
<span class="go">       [ True,  True],</span>
<span class="go">       [ True,  True],</span>
<span class="go">       [ True,  True],</span>
<span class="go">       [ True,  True]])</span>
</pre></div>
</div>
<p>An extended example taking advantage of the overloading of + and *:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">;</span> <span class="n">A</span>
<span class="go">array([[[1, 2],</span>
<span class="go">        [3, 4]],</span>
<span class="go">       [[5, 6],</span>
<span class="go">        [7, 8]]])</span>
<span class="go">array([[&#39;a&#39;, &#39;b&#39;],</span>
<span class="go">       [&#39;c&#39;, &#39;d&#39;]], dtype=object)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span> <span class="c1"># third argument default is 2 for double-contraction</span>
<span class="go">array([&#39;abbcccdddd&#39;, &#39;aaaaabbbbbbcccccccdddddddd&#39;], dtype=object)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">array([[[&#39;acc&#39;, &#39;bdd&#39;],</span>
<span class="go">        [&#39;aaacccc&#39;, &#39;bbbdddd&#39;]],</span>
<span class="go">       [[&#39;aaaaacccccc&#39;, &#39;bbbbbdddddd&#39;],</span>
<span class="go">        [&#39;aaaaaaacccccccc&#39;, &#39;bbbbbbbdddddddd&#39;]]], dtype=object)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># tensor product (result too long to incl.)</span>
<span class="go">array([[[[[&#39;a&#39;, &#39;b&#39;],</span>
<span class="go">          [&#39;c&#39;, &#39;d&#39;]],</span>
<span class="go">          ...</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">array([[[&#39;abbbbb&#39;, &#39;cddddd&#39;],</span>
<span class="go">        [&#39;aabbbbbb&#39;, &#39;ccdddddd&#39;]],</span>
<span class="go">       [[&#39;aaabbbbbbb&#39;, &#39;cccddddddd&#39;],</span>
<span class="go">        [&#39;aaaabbbbbbbb&#39;, &#39;ccccdddddddd&#39;]]], dtype=object)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">array([[[&#39;abb&#39;, &#39;cdd&#39;],</span>
<span class="go">        [&#39;aaabbbb&#39;, &#39;cccdddd&#39;]],</span>
<span class="go">       [[&#39;aaaaabbbbbb&#39;, &#39;cccccdddddd&#39;],</span>
<span class="go">        [&#39;aaaaaaabbbbbbbb&#39;, &#39;cccccccdddddddd&#39;]]], dtype=object)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
<span class="go">array([&#39;abbbcccccddddddd&#39;, &#39;aabbbbccccccdddddddd&#39;], dtype=object)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
<span class="go">array([&#39;acccbbdddd&#39;, &#39;aaaaacccccccbbbbbbdddddddd&#39;], dtype=object)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.tile">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">tile</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reps</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.tile" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct an array by repeating A the number of times given by reps.</p>
<p>If <cite>reps</cite> has length <code class="docutils literal notranslate"><span class="pre">d</span></code>, the result will have dimension of
<code class="docutils literal notranslate"><span class="pre">max(d,</span> <span class="pre">A.ndim)</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">A.ndim</span> <span class="pre">&lt;</span> <span class="pre">d</span></code>, <cite>A</cite> is promoted to be d-dimensional by prepending new
axes. So a shape (3,) array is promoted to (1, 3) for 2-D replication,
or shape (1, 1, 3) for 3-D replication. If this is not the desired
behavior, promote <cite>A</cite> to d-dimensions manually before calling this
function.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">A.ndim</span> <span class="pre">&gt;</span> <span class="pre">d</span></code>, <cite>reps</cite> is promoted to <cite>A</cite>.ndim by pre-pending 1’s to it.
Thus for an <cite>A</cite> of shape (2, 3, 4, 5), a <cite>reps</cite> of (2, 2) is treated as
(1, 1, 2, 2).</p>
<p>Note : Although tile may be used for broadcasting, it is strongly
recommended to use numpy’s broadcasting operations and functions.</p>
<dl class="simple">
<dt>A<span class="classifier">array_like</span></dt><dd><p>The input array.</p>
</dd>
<dt>reps<span class="classifier">array_like</span></dt><dd><p>The number of repetitions of <cite>A</cite> along each axis.</p>
</dd>
</dl>
<dl class="simple">
<dt>c<span class="classifier">ndarray</span></dt><dd><p>The tiled output array.</p>
</dd>
</dl>
<p>repeat : Repeat elements of an array.
broadcast_to : Broadcast an array to a new shape</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([0, 1, 2, 0, 1, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">array([[0, 1, 2, 0, 1, 2],</span>
<span class="go">       [0, 1, 2, 0, 1, 2]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">array([[[0, 1, 2, 0, 1, 2]],</span>
<span class="go">       [[0, 1, 2, 0, 1, 2]]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([[1, 2, 1, 2],</span>
<span class="go">       [3, 4, 3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4],</span>
<span class="go">       [1, 2],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">c</span><span class="p">,(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="go">array([[1, 2, 3, 4],</span>
<span class="go">       [1, 2, 3, 4],</span>
<span class="go">       [1, 2, 3, 4],</span>
<span class="go">       [1, 2, 3, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt id="numpy.timedelta64">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">timedelta64</span></code><a class="headerlink" href="#numpy.timedelta64" title="Permalink to this definition">¶</a></dt>
<dd><p>A timedelta stored as a 64-bit integer.</p>
<p>See <span class="xref std std-ref">arrays.datetime</span> for more information.</p>
<dl class="field-list simple">
<dt class="field-odd">Character code</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">'m'</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="numpy.trace">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">trace</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum along diagonals of the array.</p>
<p>If <cite>a</cite> is 2-D, the sum along its diagonal with the given offset
is returned, i.e., the sum of elements <code class="docutils literal notranslate"><span class="pre">a[i,i+offset]</span></code> for all i.</p>
<p>If <cite>a</cite> has more than two dimensions, then the axes specified by axis1 and
axis2 are used to determine the 2-D sub-arrays whose traces are returned.
The shape of the resulting array is the same as that of <cite>a</cite> with <cite>axis1</cite>
and <cite>axis2</cite> removed.</p>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input array, from which the diagonals are taken.</p>
</dd>
<dt>offset<span class="classifier">int, optional</span></dt><dd><p>Offset of the diagonal from the main diagonal. Can be both positive
and negative. Defaults to 0.</p>
</dd>
<dt>axis1, axis2<span class="classifier">int, optional</span></dt><dd><p>Axes to be used as the first and second axis of the 2-D sub-arrays
from which the diagonals should be taken. Defaults are the first two
axes of <cite>a</cite>.</p>
</dd>
<dt>dtype<span class="classifier">dtype, optional</span></dt><dd><p>Determines the data-type of the returned array and of the accumulator
where the elements are summed. If dtype has the value None and <cite>a</cite> is
of integer type of precision less than the default integer
precision, then the default integer precision is used. Otherwise,
the precision is the same as that of <cite>a</cite>.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Array into which the output is placed. Its type is preserved and
it must be of the right shape to hold the output.</p>
</dd>
</dl>
<dl class="simple">
<dt>sum_along_diagonals<span class="classifier">ndarray</span></dt><dd><p>If <cite>a</cite> is 2-D, the sum along the diagonal is returned.  If <cite>a</cite> has
larger dimensions, then an array of sums along diagonals is returned.</p>
</dd>
</dl>
<p>diag, diagonal, diagflat</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([6, 8])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.transpose">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">transpose</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse or permute the axes of an array; returns the modified array.</p>
<p>For an array a with two axes, transpose(a) gives the matrix transpose.</p>
<p>Refer to <cite>numpy.ndarray.transpose</cite> for full documentation.</p>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt>axes<span class="classifier">tuple or list of ints, optional</span></dt><dd><p>If specified, it must be a tuple or list which contains a permutation of
[0,1,..,N-1] where N is the number of axes of a.  The i’th axis of the
returned array will correspond to the axis numbered <code class="docutils literal notranslate"><span class="pre">axes[i]</span></code> of the
input.  If not specified, defaults to <code class="docutils literal notranslate"><span class="pre">range(a.ndim)[::-1]</span></code>, which
reverses the order of the axes.</p>
</dd>
</dl>
<dl class="simple">
<dt>p<span class="classifier">ndarray</span></dt><dd><p><cite>a</cite> with its axes permuted.  A view is returned whenever
possible.</p>
</dd>
</dl>
<p>ndarray.transpose : Equivalent method
moveaxis
argsort</p>
<p>Use <cite>transpose(a, argsort(axes))</cite> to invert the transposition of tensors
when using the <cite>axes</cite> keyword argument.</p>
<p>Transposing a 1-D array returns an unchanged view of the original array.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([[0, 2],</span>
<span class="go">       [1, 3]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 1, 3)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 4, 3, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.trapz">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">trapz</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.trapz" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrate along the given axis using the composite trapezoidal rule.</p>
<p>If <cite>x</cite> is provided, the integration happens in sequence along its
elements - they are not sorted.</p>
<p>Integrate <cite>y</cite> (<cite>x</cite>) along each 1d slice on the given axis, compute
<span class="math notranslate nohighlight">\(\int y(x) dx\)</span>.
When <cite>x</cite> is specified, this integrates along the parametric curve,
computing <span class="math notranslate nohighlight">\(\int_t y(t) dt =
\int_t y(t) \left.\frac{dx}{dt}\right|_{x=x(t)} dt\)</span>.</p>
<dl class="simple">
<dt>y<span class="classifier">array_like</span></dt><dd><p>Input array to integrate.</p>
</dd>
<dt>x<span class="classifier">array_like, optional</span></dt><dd><p>The sample points corresponding to the <cite>y</cite> values. If <cite>x</cite> is None,
the sample points are assumed to be evenly spaced <cite>dx</cite> apart. The
default is None.</p>
</dd>
<dt>dx<span class="classifier">scalar, optional</span></dt><dd><p>The spacing between sample points when <cite>x</cite> is None. The default is 1.</p>
</dd>
<dt>axis<span class="classifier">int, optional</span></dt><dd><p>The axis along which to integrate.</p>
</dd>
</dl>
<dl class="simple">
<dt>trapz<span class="classifier">float or ndarray</span></dt><dd><p>Definite integral of ‘y’ = n-dimensional array as approximated along
a single axis by the trapezoidal rule. If ‘y’ is a 1-dimensional array,
then the result is a float. If ‘n’ is greater than 1, then the result
is an ‘n-1’ dimensional array.</p>
</dd>
</dl>
<p>sum, cumsum</p>
<p>Image <a href="#id95"><span class="problematic" id="id65">[2]_</span></a> illustrates trapezoidal rule – y-axis locations of points
will be taken from <cite>y</cite> array, by default x-axis distances between
points will be 1.0, alternatively they can be provided with <cite>x</cite> array
or with <cite>dx</cite> scalar.  Return value will be equal to combined area under
the red lines.</p>
<dl class="footnote brackets">
<dt class="label" id="id66"><span class="brackets">1</span></dt>
<dd><p>Wikipedia page: <a class="reference external" href="https://en.wikipedia.org/wiki/Trapezoidal_rule">https://en.wikipedia.org/wiki/Trapezoidal_rule</a></p>
</dd>
<dt class="label" id="id67"><span class="brackets">2</span></dt>
<dd><p>Illustration image:
<a class="reference external" href="https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png">https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png</a></p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">4.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">x</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span>
<span class="go">8.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">dx</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">8.0</span>
</pre></div>
</div>
<p>Using a decreasing <cite>x</cite> corresponds to integrating in reverse:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">x</span><span class="o">=</span><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>  
<span class="go">-8.0</span>
</pre></div>
</div>
<p>More generally <cite>x</cite> is used to integrate along a parametric curve.
This finds the area of a circle, noting we repeat the sample which closes
the curve:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">x</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span>
<span class="go">3.141571941375841</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([1.5, 2.5, 3.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([2.,  8.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.tri">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">tri</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">N</span></em>, <em class="sig-param"><span class="pre">M=None</span></em>, <em class="sig-param"><span class="pre">k=0</span></em>, <em class="sig-param"><span class="pre">dtype=&lt;class</span> <span class="pre">'float'&gt;</span></em>, <em class="sig-param"><span class="pre">*</span></em>, <em class="sig-param"><span class="pre">like=None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.tri" title="Permalink to this definition">¶</a></dt>
<dd><p>An array with ones at and below the given diagonal and zeros elsewhere.</p>
<dl>
<dt>N<span class="classifier">int</span></dt><dd><p>Number of rows in the array.</p>
</dd>
<dt>M<span class="classifier">int, optional</span></dt><dd><p>Number of columns in the array.
By default, <cite>M</cite> is taken equal to <cite>N</cite>.</p>
</dd>
<dt>k<span class="classifier">int, optional</span></dt><dd><p>The sub-diagonal at and below which the array is filled.
<cite>k</cite> = 0 is the main diagonal, while <cite>k</cite> &lt; 0 is below it,
and <cite>k</cite> &gt; 0 is above.  The default is 0.</p>
</dd>
<dt>dtype<span class="classifier">dtype, optional</span></dt><dd><p>Data type of the returned array.  The default is float.</p>
</dd>
<dt>like<span class="classifier">array_like</span></dt><dd><p>Reference object to allow the creation of arrays which are not
NumPy arrays. If an array-like passed in as <code class="docutils literal notranslate"><span class="pre">like</span></code> supports
the <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> protocol, the result will be defined
by it. In this case, it ensures the creation of an array object
compatible with that passed in via this argument.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.20.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>tri<span class="classifier">ndarray of shape (N, M)</span></dt><dd><p>Array with its lower triangle filled with ones and zero elsewhere;
in other words <code class="docutils literal notranslate"><span class="pre">T[i,j]</span> <span class="pre">==</span> <span class="pre">1</span></code> for <code class="docutils literal notranslate"><span class="pre">j</span> <span class="pre">&lt;=</span> <span class="pre">i</span> <span class="pre">+</span> <span class="pre">k</span></code>, 0 otherwise.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tri</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([[1, 1, 1, 0, 0],</span>
<span class="go">       [1, 1, 1, 1, 0],</span>
<span class="go">       [1, 1, 1, 1, 1]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tri</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [1.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [1.,  1.,  0.,  0.,  0.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.tril">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">tril</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.tril" title="Permalink to this definition">¶</a></dt>
<dd><p>Lower triangle of an array.</p>
<p>Return a copy of an array with elements above the <cite>k</cite>-th diagonal zeroed.</p>
<dl class="simple">
<dt>m<span class="classifier">array_like, shape (M, N)</span></dt><dd><p>Input array.</p>
</dd>
<dt>k<span class="classifier">int, optional</span></dt><dd><p>Diagonal above which to zero elements.  <cite>k = 0</cite> (the default) is the
main diagonal, <cite>k &lt; 0</cite> is below it and <cite>k &gt; 0</cite> is above.</p>
</dd>
</dl>
<dl class="simple">
<dt>tril<span class="classifier">ndarray, shape (M, N)</span></dt><dd><p>Lower triangle of <cite>m</cite>, of same shape and data-type as <cite>m</cite>.</p>
</dd>
</dl>
<p>triu : same thing, only for the upper triangle</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tril</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],[</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">]],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[ 0,  0,  0],</span>
<span class="go">       [ 4,  0,  0],</span>
<span class="go">       [ 7,  8,  0],</span>
<span class="go">       [10, 11, 12]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.tril_indices">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">tril_indices</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.tril_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices for the lower-triangle of an (n, m) array.</p>
<dl>
<dt>n<span class="classifier">int</span></dt><dd><p>The row dimension of the arrays for which the returned
indices will be valid.</p>
</dd>
<dt>k<span class="classifier">int, optional</span></dt><dd><p>Diagonal offset (see <cite>tril</cite> for details).</p>
</dd>
<dt>m<span class="classifier">int, optional</span></dt><dd><div class="versionadded">
<p><span class="versionmodified added">New in version 1.9.0.</span></p>
</div>
<p>The column dimension of the arrays for which the returned
arrays will be valid.
By default <cite>m</cite> is taken equal to <cite>n</cite>.</p>
</dd>
</dl>
<dl class="simple">
<dt>inds<span class="classifier">tuple of arrays</span></dt><dd><p>The indices for the triangle. The returned tuple contains two arrays,
each with the indices along one dimension of the array.</p>
</dd>
</dl>
<p>triu_indices : similar function, for upper-triangular.
mask_indices : generic function accepting an arbitrary mask function.
tril, triu</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.4.0.</span></p>
</div>
<p>Compute two different sets of indices to access 4x4 arrays, one for the
lower triangular part starting at the main diagonal, and one starting two
diagonals further right:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">il1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tril_indices</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">il2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tril_indices</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Here is how they can be used with a sample array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15]])</span>
</pre></div>
</div>
<p>Both for indexing:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">il1</span><span class="p">]</span>
<span class="go">array([ 0,  4,  5, ..., 13, 14, 15])</span>
</pre></div>
</div>
<p>And for assigning values:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">il1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[-1,  1,  2,  3],</span>
<span class="go">       [-1, -1,  6,  7],</span>
<span class="go">       [-1, -1, -1, 11],</span>
<span class="go">       [-1, -1, -1, -1]])</span>
</pre></div>
</div>
<p>These cover almost the whole array (two diagonals right of the main one):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">il2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[-10, -10, -10,   3],</span>
<span class="go">       [-10, -10, -10, -10],</span>
<span class="go">       [-10, -10, -10, -10],</span>
<span class="go">       [-10, -10, -10, -10]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.tril_indices_from">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">tril_indices_from</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.tril_indices_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices for the lower-triangle of arr.</p>
<p>See <cite>tril_indices</cite> for full details.</p>
<dl class="simple">
<dt>arr<span class="classifier">array_like</span></dt><dd><p>The indices will be valid for square arrays whose dimensions are
the same as arr.</p>
</dd>
<dt>k<span class="classifier">int, optional</span></dt><dd><p>Diagonal offset (see <cite>tril</cite> for details).</p>
</dd>
</dl>
<p>tril_indices, tril</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.4.0.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.trim_zeros">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">trim_zeros</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'fb'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.trim_zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Trim the leading and/or trailing zeros from a 1-D array or sequence.</p>
<dl class="simple">
<dt>filt<span class="classifier">1-D array or sequence</span></dt><dd><p>Input array.</p>
</dd>
<dt>trim<span class="classifier">str, optional</span></dt><dd><p>A string with ‘f’ representing trim from front and ‘b’ to trim from
back. Default is ‘fb’, trim zeros from both front and back of the
array.</p>
</dd>
</dl>
<dl class="simple">
<dt>trimmed<span class="classifier">1-D array or sequence</span></dt><dd><p>The result of trimming the input. The input data type is preserved.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">trim_zeros</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([1, 2, 3, 0, 2, 1])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">trim_zeros</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="go">array([0, 0, 0, ..., 0, 2, 1])</span>
</pre></div>
</div>
<p>The input data type is preserved, list/tuple in means list/tuple out.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">trim_zeros</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">[1, 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.triu">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">triu</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.triu" title="Permalink to this definition">¶</a></dt>
<dd><p>Upper triangle of an array.</p>
<p>Return a copy of an array with the elements below the <cite>k</cite>-th diagonal
zeroed.</p>
<p>Please refer to the documentation for <cite>tril</cite> for further details.</p>
<p>tril : lower triangle of an array</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],[</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">]],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[ 1,  2,  3],</span>
<span class="go">       [ 4,  5,  6],</span>
<span class="go">       [ 0,  8,  9],</span>
<span class="go">       [ 0,  0, 12]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.triu_indices">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">triu_indices</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.triu_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices for the upper-triangle of an (n, m) array.</p>
<dl>
<dt>n<span class="classifier">int</span></dt><dd><p>The size of the arrays for which the returned indices will
be valid.</p>
</dd>
<dt>k<span class="classifier">int, optional</span></dt><dd><p>Diagonal offset (see <cite>triu</cite> for details).</p>
</dd>
<dt>m<span class="classifier">int, optional</span></dt><dd><div class="versionadded">
<p><span class="versionmodified added">New in version 1.9.0.</span></p>
</div>
<p>The column dimension of the arrays for which the returned
arrays will be valid.
By default <cite>m</cite> is taken equal to <cite>n</cite>.</p>
</dd>
</dl>
<dl>
<dt>inds<span class="classifier">tuple, shape(2) of ndarrays, shape(<cite>n</cite>)</span></dt><dd><p>The indices for the triangle. The returned tuple contains two arrays,
each with the indices along one dimension of the array.  Can be used
to slice a ndarray of shape(<cite>n</cite>, <cite>n</cite>).</p>
</dd>
</dl>
<p>tril_indices : similar function, for lower-triangular.
mask_indices : generic function accepting an arbitrary mask function.
triu, tril</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.4.0.</span></p>
</div>
<p>Compute two different sets of indices to access 4x4 arrays, one for the
upper triangular part starting at the main diagonal, and one starting two
diagonals further right:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">iu1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iu2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Here is how they can be used with a sample array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15]])</span>
</pre></div>
</div>
<p>Both for indexing:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">iu1</span><span class="p">]</span>
<span class="go">array([ 0,  1,  2, ..., 10, 11, 15])</span>
</pre></div>
</div>
<p>And for assigning values:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">iu1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[-1, -1, -1, -1],</span>
<span class="go">       [ 4, -1, -1, -1],</span>
<span class="go">       [ 8,  9, -1, -1],</span>
<span class="go">       [12, 13, 14, -1]])</span>
</pre></div>
</div>
<p>These cover only a small part of the whole array (two diagonals right
of the main one):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">iu2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[ -1,  -1, -10, -10],</span>
<span class="go">       [  4,  -1,  -1, -10],</span>
<span class="go">       [  8,   9,  -1,  -1],</span>
<span class="go">       [ 12,  13,  14,  -1]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.triu_indices_from">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">triu_indices_from</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.triu_indices_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices for the upper-triangle of arr.</p>
<p>See <cite>triu_indices</cite> for full details.</p>
<dl class="simple">
<dt>arr<span class="classifier">ndarray, shape(N, N)</span></dt><dd><p>The indices will be valid for square arrays.</p>
</dd>
<dt>k<span class="classifier">int, optional</span></dt><dd><p>Diagonal offset (see <cite>triu</cite> for details).</p>
</dd>
</dl>
<dl class="simple">
<dt>triu_indices_from<span class="classifier">tuple, shape(2) of ndarray, shape(N)</span></dt><dd><p>Indices for the upper-triangle of <cite>arr</cite>.</p>
</dd>
</dl>
<p>triu_indices, triu</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.4.0.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.typename">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">typename</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">char</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.typename" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a description for the given data type code.</p>
<dl class="simple">
<dt>char<span class="classifier">str</span></dt><dd><p>Data type code.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">str</span></dt><dd><p>Description of the input data type code.</p>
</dd>
</dl>
<p>dtype, typecodes</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">typechars</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;S1&#39;</span><span class="p">,</span> <span class="s1">&#39;?&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="s1">&#39;Q&#39;</span><span class="p">,</span>
<span class="gp">... </span>             <span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">,</span> <span class="s1">&#39;l&#39;</span><span class="p">,</span> <span class="s1">&#39;q&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">typechar</span> <span class="ow">in</span> <span class="n">typechars</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">typechar</span><span class="p">,</span> <span class="s1">&#39; : &#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">typename</span><span class="p">(</span><span class="n">typechar</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">S1  :  character</span>
<span class="go">?  :  bool</span>
<span class="go">B  :  unsigned char</span>
<span class="go">D  :  complex double precision</span>
<span class="go">G  :  complex long double precision</span>
<span class="go">F  :  complex single precision</span>
<span class="go">I  :  unsigned integer</span>
<span class="go">H  :  unsigned short</span>
<span class="go">L  :  unsigned long integer</span>
<span class="go">O  :  object</span>
<span class="go">Q  :  unsigned long long integer</span>
<span class="go">S  :  string</span>
<span class="go">U  :  unicode</span>
<span class="go">V  :  void</span>
<span class="go">b  :  signed char</span>
<span class="go">d  :  double precision</span>
<span class="go">g  :  long precision</span>
<span class="go">f  :  single precision</span>
<span class="go">i  :  integer</span>
<span class="go">h  :  short</span>
<span class="go">l  :  long integer</span>
<span class="go">q  :  long long integer</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.ubyte">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">ubyte</span></code><a class="headerlink" href="#numpy.ubyte" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.uint8" title="numpy.uint8"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.uint8</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt id="numpy.ufunc">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">ufunc</span></code><a class="headerlink" href="#numpy.ufunc" title="Permalink to this definition">¶</a></dt>
<dd><p>Functions that operate element by element on whole arrays.</p>
<p>To see the documentation for a specific ufunc, use <cite>info</cite>.  For
example, <code class="docutils literal notranslate"><span class="pre">np.info(np.sin)</span></code>.  Because ufuncs are written in C
(for speed) and linked into Python with NumPy’s ufunc facility,
Python’s help() function finds this page whenever help() is called
on a ufunc.</p>
<p>A detailed explanation of ufuncs can be found in the docs for <span class="xref std std-ref">ufuncs</span>.</p>
<p><strong>Calling ufuncs:</strong> <code class="docutils literal notranslate"><span class="pre">op(*x[,</span> <span class="pre">out],</span> <span class="pre">where=True,</span> <span class="pre">**kwargs)</span></code></p>
<p>Apply <cite>op</cite> to the arguments <cite>*x</cite> elementwise, broadcasting the arguments.</p>
<p>The broadcasting rules are:</p>
<ul class="simple">
<li><p>Dimensions of length 1 may be prepended to either array.</p></li>
<li><p>Arrays may be repeated along dimensions of length 1.</p></li>
</ul>
<dl class="simple">
<dt><a href="#id68"><span class="problematic" id="id69">*</span></a>x<span class="classifier">array_like</span></dt><dd><p>Input arrays.</p>
</dd>
<dt>out<span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>Alternate array object(s) in which to put the result; if provided, it
must have a shape that the inputs broadcast to. A tuple of arrays
(possible only as a keyword argument) must have length equal to the
number of outputs; use None for uninitialized outputs to be
allocated by the ufunc.</p>
</dd>
<dt>where<span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><a href="#id70"><span class="problematic" id="id71">**</span></a>kwargs</dt><dd><p>For other keyword-only arguments, see the <span class="xref std std-ref">ufunc docs</span>.</p>
</dd>
</dl>
<dl class="simple">
<dt>r<span class="classifier">ndarray or tuple of ndarray</span></dt><dd><p><cite>r</cite> will have the shape that the arrays in <cite>x</cite> broadcast to; if <cite>out</cite> is
provided, it will be returned. If not, <cite>r</cite> will be allocated and
may contain uninitialized values. If the function has more than one
output, then the result will be a tuple of arrays.</p>
</dd>
</dl>
<dl class="py method">
<dt id="numpy.ufunc.accumulate">
<code class="sig-name descname"><span class="pre">accumulate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ufunc.accumulate" title="Permalink to this definition">¶</a></dt>
<dd><p>Accumulate the result of applying the operator to all elements.</p>
<p>For a one-dimensional array, accumulate produces results equivalent to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">identity</span>        <span class="c1"># op = the ufunc being applied to A&#39;s  elements</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)):</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>
<span class="k">return</span> <span class="n">r</span>
</pre></div>
</div>
<p>For example, add.accumulate() is equivalent to np.cumsum().</p>
<p>For a multi-dimensional array, accumulate is applied along only one
axis (axis zero by default; see Examples below) so repeated use is
necessary if one wants to accumulate over multiple axes.</p>
<dl>
<dt>array<span class="classifier">array_like</span></dt><dd><p>The array to act on.</p>
</dd>
<dt>axis<span class="classifier">int, optional</span></dt><dd><p>The axis along which to apply the accumulation; default is zero.</p>
</dd>
<dt>dtype<span class="classifier">data-type code, optional</span></dt><dd><p>The data-type used to represent the intermediate results. Defaults
to the data-type of the output array if such is provided, or the
the data-type of the input array if no output array is provided.</p>
</dd>
<dt>out<span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If not provided or None,
a freshly-allocated array is returned. For consistency with
<code class="docutils literal notranslate"><span class="pre">ufunc.__call__</span></code>, if given as a keyword, this may be wrapped in a
1-element tuple.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.13.0: </span>Tuples are allowed for keyword argument.</p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>r<span class="classifier">ndarray</span></dt><dd><p>The accumulated values. If <cite>out</cite> was supplied, <cite>r</cite> is a reference to
<cite>out</cite>.</p>
</dd>
</dl>
<p>1-D array examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">accumulate</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="go">array([ 2,  5, 10])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">accumulate</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="go">array([ 2,  6, 30])</span>
</pre></div>
</div>
<p>2-D array examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span>
<span class="go">array([[1.,  0.],</span>
<span class="go">       [0.,  1.]])</span>
</pre></div>
</div>
<p>Accumulate along axis 0 (rows), down columns:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">array([[1.,  0.],</span>
<span class="go">       [1.,  1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="c1"># no axis specified = axis zero</span>
<span class="go">array([[1.,  0.],</span>
<span class="go">       [1.,  1.]])</span>
</pre></div>
</div>
<p>Accumulate along axis 1 (columns), through rows:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">array([[1.,  1.],</span>
<span class="go">       [0.,  1.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.ufunc.at">
<code class="sig-name descname"><span class="pre">at</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ufunc.at" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs unbuffered in place operation on operand ‘a’ for elements
specified by ‘indices’. For addition ufunc, this method is equivalent to
<code class="docutils literal notranslate"><span class="pre">a[indices]</span> <span class="pre">+=</span> <span class="pre">b</span></code>, except that results are accumulated for elements that
are indexed more than once. For example, <code class="docutils literal notranslate"><span class="pre">a[[0,0]]</span> <span class="pre">+=</span> <span class="pre">1</span></code> will only
increment the first element once because of buffering, whereas
<code class="docutils literal notranslate"><span class="pre">add.at(a,</span> <span class="pre">[0,0],</span> <span class="pre">1)</span></code> will increment the first element twice.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.0.</span></p>
</div>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>The array to perform in place operation on.</p>
</dd>
<dt>indices<span class="classifier">array_like or tuple</span></dt><dd><p>Array like index object or slice object for indexing into first
operand. If first operand has multiple dimensions, indices can be a
tuple of array like index objects or slice objects.</p>
</dd>
<dt>b<span class="classifier">array_like</span></dt><dd><p>Second operand for ufuncs requiring two operands. Operand must be
broadcastable over first operand after indexing or slicing.</p>
</dd>
</dl>
<p>Set items 0 and 1 to their negative values:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">negative</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([-1, -2,  3,  4])</span>
</pre></div>
</div>
<p>Increment items 0 and 1, and increment item 2 twice:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([2, 3, 5, 4])</span>
</pre></div>
</div>
<p>Add items 0 and 1 in first array to second array,
and store results in first array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([2, 4, 3, 4])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.ufunc.identity">
<code class="sig-name descname"><span class="pre">identity</span></code><a class="headerlink" href="#numpy.ufunc.identity" title="Permalink to this definition">¶</a></dt>
<dd><p>The identity value.</p>
<p>Data attribute containing the identity element for the ufunc, if it has one.
If it does not, the attribute value is None.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">identity</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">identity</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="o">.</span><span class="n">identity</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">identity</span><span class="p">)</span>
<span class="go">None</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.ufunc.nargs">
<code class="sig-name descname"><span class="pre">nargs</span></code><a class="headerlink" href="#numpy.ufunc.nargs" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of arguments.</p>
<p>Data attribute containing the number of arguments the ufunc takes, including
optional ones.</p>
<p>Typically this value will be one more than what you might expect because all
ufuncs take  the optional “out” argument.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">nargs</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">nargs</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="o">.</span><span class="n">nargs</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">nargs</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.ufunc.nin">
<code class="sig-name descname"><span class="pre">nin</span></code><a class="headerlink" href="#numpy.ufunc.nin" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of inputs.</p>
<p>Data attribute containing the number of arguments the ufunc treats as input.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">nin</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">nin</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="o">.</span><span class="n">nin</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">nin</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.ufunc.nout">
<code class="sig-name descname"><span class="pre">nout</span></code><a class="headerlink" href="#numpy.ufunc.nout" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of outputs.</p>
<p>Data attribute containing the number of arguments the ufunc treats as output.</p>
<p>Since all ufuncs can take output arguments, this will always be (at least) 1.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">nout</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">nout</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="o">.</span><span class="n">nout</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">nout</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.ufunc.ntypes">
<code class="sig-name descname"><span class="pre">ntypes</span></code><a class="headerlink" href="#numpy.ufunc.ntypes" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of types.</p>
<p>The number of numerical NumPy types - of which there are 18 total - on which
the ufunc can operate.</p>
<p>numpy.ufunc.types</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">ntypes</span>
<span class="go">18</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">ntypes</span>
<span class="go">18</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="o">.</span><span class="n">ntypes</span>
<span class="go">17</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">ntypes</span>
<span class="go">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="o">.</span><span class="n">ntypes</span>
<span class="go">14</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.ufunc.outer">
<code class="sig-name descname"><span class="pre">outer</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ufunc.outer" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the ufunc <cite>op</cite> to all pairs (a, b) with a in <cite>A</cite> and b in <cite>B</cite>.</p>
<p>Let <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">=</span> <span class="pre">A.ndim</span></code>, <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">B.ndim</span></code>. Then the result, <cite>C</cite>, of
<code class="docutils literal notranslate"><span class="pre">op.outer(A,</span> <span class="pre">B)</span></code> is an array of dimension M + N such that:</p>
<div class="math notranslate nohighlight">
\[C[i_0, ..., i_{M-1}, j_0, ..., j_{N-1}] =
op(A[i_0, ..., i_{M-1}], B[j_0, ..., j_{N-1}])\]</div>
<p>For <cite>A</cite> and <cite>B</cite> one-dimensional, this is equivalent to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">r</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="p">)):</span>
        <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>  <span class="c1"># op = ufunc in question</span>
</pre></div>
</div>
<dl class="simple">
<dt>A<span class="classifier">array_like</span></dt><dd><p>First array</p>
</dd>
<dt>B<span class="classifier">array_like</span></dt><dd><p>Second array</p>
</dd>
<dt>kwargs<span class="classifier">any</span></dt><dd><p>Arguments to pass on to the ufunc. Typically <cite>dtype</cite> or <cite>out</cite>.
See <cite>ufunc</cite> for a comprehensive overview of all available arguments.</p>
</dd>
</dl>
<dl class="simple">
<dt>r<span class="classifier">ndarray</span></dt><dd><p>Output array</p>
</dd>
</dl>
<dl>
<dt>numpy.outer<span class="classifier">A less powerful version of <code class="docutils literal notranslate"><span class="pre">np.multiply.outer</span></code></span></dt><dd><p>that <cite>ravel</cite>s all inputs to 1D. This exists
primarily for compatibility with old code.</p>
</dd>
<dt>tensordot<span class="classifier"><code class="docutils literal notranslate"><span class="pre">np.tensordot(a,</span> <span class="pre">b,</span> <span class="pre">axes=((),</span> <span class="pre">()))</span></code> and</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">np.multiply.outer(a,</span> <span class="pre">b)</span></code> behave same for all
dimensions of a and b.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">outer</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="go">array([[ 4,  5,  6],</span>
<span class="go">       [ 8, 10, 12],</span>
<span class="go">       [12, 15, 18]])</span>
</pre></div>
</div>
<p>A multi-dimensional example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">;</span> <span class="n">C</span>
<span class="go">(2, 3, 1, 4)</span>
<span class="go">array([[[[ 1,  2,  3,  4]],</span>
<span class="go">        [[ 2,  4,  6,  8]],</span>
<span class="go">        [[ 3,  6,  9, 12]]],</span>
<span class="go">       [[[ 4,  8, 12, 16]],</span>
<span class="go">        [[ 5, 10, 15, 20]],</span>
<span class="go">        [[ 6, 12, 18, 24]]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.ufunc.reduce">
<code class="sig-name descname"><span class="pre">reduce</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">array</span></em>, <em class="sig-param"><span class="pre">axis=0</span></em>, <em class="sig-param"><span class="pre">dtype=None</span></em>, <em class="sig-param"><span class="pre">out=None</span></em>, <em class="sig-param"><span class="pre">keepdims=False</span></em>, <em class="sig-param"><span class="pre">initial=&lt;no</span> <span class="pre">value&gt;</span></em>, <em class="sig-param"><span class="pre">where=True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ufunc.reduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduces <cite>array</cite>’s dimension by one, by applying ufunc along one axis.</p>
<p>Let <span class="math notranslate nohighlight">\(array.shape = (N_0, ..., N_i, ..., N_{M-1})\)</span>.  Then
<span class="math notranslate nohighlight">\(ufunc.reduce(array, axis=i)[k_0, ..,k_{i-1}, k_{i+1}, .., k_{M-1}]\)</span> =
the result of iterating <cite>j</cite> over <span class="math notranslate nohighlight">\(range(N_i)\)</span>, cumulatively applying
ufunc to each <span class="math notranslate nohighlight">\(array[k_0, ..,k_{i-1}, j, k_{i+1}, .., k_{M-1}]\)</span>.
For a one-dimensional array, reduce produces results equivalent to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">r</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">identity</span> <span class="c1"># op = ufunc</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)):</span>
  <span class="n">r</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="k">return</span> <span class="n">r</span>
</pre></div>
</div>
<p>For example, add.reduce() is equivalent to sum().</p>
<dl>
<dt>array<span class="classifier">array_like</span></dt><dd><p>The array to act on.</p>
</dd>
<dt>axis<span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Axis or axes along which a reduction is performed.
The default (<cite>axis</cite> = 0) is perform a reduction over the first
dimension of the input array. <cite>axis</cite> may be negative, in
which case it counts from the last to the first axis.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<p>If this is None, a reduction is performed over all the axes.
If this is a tuple of ints, a reduction is performed on multiple
axes, instead of a single axis or all the axes as before.</p>
<p>For operations which are either not commutative or not associative,
doing a reduction over multiple axes is not well-defined. The
ufuncs do not currently raise an exception in this case, but will
likely do so in the future.</p>
</dd>
<dt>dtype<span class="classifier">data-type code, optional</span></dt><dd><p>The type used to represent the intermediate results. Defaults
to the data-type of the output array if this is provided, or
the data-type of the input array if no output array is provided.</p>
</dd>
<dt>out<span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If not provided or None,
a freshly-allocated array is returned. For consistency with
<code class="docutils literal notranslate"><span class="pre">ufunc.__call__</span></code>, if given as a keyword, this may be wrapped in a
1-element tuple.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.13.0: </span>Tuples are allowed for keyword argument.</p>
</div>
</dd>
<dt>keepdims<span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original <cite>array</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
</dd>
<dt>initial<span class="classifier">scalar, optional</span></dt><dd><p>The value with which to start the reduction.
If the ufunc has no identity or the dtype is object, this defaults
to None - otherwise it defaults to ufunc.identity.
If <code class="docutils literal notranslate"><span class="pre">None</span></code> is given, the first element of the reduction is used,
and an error is thrown if the reduction is empty.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.15.0.</span></p>
</div>
</dd>
<dt>where<span class="classifier">array_like of bool, optional</span></dt><dd><p>A boolean array which is broadcasted to match the dimensions
of <cite>array</cite>, and selects elements to include in the reduction. Note
that for ufuncs like <code class="docutils literal notranslate"><span class="pre">minimum</span></code> that do not have an identity
defined, one has to pass in also <code class="docutils literal notranslate"><span class="pre">initial</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.17.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>r<span class="classifier">ndarray</span></dt><dd><p>The reduced array. If <cite>out</cite> was supplied, <cite>r</cite> is a reference to it.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">reduce</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="go">30</span>
</pre></div>
</div>
<p>A multi-dimensional array example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span>
<span class="go">array([[[0, 1],</span>
<span class="go">        [2, 3]],</span>
<span class="go">       [[4, 5],</span>
<span class="go">        [6, 7]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">array([[ 4,  6],</span>
<span class="go">       [ 8, 10]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="c1"># confirm: default axis value is 0</span>
<span class="go">array([[ 4,  6],</span>
<span class="go">       [ 8, 10]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">array([[ 2,  4],</span>
<span class="go">       [10, 12]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([[ 1,  5],</span>
<span class="go">       [ 9, 13]])</span>
</pre></div>
</div>
<p>You can use the <code class="docutils literal notranslate"><span class="pre">initial</span></code> keyword argument to initialize the reduction
with a different value, and <code class="docutils literal notranslate"><span class="pre">where</span></code> to select specific elements to include:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">([</span><span class="mi">10</span><span class="p">],</span> <span class="n">initial</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">initial</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="go">array([14., 14.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">10.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">where</span><span class="o">=~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
<span class="go">20.0</span>
</pre></div>
</div>
<p>Allows reductions of empty arrays where they would normally fail, i.e.
for ufuncs without an identity.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="o">.</span><span class="n">reduce</span><span class="p">([],</span> <span class="n">initial</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="go">inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="o">.</span><span class="n">reduce</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">],</span> <span class="p">[</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">]],</span> <span class="n">initial</span><span class="o">=</span><span class="mf">10.</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">])</span>
<span class="go">array([ 1., 10.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="o">.</span><span class="n">reduce</span><span class="p">([])</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">ValueError</span>: <span class="n">zero-size array to reduction operation minimum which has no identity</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="numpy.ufunc.reduceat">
<code class="sig-name descname"><span class="pre">reduceat</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ufunc.reduceat" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a (local) reduce with specified slices over a single axis.</p>
<p>For i in <code class="docutils literal notranslate"><span class="pre">range(len(indices))</span></code>, <cite>reduceat</cite> computes
<code class="docutils literal notranslate"><span class="pre">ufunc.reduce(array[indices[i]:indices[i+1]])</span></code>, which becomes the i-th
generalized “row” parallel to <cite>axis</cite> in the final result (i.e., in a
2-D array, for example, if <cite>axis = 0</cite>, it becomes the i-th row, but if
<cite>axis = 1</cite>, it becomes the i-th column).  There are three exceptions to this:</p>
<ul class="simple">
<li><p>when <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">=</span> <span class="pre">len(indices)</span> <span class="pre">-</span> <span class="pre">1</span></code> (so for the last index),
<code class="docutils literal notranslate"><span class="pre">indices[i+1]</span> <span class="pre">=</span> <span class="pre">array.shape[axis]</span></code>.</p></li>
<li><p>if <code class="docutils literal notranslate"><span class="pre">indices[i]</span> <span class="pre">&gt;=</span> <span class="pre">indices[i</span> <span class="pre">+</span> <span class="pre">1]</span></code>, the i-th generalized “row” is
simply <code class="docutils literal notranslate"><span class="pre">array[indices[i]]</span></code>.</p></li>
<li><p>if <code class="docutils literal notranslate"><span class="pre">indices[i]</span> <span class="pre">&gt;=</span> <span class="pre">len(array)</span></code> or <code class="docutils literal notranslate"><span class="pre">indices[i]</span> <span class="pre">&lt;</span> <span class="pre">0</span></code>, an error is raised.</p></li>
</ul>
<p>The shape of the output depends on the size of <cite>indices</cite>, and may be
larger than <cite>array</cite> (this happens if <code class="docutils literal notranslate"><span class="pre">len(indices)</span> <span class="pre">&gt;</span> <span class="pre">array.shape[axis]</span></code>).</p>
<dl>
<dt>array<span class="classifier">array_like</span></dt><dd><p>The array to act on.</p>
</dd>
<dt>indices<span class="classifier">array_like</span></dt><dd><p>Paired indices, comma separated (not colon), specifying slices to
reduce.</p>
</dd>
<dt>axis<span class="classifier">int, optional</span></dt><dd><p>The axis along which to apply the reduceat.</p>
</dd>
<dt>dtype<span class="classifier">data-type code, optional</span></dt><dd><p>The type used to represent the intermediate results. Defaults
to the data type of the output array if this is provided, or
the data type of the input array if no output array is provided.</p>
</dd>
<dt>out<span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If not provided or None,
a freshly-allocated array is returned. For consistency with
<code class="docutils literal notranslate"><span class="pre">ufunc.__call__</span></code>, if given as a keyword, this may be wrapped in a
1-element tuple.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.13.0: </span>Tuples are allowed for keyword argument.</p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>r<span class="classifier">ndarray</span></dt><dd><p>The reduced values. If <cite>out</cite> was supplied, <cite>r</cite> is a reference to
<cite>out</cite>.</p>
</dd>
</dl>
<p>A descriptive example:</p>
<p>If <cite>array</cite> is 1-D, the function <cite>ufunc.accumulate(array)</cite> is the same as
<code class="docutils literal notranslate"><span class="pre">ufunc.reduceat(array,</span> <span class="pre">indices)[::2]</span></code> where <cite>indices</cite> is
<code class="docutils literal notranslate"><span class="pre">range(len(array)</span> <span class="pre">-</span> <span class="pre">1)</span></code> with a zero placed
in every other element:
<code class="docutils literal notranslate"><span class="pre">indices</span> <span class="pre">=</span> <span class="pre">zeros(2</span> <span class="pre">*</span> <span class="pre">len(array)</span> <span class="pre">-</span> <span class="pre">1)</span></code>,
<code class="docutils literal notranslate"><span class="pre">indices[1::2]</span> <span class="pre">=</span> <span class="pre">range(1,</span> <span class="pre">len(array))</span></code>.</p>
<p>Don’t be fooled by this attribute’s name: <cite>reduceat(array)</cite> is not
necessarily smaller than <cite>array</cite>.</p>
<p>To take the running sum of four successive values:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">8</span><span class="p">),[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">])[::</span><span class="mi">2</span><span class="p">]</span>
<span class="go">array([ 6, 10, 14, 18])</span>
</pre></div>
</div>
<p>A 2-D example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[ 0.,   1.,   2.,   3.],</span>
<span class="go">       [ 4.,   5.,   6.,   7.],</span>
<span class="go">       [ 8.,   9.,  10.,  11.],</span>
<span class="go">       [12.,  13.,  14.,  15.]])</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># reduce such that the result has the following five rows:</span>
<span class="c1"># [row1 + row2 + row3]</span>
<span class="c1"># [row4]</span>
<span class="c1"># [row2]</span>
<span class="c1"># [row3]</span>
<span class="c1"># [row1 + row2 + row3 + row4]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">array([[12.,  15.,  18.,  21.],</span>
<span class="go">       [12.,  13.,  14.,  15.],</span>
<span class="go">       [ 4.,   5.,   6.,   7.],</span>
<span class="go">       [ 8.,   9.,  10.,  11.],</span>
<span class="go">       [24.,  28.,  32.,  36.]])</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># reduce such that result has the following two columns:</span>
<span class="c1"># [col1 * col2 * col3, col4]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">array([[   0.,     3.],</span>
<span class="go">       [ 120.,     7.],</span>
<span class="go">       [ 720.,    11.],</span>
<span class="go">       [2184.,    15.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.ufunc.signature">
<code class="sig-name descname"><span class="pre">signature</span></code><a class="headerlink" href="#numpy.ufunc.signature" title="Permalink to this definition">¶</a></dt>
<dd><p>Definition of the core elements a generalized ufunc operates on.</p>
<p>The signature determines how the dimensions of each input/output array
are split into core and loop dimensions:</p>
<ol class="arabic simple">
<li><p>Each dimension in the signature is matched to a dimension of the
corresponding passed-in array, starting from the end of the shape tuple.</p></li>
<li><p>Core dimensions assigned to the same label in the signature must have
exactly matching sizes, no broadcasting is performed.</p></li>
<li><p>The core dimensions are removed from all inputs and the remaining
dimensions are broadcast together, defining the loop dimensions.</p></li>
</ol>
<p>Generalized ufuncs are used internally in many linalg functions, and in
the testing suite; the examples below are taken from these.
For ufuncs that operate on scalars, the signature is None, which is
equivalent to ‘()’ for every argument.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">umath_tests</span><span class="o">.</span><span class="n">matrix_multiply</span><span class="o">.</span><span class="n">signature</span>
<span class="go">&#39;(m,n),(n,p)-&gt;(m,p)&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">_umath_linalg</span><span class="o">.</span><span class="n">det</span><span class="o">.</span><span class="n">signature</span>
<span class="go">&#39;(m,m)-&gt;()&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">signature</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True  # equivalent to &#39;(),()-&gt;()&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.ufunc.types">
<code class="sig-name descname"><span class="pre">types</span></code><a class="headerlink" href="#numpy.ufunc.types" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list with types grouped input-&gt;output.</p>
<p>Data attribute listing the data-type “Domain-Range” groupings the ufunc can
deliver. The data-types are given using the character codes.</p>
<p>numpy.ufunc.ntypes</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">types</span>
<span class="go">[&#39;??-&gt;?&#39;, &#39;bb-&gt;b&#39;, &#39;BB-&gt;B&#39;, &#39;hh-&gt;h&#39;, &#39;HH-&gt;H&#39;, &#39;ii-&gt;i&#39;, &#39;II-&gt;I&#39;, &#39;ll-&gt;l&#39;,</span>
<span class="go">&#39;LL-&gt;L&#39;, &#39;qq-&gt;q&#39;, &#39;QQ-&gt;Q&#39;, &#39;ff-&gt;f&#39;, &#39;dd-&gt;d&#39;, &#39;gg-&gt;g&#39;, &#39;FF-&gt;F&#39;, &#39;DD-&gt;D&#39;,</span>
<span class="go">&#39;GG-&gt;G&#39;, &#39;OO-&gt;O&#39;]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">types</span>
<span class="go">[&#39;??-&gt;?&#39;, &#39;bb-&gt;b&#39;, &#39;BB-&gt;B&#39;, &#39;hh-&gt;h&#39;, &#39;HH-&gt;H&#39;, &#39;ii-&gt;i&#39;, &#39;II-&gt;I&#39;, &#39;ll-&gt;l&#39;,</span>
<span class="go">&#39;LL-&gt;L&#39;, &#39;qq-&gt;q&#39;, &#39;QQ-&gt;Q&#39;, &#39;ff-&gt;f&#39;, &#39;dd-&gt;d&#39;, &#39;gg-&gt;g&#39;, &#39;FF-&gt;F&#39;, &#39;DD-&gt;D&#39;,</span>
<span class="go">&#39;GG-&gt;G&#39;, &#39;OO-&gt;O&#39;]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="o">.</span><span class="n">types</span>
<span class="go">[&#39;bb-&gt;b&#39;, &#39;BB-&gt;B&#39;, &#39;hh-&gt;h&#39;, &#39;HH-&gt;H&#39;, &#39;ii-&gt;i&#39;, &#39;II-&gt;I&#39;, &#39;ll-&gt;l&#39;, &#39;LL-&gt;L&#39;,</span>
<span class="go">&#39;qq-&gt;q&#39;, &#39;QQ-&gt;Q&#39;, &#39;ff-&gt;f&#39;, &#39;dd-&gt;d&#39;, &#39;gg-&gt;g&#39;, &#39;FF-&gt;F&#39;, &#39;DD-&gt;D&#39;, &#39;GG-&gt;G&#39;,</span>
<span class="go">&#39;OO-&gt;O&#39;]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">types</span>
<span class="go">[&#39;f-&gt;f&#39;, &#39;d-&gt;d&#39;, &#39;g-&gt;g&#39;, &#39;F-&gt;F&#39;, &#39;D-&gt;D&#39;, &#39;G-&gt;G&#39;, &#39;O-&gt;O&#39;]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="o">.</span><span class="n">types</span>
<span class="go">[&#39;bb-&gt;b&#39;, &#39;BB-&gt;B&#39;, &#39;hh-&gt;h&#39;, &#39;HH-&gt;H&#39;, &#39;ii-&gt;i&#39;, &#39;II-&gt;I&#39;, &#39;ll-&gt;l&#39;, &#39;LL-&gt;L&#39;,</span>
<span class="go">&#39;qq-&gt;q&#39;, &#39;QQ-&gt;Q&#39;, &#39;ff-&gt;f&#39;, &#39;dd-&gt;d&#39;, &#39;gg-&gt;g&#39;, &#39;OO-&gt;O&#39;]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py attribute">
<dt id="numpy.uint">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">uint</span></code><a class="headerlink" href="#numpy.uint" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.uint64" title="numpy.uint64"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.uint64</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.uint0">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">uint0</span></code><a class="headerlink" href="#numpy.uint0" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.uint64" title="numpy.uint64"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.uint64</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt id="numpy.uint16">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">uint16</span></code><a class="headerlink" href="#numpy.uint16" title="Permalink to this definition">¶</a></dt>
<dd><p>Unsigned integer type, compatible with C <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Character code</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">'H'</span></code></p>
</dd>
<dt class="field-even">Canonical name</dt>
<dd class="field-even"><p><cite>numpy.ushort</cite></p>
</dd>
<dt class="field-odd">Alias on this platform (Linux x86_64)</dt>
<dd class="field-odd"><p><cite>numpy.uint16</cite>: 16-bit unsigned integer (<code class="docutils literal notranslate"><span class="pre">0</span></code> to <code class="docutils literal notranslate"><span class="pre">65_535</span></code>).</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="numpy.uint32">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">uint32</span></code><a class="headerlink" href="#numpy.uint32" title="Permalink to this definition">¶</a></dt>
<dd><p>Unsigned integer type, compatible with C <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Character code</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">'I'</span></code></p>
</dd>
<dt class="field-even">Canonical name</dt>
<dd class="field-even"><p><cite>numpy.uintc</cite></p>
</dd>
<dt class="field-odd">Alias on this platform (Linux x86_64)</dt>
<dd class="field-odd"><p><cite>numpy.uint32</cite>: 32-bit unsigned integer (<code class="docutils literal notranslate"><span class="pre">0</span></code> to <code class="docutils literal notranslate"><span class="pre">4_294_967_295</span></code>).</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="numpy.uint64">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">uint64</span></code><a class="headerlink" href="#numpy.uint64" title="Permalink to this definition">¶</a></dt>
<dd><p>Unsigned integer type, compatible with C <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Character code</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">'L'</span></code></p>
</dd>
<dt class="field-even">Canonical name</dt>
<dd class="field-even"><p><cite>numpy.uint</cite></p>
</dd>
<dt class="field-odd">Alias on this platform (Linux x86_64)</dt>
<dd class="field-odd"><p><cite>numpy.uint64</cite>: 64-bit unsigned integer (<code class="docutils literal notranslate"><span class="pre">0</span></code> to <code class="docutils literal notranslate"><span class="pre">18_446_744_073_709_551_615</span></code>).</p>
</dd>
<dt class="field-even">Alias on this platform (Linux x86_64)</dt>
<dd class="field-even"><p><cite>numpy.uintp</cite>: Unsigned integer large enough to fit pointer, compatible with C <code class="docutils literal notranslate"><span class="pre">uintptr_t</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="numpy.uint8">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">uint8</span></code><a class="headerlink" href="#numpy.uint8" title="Permalink to this definition">¶</a></dt>
<dd><p>Unsigned integer type, compatible with C <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Character code</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">'B'</span></code></p>
</dd>
<dt class="field-even">Canonical name</dt>
<dd class="field-even"><p><cite>numpy.ubyte</cite></p>
</dd>
<dt class="field-odd">Alias on this platform (Linux x86_64)</dt>
<dd class="field-odd"><p><cite>numpy.uint8</cite>: 8-bit unsigned integer (<code class="docutils literal notranslate"><span class="pre">0</span></code> to <code class="docutils literal notranslate"><span class="pre">255</span></code>).</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.uintc">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">uintc</span></code><a class="headerlink" href="#numpy.uintc" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.uint32" title="numpy.uint32"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.uint32</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.uintp">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">uintp</span></code><a class="headerlink" href="#numpy.uintp" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.uint64" title="numpy.uint64"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.uint64</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt id="numpy.ulonglong">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">ulonglong</span></code><a class="headerlink" href="#numpy.ulonglong" title="Permalink to this definition">¶</a></dt>
<dd><p>Signed integer type, compatible with C <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Character code</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">'Q'</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.unicode_">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">unicode_</span></code><a class="headerlink" href="#numpy.unicode_" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.str_" title="numpy.str_"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.str_</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="numpy.union1d">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">union1d</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ar1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ar2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.union1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the union of two arrays.</p>
<p>Return the unique, sorted array of values that are in either of the two
input arrays.</p>
<dl class="simple">
<dt>ar1, ar2<span class="classifier">array_like</span></dt><dd><p>Input arrays. They are flattened if they are not already 1D.</p>
</dd>
</dl>
<dl class="simple">
<dt>union1d<span class="classifier">ndarray</span></dt><dd><p>Unique, sorted union of the input arrays.</p>
</dd>
</dl>
<dl class="simple">
<dt>numpy.lib.arraysetops<span class="classifier">Module with a number of other functions for</span></dt><dd><p>performing set operations on arrays.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">union1d</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">array([-2, -1,  0,  1,  2])</span>
</pre></div>
</div>
<p>To find the union of more than two arrays, use functools.reduce:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">reduce</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reduce</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">union1d</span><span class="p">,</span> <span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">array([1, 2, 3, 4, 6])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.unique">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">unique</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ar</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_inverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_counts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.unique" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the unique elements of an array.</p>
<p>Returns the sorted unique elements of an array. There are three optional
outputs in addition to the unique elements:</p>
<ul class="simple">
<li><p>the indices of the input array that give the unique values</p></li>
<li><p>the indices of the unique array that reconstruct the input array</p></li>
<li><p>the number of times each unique value comes up in the input array</p></li>
</ul>
<dl>
<dt>ar<span class="classifier">array_like</span></dt><dd><p>Input array. Unless <cite>axis</cite> is specified, this will be flattened if it
is not already 1-D.</p>
</dd>
<dt>return_index<span class="classifier">bool, optional</span></dt><dd><p>If True, also return the indices of <cite>ar</cite> (along the specified axis,
if provided, or in the flattened array) that result in the unique array.</p>
</dd>
<dt>return_inverse<span class="classifier">bool, optional</span></dt><dd><p>If True, also return the indices of the unique array (for the specified
axis, if provided) that can be used to reconstruct <cite>ar</cite>.</p>
</dd>
<dt>return_counts<span class="classifier">bool, optional</span></dt><dd><p>If True, also return the number of times each unique item appears
in <cite>ar</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.9.0.</span></p>
</div>
</dd>
<dt>axis<span class="classifier">int or None, optional</span></dt><dd><p>The axis to operate on. If None, <cite>ar</cite> will be flattened. If an integer,
the subarrays indexed by the given axis will be flattened and treated
as the elements of a 1-D array with the dimension of the given axis,
see the notes for more details.  Object arrays or structured arrays
that contain objects are not supported if the <cite>axis</cite> kwarg is used. The
default is None.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.13.0.</span></p>
</div>
</dd>
</dl>
<dl>
<dt>unique<span class="classifier">ndarray</span></dt><dd><p>The sorted unique values.</p>
</dd>
<dt>unique_indices<span class="classifier">ndarray, optional</span></dt><dd><p>The indices of the first occurrences of the unique values in the
original array. Only provided if <cite>return_index</cite> is True.</p>
</dd>
<dt>unique_inverse<span class="classifier">ndarray, optional</span></dt><dd><p>The indices to reconstruct the original array from the
unique array. Only provided if <cite>return_inverse</cite> is True.</p>
</dd>
<dt>unique_counts<span class="classifier">ndarray, optional</span></dt><dd><p>The number of times each of the unique values comes up in the
original array. Only provided if <cite>return_counts</cite> is True.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.9.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>numpy.lib.arraysetops<span class="classifier">Module with a number of other functions for</span></dt><dd><p>performing set operations on arrays.</p>
</dd>
</dl>
<p>repeat : Repeat elements of an array.</p>
<p>When an axis is specified the subarrays indexed by the axis are sorted.
This is done by making the specified axis the first dimension of the array
(move the axis to the first dimension to keep the order of the other axes)
and then flattening the subarrays in C order. The flattened subarrays are
then viewed as a structured type with each element given a label, with the
effect that we end up with a 1-D array of structured types that can be
treated in the same way as any other 1-D array. The result is that the
flattened subarrays are sorted in lexicographic order starting with the
first element.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">array([1, 2, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([1, 2, 3])</span>
</pre></div>
</div>
<p>Return the unique rows of a 2D array</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[1, 0, 0], [2, 3, 4]])</span>
</pre></div>
</div>
<p>Return the indices of the original array that give the unique values:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span>
<span class="go">array([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], dtype=&#39;&lt;U1&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span>
<span class="go">array([0, 1, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
<span class="go">array([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], dtype=&#39;&lt;U1&#39;)</span>
</pre></div>
</div>
<p>Reconstruct the input array from the unique values and inverse:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span>
<span class="go">array([1, 2, 3, 4, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span>
<span class="go">array([0, 1, 4, 3, 1, 2, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
<span class="go">array([1, 2, 6, 4, 2, 3, 2])</span>
</pre></div>
</div>
<p>Reconstruct the input values from the unique values and counts:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span>
<span class="go">array([1, 2, 3, 4, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">counts</span>
<span class="go">array([1, 3, 1, 1, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">counts</span><span class="p">)</span>
<span class="go">array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.unpackbits">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">unpackbits</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bitorder</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'big'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.unpackbits" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpacks elements of a uint8 array into a binary-valued output array.</p>
<p>Each element of <cite>a</cite> represents a bit-field that should be unpacked
into a binary-valued output array. The shape of the output array is
either 1-D (if <cite>axis</cite> is <code class="docutils literal notranslate"><span class="pre">None</span></code>) or the same shape as the input
array with unpacking done along the axis specified.</p>
<dl>
<dt>a<span class="classifier">ndarray, uint8 type</span></dt><dd><p>Input array.</p>
</dd>
<dt>axis<span class="classifier">int, optional</span></dt><dd><p>The dimension over which bit-unpacking is done.
<code class="docutils literal notranslate"><span class="pre">None</span></code> implies unpacking the flattened array.</p>
</dd>
<dt>count<span class="classifier">int or None, optional</span></dt><dd><p>The number of elements to unpack along <cite>axis</cite>, provided as a way
of undoing the effect of packing a size that is not a multiple
of eight. A non-negative number means to only unpack <cite>count</cite>
bits. A negative number means to trim off that many bits from
the end. <code class="docutils literal notranslate"><span class="pre">None</span></code> means to unpack the entire array (the
default). Counts larger than the available number of bits will
add zero padding to the output. Negative counts must not
exceed the available number of bits.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.17.0.</span></p>
</div>
</dd>
<dt>bitorder<span class="classifier">{‘big’, ‘little’}, optional</span></dt><dd><p>The order of the returned bits. ‘big’ will mimic bin(val),
<code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">=</span> <span class="pre">0b00000011</span> <span class="pre">=&gt;</span> <span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">1]</span></code>, ‘little’ will reverse
the order to <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0]</span></code>.
Defaults to ‘big’.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.17.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>unpacked<span class="classifier">ndarray, uint8 type</span></dt><dd><p>The elements are binary-valued (0 or 1).</p>
</dd>
</dl>
<dl class="simple">
<dt>packbits<span class="classifier">Packs the elements of a binary-valued array into bits in</span></dt><dd><p>a uint8 array.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">23</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[ 2],</span>
<span class="go">       [ 7],</span>
<span class="go">       [23]], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unpackbits</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 1, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 1, 1, 1],</span>
<span class="go">       [0, 0, 0, 1, 0, 1, 1, 1]], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unpackbits</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">count</span><span class="o">=-</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">array([[0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 0]], dtype=uint8)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">packbits</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">unpackbits</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 1, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 1, 1, 1],</span>
<span class="go">       [0, 0, 0, 1, 0, 1, 1, 1],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">unpackbits</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.unravel_index">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">unravel_index</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'C'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.unravel_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a flat index or array of flat indices into a tuple
of coordinate arrays.</p>
<dl>
<dt>indices<span class="classifier">array_like</span></dt><dd><p>An integer array whose elements are indices into the flattened
version of an array of dimensions <code class="docutils literal notranslate"><span class="pre">shape</span></code>. Before version 1.6.0,
this function accepted just one index value.</p>
</dd>
<dt>shape<span class="classifier">tuple of ints</span></dt><dd><p>The shape of the array to use for unraveling <code class="docutils literal notranslate"><span class="pre">indices</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.16.0: </span>Renamed from <code class="docutils literal notranslate"><span class="pre">dims</span></code> to <code class="docutils literal notranslate"><span class="pre">shape</span></code>.</p>
</div>
</dd>
<dt>order<span class="classifier">{‘C’, ‘F’}, optional</span></dt><dd><p>Determines whether the indices should be viewed as indexing in
row-major (C-style) or column-major (Fortran-style) order.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.6.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>unraveled_coords<span class="classifier">tuple of ndarray</span></dt><dd><p>Each array in the tuple has the same shape as the <code class="docutils literal notranslate"><span class="pre">indices</span></code>
array.</p>
</dd>
</dl>
<p>ravel_multi_index</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">([</span><span class="mi">22</span><span class="p">,</span> <span class="mi">41</span><span class="p">,</span> <span class="mi">37</span><span class="p">],</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="go">(array([3, 6, 6]), array([4, 5, 1]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">([</span><span class="mi">31</span><span class="p">,</span> <span class="mi">41</span><span class="p">,</span> <span class="mi">13</span><span class="p">],</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
<span class="go">(array([3, 6, 6]), array([4, 5, 1]))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="mi">1621</span><span class="p">,</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">))</span>
<span class="go">(3, 1, 4, 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt id="numpy.unsignedinteger">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">unsignedinteger</span></code><a class="headerlink" href="#numpy.unsignedinteger" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class of all unsigned integer scalar types.</p>
</dd></dl>

<dl class="py function">
<dt id="numpy.unwrap">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">unwrap</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">discont</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">period</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6.283185307179586</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.unwrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Unwrap by taking the complement of large deltas with respect to the period.</p>
<p>This unwraps a signal <cite>p</cite> by changing elements which have an absolute
difference from their predecessor of more than <code class="docutils literal notranslate"><span class="pre">max(discont,</span> <span class="pre">period/2)</span></code>
to their <cite>period</cite>-complementary values.</p>
<p>For the default case where <cite>period</cite> is <span class="math notranslate nohighlight">\(2\pi\)</span> and is <cite>discont</cite> is
<span class="math notranslate nohighlight">\(\pi\)</span>, this unwraps a radian phase <cite>p</cite> such that adjacent differences
are never greater than <span class="math notranslate nohighlight">\(\pi\)</span> by adding <span class="math notranslate nohighlight">\(2k\pi\)</span> for some
integer <span class="math notranslate nohighlight">\(k\)</span>.</p>
<dl>
<dt>p<span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt>discont<span class="classifier">float, optional</span></dt><dd><p>Maximum discontinuity between values, default is <code class="docutils literal notranslate"><span class="pre">period/2</span></code>. 
Values below <code class="docutils literal notranslate"><span class="pre">period/2</span></code> are treated as if they were <code class="docutils literal notranslate"><span class="pre">period/2</span></code>.
To have an effect different from the default, <cite>discont</cite> should be
larger than <code class="docutils literal notranslate"><span class="pre">period/2</span></code>.</p>
</dd>
<dt>axis<span class="classifier">int, optional</span></dt><dd><p>Axis along which unwrap will operate, default is the last axis.</p>
</dd>
<dt>period: float, optional</dt><dd><p>Size of the range over which the input wraps. By default, it is
<code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">pi</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.21.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>Output array.</p>
</dd>
</dl>
<p>rad2deg, deg2rad</p>
<p>If the discontinuity in <cite>p</cite> is smaller than <code class="docutils literal notranslate"><span class="pre">period/2</span></code>, 
but larger than <cite>discont</cite>, no unwrapping is done because taking 
the complement would only make the discontinuity larger.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phase</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phase</span>
<span class="go">array([ 0.        ,  0.78539816,  1.57079633,  5.49778714,  6.28318531]) # may vary</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span>
<span class="go">array([ 0.        ,  0.78539816,  1.57079633, -0.78539816,  0.        ]) # may vary</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">unwrap</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">period</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">array([0, 1, 2, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">unwrap</span><span class="p">([</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">period</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="go">array([1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">unwrap</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="n">period</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">array([2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phase_deg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span> <span class="p">,</span><span class="mi">720</span><span class="p">,</span> <span class="mi">19</span><span class="p">),</span> <span class="mi">360</span><span class="p">)</span> <span class="o">-</span> <span class="mi">180</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">phase_deg</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="mi">360</span><span class="p">)</span>
<span class="go">array([-180., -140., -100.,  -60.,  -20.,   20.,   60.,  100.,  140.,</span>
<span class="go">        180.,  220.,  260.,  300.,  340.,  380.,  420.,  460.,  500.,</span>
<span class="go">        540.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.ushort">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">ushort</span></code><a class="headerlink" href="#numpy.ushort" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.uint16" title="numpy.uint16"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.uint16</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="numpy.vander">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">vander</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">increasing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.vander" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a Vandermonde matrix.</p>
<p>The columns of the output matrix are powers of the input vector. The
order of the powers is determined by the <cite>increasing</cite> boolean argument.
Specifically, when <cite>increasing</cite> is False, the <cite>i</cite>-th output column is
the input vector raised element-wise to the power of <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">i</span> <span class="pre">-</span> <span class="pre">1</span></code>. Such
a matrix with a geometric progression in each row is named for Alexandre-
Theophile Vandermonde.</p>
<dl>
<dt>x<span class="classifier">array_like</span></dt><dd><p>1-D input array.</p>
</dd>
<dt>N<span class="classifier">int, optional</span></dt><dd><p>Number of columns in the output.  If <cite>N</cite> is not specified, a square
array is returned (<code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">len(x)</span></code>).</p>
</dd>
<dt>increasing<span class="classifier">bool, optional</span></dt><dd><p>Order of the powers of the columns.  If True, the powers increase
from left to right, if False (the default) they are reversed.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.9.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>Vandermonde matrix.  If <cite>increasing</cite> is False, the first column is
<code class="docutils literal notranslate"><span class="pre">x^(N-1)</span></code>, the second <code class="docutils literal notranslate"><span class="pre">x^(N-2)</span></code> and so forth. If <cite>increasing</cite> is
True, the columns are <code class="docutils literal notranslate"><span class="pre">x^0,</span> <span class="pre">x^1,</span> <span class="pre">...,</span> <span class="pre">x^(N-1)</span></code>.</p>
</dd>
</dl>
<p>polynomial.polynomial.polyvander</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vander</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="go">array([[ 1,  1,  1],</span>
<span class="go">       [ 4,  2,  1],</span>
<span class="go">       [ 9,  3,  1],</span>
<span class="go">       [25,  5,  1]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)])</span>
<span class="go">array([[ 1,  1,  1],</span>
<span class="go">       [ 4,  2,  1],</span>
<span class="go">       [ 9,  3,  1],</span>
<span class="go">       [25,  5,  1]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vander</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([[  1,   1,   1,   1],</span>
<span class="go">       [  8,   4,   2,   1],</span>
<span class="go">       [ 27,   9,   3,   1],</span>
<span class="go">       [125,  25,   5,   1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vander</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">increasing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([[  1,   1,   1,   1],</span>
<span class="go">       [  1,   2,   4,   8],</span>
<span class="go">       [  1,   3,   9,  27],</span>
<span class="go">       [  1,   5,  25, 125]])</span>
</pre></div>
</div>
<p>The determinant of a square Vandermonde matrix is the product
of the differences between the values of the input vector:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vander</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">48.000000000000043 # may vary</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">5</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">5</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">5</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">48</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.var">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">var</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">a</span></em>, <em class="sig-param"><span class="pre">axis=None</span></em>, <em class="sig-param"><span class="pre">dtype=None</span></em>, <em class="sig-param"><span class="pre">out=None</span></em>, <em class="sig-param"><span class="pre">ddof=0</span></em>, <em class="sig-param"><span class="pre">keepdims=&lt;no</span> <span class="pre">value&gt;</span></em>, <em class="sig-param"><span class="pre">*</span></em>, <em class="sig-param"><span class="pre">where=&lt;no</span> <span class="pre">value&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.var" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the variance along the specified axis.</p>
<p>Returns the variance of the array elements, a measure of the spread of a
distribution.  The variance is computed for the flattened array by
default, otherwise over the specified axis.</p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Array containing numbers whose variance is desired.  If <cite>a</cite> is not an
array, a conversion is attempted.</p>
</dd>
<dt>axis<span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Axis or axes along which the variance is computed.  The default is to
compute the variance of the flattened array.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<p>If this is a tuple of ints, a variance is performed over multiple axes,
instead of a single axis or all the axes as before.</p>
</dd>
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>Type to use in computing the variance.  For arrays of integer type
the default is <cite>float64</cite>; for arrays of float types it is the same as
the array type.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Alternate output array in which to place the result.  It must have
the same shape as the expected output, but the type is cast if
necessary.</p>
</dd>
<dt>ddof<span class="classifier">int, optional</span></dt><dd><p>“Delta Degrees of Freedom”: the divisor used in the calculation is
<code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">ddof</span></code>, where <code class="docutils literal notranslate"><span class="pre">N</span></code> represents the number of elements. By
default <cite>ddof</cite> is zero.</p>
</dd>
<dt>keepdims<span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p>If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>var</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
<dt>where<span class="classifier">array_like of bool, optional</span></dt><dd><p>Elements to include in the variance. See <cite>~numpy.ufunc.reduce</cite> for
details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.20.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>variance<span class="classifier">ndarray, see dtype parameter above</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">out=None</span></code>, returns a new array containing the variance;
otherwise, a reference to the output array is returned.</p>
</dd>
</dl>
<p>std, mean, nanmean, nanstd, nanvar
<span class="xref std std-ref">ufuncs-output-type</span></p>
<p>The variance is the average of the squared deviations from the mean,
i.e.,  <code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">=</span> <span class="pre">mean(x)</span></code>, where <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">abs(a</span> <span class="pre">-</span> <span class="pre">a.mean())**2</span></code>.</p>
<p>The mean is typically calculated as <code class="docutils literal notranslate"><span class="pre">x.sum()</span> <span class="pre">/</span> <span class="pre">N</span></code>, where <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">len(x)</span></code>.
If, however, <cite>ddof</cite> is specified, the divisor <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">ddof</span></code> is used
instead.  In standard statistical practice, <code class="docutils literal notranslate"><span class="pre">ddof=1</span></code> provides an
unbiased estimator of the variance of a hypothetical infinite population.
<code class="docutils literal notranslate"><span class="pre">ddof=0</span></code> provides a maximum likelihood estimate of the variance for
normally distributed variables.</p>
<p>Note that for complex numbers, the absolute value is taken before
squaring, so that the result is always real and nonnegative.</p>
<p>For floating-point input, the variance is computed using the same
precision the input has.  Depending on the input data, this can cause
the results to be inaccurate, especially for <cite>float32</cite> (see example
below).  Specifying a higher-accuracy accumulator using the <code class="docutils literal notranslate"><span class="pre">dtype</span></code>
keyword can alleviate this issue.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1.25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([1.,  1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([0.25,  0.25])</span>
</pre></div>
</div>
<p>In single precision, var() can be inaccurate:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">512</span><span class="o">*</span><span class="mi">512</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">0.20250003</span>
</pre></div>
</div>
<p>Computing the variance in float64 is more accurate:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="go">0.20249999932944759 # may vary</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="mf">0.55</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mf">0.1</span><span class="o">-</span><span class="mf">0.55</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
<span class="go">0.2025</span>
</pre></div>
</div>
<p>Specifying a where argument:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">14</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">6.833333333333333 # may vary</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="p">[[</span><span class="kc">True</span><span class="p">],</span> <span class="p">[</span><span class="kc">True</span><span class="p">],</span> <span class="p">[</span><span class="kc">False</span><span class="p">]])</span>
<span class="go">4.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.vdot">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">vdot</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.vdot" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dot product of two vectors.</p>
<p>The vdot(<cite>a</cite>, <cite>b</cite>) function handles complex numbers differently than
dot(<cite>a</cite>, <cite>b</cite>).  If the first argument is complex the complex conjugate
of the first argument is used for the calculation of the dot product.</p>
<p>Note that <cite>vdot</cite> handles multidimensional arrays differently than <cite>dot</cite>:
it does <em>not</em> perform a matrix product, but flattens input arguments
to 1-D vectors first. Consequently, it should only be used for vectors.</p>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>If <cite>a</cite> is complex the complex conjugate is taken before calculation
of the dot product.</p>
</dd>
<dt>b<span class="classifier">array_like</span></dt><dd><p>Second argument to the dot product.</p>
</dd>
</dl>
<dl class="simple">
<dt>output<span class="classifier">ndarray</span></dt><dd><p>Dot product of <cite>a</cite> and <cite>b</cite>.  Can be an int, float, or
complex depending on the types of <cite>a</cite> and <cite>b</cite>.</p>
</dd>
</dl>
<dl class="simple">
<dt>dot<span class="classifier">Return the dot product without using the complex conjugate of the</span></dt><dd><p>first argument.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span><span class="mi">3</span><span class="o">+</span><span class="mi">4</span><span class="n">j</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="o">+</span><span class="mi">6</span><span class="n">j</span><span class="p">,</span><span class="mi">7</span><span class="o">+</span><span class="mi">8</span><span class="n">j</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">(70-8j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">(70+8j)</span>
</pre></div>
</div>
<p>Note that higher-dimensional arrays are flattened!</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span><span class="o">*</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">6</span><span class="o">*</span><span class="mi">2</span>
<span class="go">30</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt id="numpy.vectorize">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">vectorize</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pyfunc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">otypes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">doc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">excluded</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cache</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signature</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.vectorize" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>vectorize(pyfunc, otypes=None, doc=None, excluded=None, cache=False,</dt><dd><p>signature=None)</p>
</dd>
</dl>
<p>Generalized function class.</p>
<p>Define a vectorized function which takes a nested sequence of objects or
numpy arrays as inputs and returns a single numpy array or a tuple of numpy
arrays. The vectorized function evaluates <cite>pyfunc</cite> over successive tuples
of the input arrays like the python map function, except it uses the
broadcasting rules of numpy.</p>
<p>The data type of the output of <cite>vectorized</cite> is determined by calling
the function with the first element of the input.  This can be avoided
by specifying the <cite>otypes</cite> argument.</p>
<dl>
<dt>pyfunc<span class="classifier">callable</span></dt><dd><p>A python function or method.</p>
</dd>
<dt>otypes<span class="classifier">str or list of dtypes, optional</span></dt><dd><p>The output data type. It must be specified as either a string of
typecode characters or a list of data type specifiers. There should
be one data type specifier for each output.</p>
</dd>
<dt>doc<span class="classifier">str, optional</span></dt><dd><p>The docstring for the function. If None, the docstring will be the
<code class="docutils literal notranslate"><span class="pre">pyfunc.__doc__</span></code>.</p>
</dd>
<dt>excluded<span class="classifier">set, optional</span></dt><dd><p>Set of strings or integers representing the positional or keyword
arguments for which the function will not be vectorized.  These will be
passed directly to <cite>pyfunc</cite> unmodified.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
</dd>
<dt>cache<span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, then cache the first function call that determines the number
of outputs if <cite>otypes</cite> is not provided.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
</dd>
<dt>signature<span class="classifier">string, optional</span></dt><dd><p>Generalized universal function signature, e.g., <code class="docutils literal notranslate"><span class="pre">(m,n),(n)-&gt;(m)</span></code> for
vectorized matrix-vector multiplication. If provided, <code class="docutils literal notranslate"><span class="pre">pyfunc</span></code> will
be called with (and expected to return) arrays with shapes given by the
size of corresponding core dimensions. By default, <code class="docutils literal notranslate"><span class="pre">pyfunc</span></code> is
assumed to take scalars as input and output.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.12.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>vectorized<span class="classifier">callable</span></dt><dd><p>Vectorized function.</p>
</dd>
</dl>
<p>frompyfunc : Takes an arbitrary Python function and returns a ufunc</p>
<p>The <cite>vectorize</cite> function is provided primarily for convenience, not for
performance. The implementation is essentially a for loop.</p>
<p>If <cite>otypes</cite> is not specified, then a call to the function with the
first argument will be used to determine the number of outputs.  The
results of this call will be cached if <cite>cache</cite> is <cite>True</cite> to prevent
calling the function twice.  However, to implement the cache, the
original function must be wrapped which will slow down subsequent
calls, so only do this if your function is expensive.</p>
<p>The new keyword argument interface and <cite>excluded</cite> argument support
further degrades performance.</p>
<dl class="footnote brackets">
<dt class="label" id="id72"><span class="brackets">1</span></dt>
<dd><p><span class="xref std std-doc">/reference/c-api/generalized-ufuncs</span></p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">myfunc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="s2">&quot;Return a-b if a&gt;b, otherwise return a+b&quot;</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span>
<span class="gp">... </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vfunc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">myfunc</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vfunc</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([3, 4, 1, 2])</span>
</pre></div>
</div>
<p>The docstring is taken from the input function to <cite>vectorize</cite> unless it
is specified:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vfunc</span><span class="o">.</span><span class="vm">__doc__</span>
<span class="go">&#39;Return a-b if a&gt;b, otherwise return a+b&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vfunc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">myfunc</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s1">&#39;Vectorized `myfunc`&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vfunc</span><span class="o">.</span><span class="vm">__doc__</span>
<span class="go">&#39;Vectorized `myfunc`&#39;</span>
</pre></div>
</div>
<p>The output type is determined by evaluating the first element of the input,
unless it is specified:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">vfunc</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&lt;class &#39;numpy.int64&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vfunc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">myfunc</span><span class="p">,</span> <span class="n">otypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">vfunc</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&lt;class &#39;numpy.float64&#39;&gt;</span>
</pre></div>
</div>
<p>The <cite>excluded</cite> argument can be used to prevent vectorizing over certain
arguments.  This can be useful for array-like arguments of a fixed length
such as the coefficients for a polynomial as in <cite>polyval</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">mypolyval</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_p</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">res</span> <span class="o">=</span> <span class="n">_p</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">while</span> <span class="n">_p</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">_p</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">res</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vpolyval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">mypolyval</span><span class="p">,</span> <span class="n">excluded</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vpolyval</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">x</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">array([3, 6])</span>
</pre></div>
</div>
<p>Positional arguments may also be excluded by specifying their position:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vpolyval</span><span class="o">.</span><span class="n">excluded</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vpolyval</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">x</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">array([3, 6])</span>
</pre></div>
</div>
<p>The <cite>signature</cite> argument allows for vectorizing functions that act on
non-scalar arrays of fixed length. For example, you can use it for a
vectorized calculation of Pearson correlation coefficient and its p-value:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">scipy.stats</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pearsonr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">pearsonr</span><span class="p">,</span>
<span class="gp">... </span>                <span class="n">signature</span><span class="o">=</span><span class="s1">&#39;(n),(n)-&gt;(),()&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pearsonr</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="go">(array([ 1., -1.]), array([ 0.,  0.]))</span>
</pre></div>
</div>
<p>Or for a vectorized convolution:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">convolve</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="s1">&#39;(n),(m)-&gt;(k)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">convolve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">array([[1., 2., 1., 0., 0., 0.],</span>
<span class="go">       [0., 1., 2., 1., 0., 0.],</span>
<span class="go">       [0., 0., 1., 2., 1., 0.],</span>
<span class="go">       [0., 0., 0., 1., 2., 1.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt id="numpy.void">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">void</span></code><a class="headerlink" href="#numpy.void" title="Permalink to this definition">¶</a></dt>
<dd><p>Either an opaque sequence of bytes, or a structure.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">void</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abcd&#39;</span><span class="p">)</span>
<span class="go">void(b&#39;\x61\x62\x63\x64&#39;)</span>
</pre></div>
</div>
<p>Structured <cite>void</cite> scalars can only be constructed via extraction from <span class="xref std std-ref">structured_arrays</span>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="p">[()]</span>
<span class="go">(1, 2)  # looks like a tuple, but is `np.void`</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Character code</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">'V'</span></code></p>
</dd>
</dl>
<dl class="py attribute">
<dt id="numpy.void.base">
<code class="sig-name descname"><span class="pre">base</span></code><a class="headerlink" href="#numpy.void.base" title="Permalink to this definition">¶</a></dt>
<dd><p>base object</p>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.void.dtype">
<code class="sig-name descname"><span class="pre">dtype</span></code><a class="headerlink" href="#numpy.void.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>dtype object</p>
</dd></dl>

<dl class="py attribute">
<dt id="numpy.void.flags">
<code class="sig-name descname"><span class="pre">flags</span></code><a class="headerlink" href="#numpy.void.flags" title="Permalink to this definition">¶</a></dt>
<dd><p>integer value of flags</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.void.getfield">
<code class="sig-name descname"><span class="pre">getfield</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.void.getfield" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.getfield</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="numpy.void.setfield">
<code class="sig-name descname"><span class="pre">setfield</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.void.setfield" title="Permalink to this definition">¶</a></dt>
<dd><p>Scalar method identical to the corresponding array attribute.</p>
<p>Please see <cite>ndarray.setfield</cite>.</p>
</dd></dl>

</dd></dl>

<dl class="py attribute">
<dt id="numpy.void0">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">void0</span></code><a class="headerlink" href="#numpy.void0" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.void" title="numpy.void"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.void</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="numpy.vsplit">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">vsplit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ary</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices_or_sections</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.vsplit" title="Permalink to this definition">¶</a></dt>
<dd><p>Split an array into multiple sub-arrays vertically (row-wise).</p>
<p>Please refer to the <code class="docutils literal notranslate"><span class="pre">split</span></code> documentation.  <code class="docutils literal notranslate"><span class="pre">vsplit</span></code> is equivalent
to <code class="docutils literal notranslate"><span class="pre">split</span></code> with <cite>axis=0</cite> (default), the array is always split along the
first axis regardless of the array dimension.</p>
<p>split : Split an array into multiple sub-arrays of equal size.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">16.0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[ 0.,   1.,   2.,   3.],</span>
<span class="go">       [ 4.,   5.,   6.,   7.],</span>
<span class="go">       [ 8.,   9.,  10.,  11.],</span>
<span class="go">       [12.,  13.,  14.,  15.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vsplit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">[array([[0., 1., 2., 3.],</span>
<span class="go">       [4., 5., 6., 7.]]), array([[ 8.,  9., 10., 11.],</span>
<span class="go">       [12., 13., 14., 15.]])]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vsplit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">]))</span>
<span class="go">[array([[ 0.,  1.,  2.,  3.],</span>
<span class="go">       [ 4.,  5.,  6.,  7.],</span>
<span class="go">       [ 8.,  9., 10., 11.]]), array([[12., 13., 14., 15.]]), array([], shape=(0, 4), dtype=float64)]</span>
</pre></div>
</div>
<p>With a higher dimensional array the split is still along the first axis.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">8.0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[[0.,  1.],</span>
<span class="go">        [2.,  3.]],</span>
<span class="go">       [[4.,  5.],</span>
<span class="go">        [6.,  7.]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vsplit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">[array([[[0., 1.],</span>
<span class="go">        [2., 3.]]]), array([[[4., 5.],</span>
<span class="go">        [6., 7.]]])]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.vstack">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">vstack</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tup</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.vstack" title="Permalink to this definition">¶</a></dt>
<dd><p>Stack arrays in sequence vertically (row wise).</p>
<p>This is equivalent to concatenation along the first axis after 1-D arrays
of shape <cite>(N,)</cite> have been reshaped to <cite>(1,N)</cite>. Rebuilds arrays divided by
<cite>vsplit</cite>.</p>
<p>This function makes most sense for arrays with up to 3 dimensions. For
instance, for pixel-data with a height (first axis), width (second axis),
and r/g/b channels (third axis). The functions <cite>concatenate</cite>, <cite>stack</cite> and
<cite>block</cite> provide more general stacking and concatenation operations.</p>
<dl class="simple">
<dt>tup<span class="classifier">sequence of ndarrays</span></dt><dd><p>The arrays must have the same shape along all but the first axis.
1-D arrays must have the same length.</p>
</dd>
</dl>
<dl class="simple">
<dt>stacked<span class="classifier">ndarray</span></dt><dd><p>The array formed by stacking the given arrays, will be at least 2-D.</p>
</dd>
</dl>
<p>concatenate : Join a sequence of arrays along an existing axis.
stack : Join a sequence of arrays along a new axis.
block : Assemble an nd-array from nested lists of blocks.
hstack : Stack arrays in sequence horizontally (column wise).
dstack : Stack arrays in sequence depth wise (along third axis).
column_stack : Stack 1-D arrays as columns into a 2-D array.
vsplit : Split an array into multiple sub-arrays vertically (row-wise).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [4, 5, 6]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
<span class="go">array([[1],</span>
<span class="go">       [2],</span>
<span class="go">       [3],</span>
<span class="go">       [4],</span>
<span class="go">       [5],</span>
<span class="go">       [6]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.where">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">where</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">condition</span></em><span class="optional">[</span>, <em class="sig-param"><span class="pre">x</span></em>, <em class="sig-param"><span class="pre">y</span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.where" title="Permalink to this definition">¶</a></dt>
<dd><p>Return elements chosen from <cite>x</cite> or <cite>y</cite> depending on <cite>condition</cite>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When only <cite>condition</cite> is provided, this function is a shorthand for
<code class="docutils literal notranslate"><span class="pre">np.asarray(condition).nonzero()</span></code>. Using <cite>nonzero</cite> directly should be
preferred, as it behaves correctly for subclasses. The rest of this
documentation covers only the case where all three arguments are
provided.</p>
</div>
<dl class="simple">
<dt>condition<span class="classifier">array_like, bool</span></dt><dd><p>Where True, yield <cite>x</cite>, otherwise yield <cite>y</cite>.</p>
</dd>
<dt>x, y<span class="classifier">array_like</span></dt><dd><p>Values from which to choose. <cite>x</cite>, <cite>y</cite> and <cite>condition</cite> need to be
broadcastable to some shape.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>An array with elements from <cite>x</cite> where <cite>condition</cite> is True, and elements
from <cite>y</cite> elsewhere.</p>
</dd>
</dl>
<p>choose
nonzero : The function that is called when x and y are omitted</p>
<p>If all the arrays are 1-D, <cite>where</cite> is equivalent to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">xv</span> <span class="k">if</span> <span class="n">c</span> <span class="k">else</span> <span class="n">yv</span>
 <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">xv</span><span class="p">,</span> <span class="n">yv</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="mi">10</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([ 0,  1,  2,  3,  4, 50, 60, 70, 80, 90])</span>
</pre></div>
</div>
<p>This can be used on multidimensional arrays too:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">([[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]],</span>
<span class="gp">... </span>         <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]],</span>
<span class="gp">... </span>         <span class="p">[[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="go">array([[1, 8],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
<p>The shapes of x, y, and the condition are broadcast together:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ogrid</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>  <span class="c1"># both x and 10+y are broadcast</span>
<span class="go">array([[10,  0,  0,  0],</span>
<span class="go">       [10, 11,  1,  1],</span>
<span class="go">       [10, 11, 12,  2]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># -1 is broadcast</span>
<span class="go">array([[ 0,  1,  2],</span>
<span class="go">       [ 0,  2, -1],</span>
<span class="go">       [ 0,  3, -1]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.who">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">who</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vardict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.who" title="Permalink to this definition">¶</a></dt>
<dd><p>Print the NumPy arrays in the given dictionary.</p>
<p>If there is no dictionary passed in or <cite>vardict</cite> is None then returns
NumPy arrays in the globals() dictionary (all NumPy arrays in the
namespace).</p>
<dl class="simple">
<dt>vardict<span class="classifier">dict, optional</span></dt><dd><p>A dictionary possibly containing ndarrays.  Default is globals().</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">None</span></dt><dd><p>Returns ‘None’.</p>
</dd>
</dl>
<p>Prints out the name, shape, bytes and type of all of the ndarrays
present in <cite>vardict</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">who</span><span class="p">()</span>
<span class="go">Name            Shape            Bytes            Type</span>
<span class="go">===========================================================</span>
<span class="go">a               10               80               int64</span>
<span class="go">b               20               160              float64</span>
<span class="go">Upper bound on total bytes  =       240</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">2.0</span><span class="p">),</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">3.0</span><span class="p">),</span> <span class="s1">&#39;txt&#39;</span><span class="p">:</span> <span class="s1">&#39;Some str&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="s1">&#39;idx&#39;</span><span class="p">:</span><span class="mi">5</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">who</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="go">Name            Shape            Bytes            Type</span>
<span class="go">===========================================================</span>
<span class="go">x               2                16               float64</span>
<span class="go">y               3                24               float64</span>
<span class="go">Upper bound on total bytes  =       40</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.zeros">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">zeros</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'C'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">like</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new array of given shape and type, filled with zeros.</p>
<dl>
<dt>shape<span class="classifier">int or tuple of ints</span></dt><dd><p>Shape of the new array, e.g., <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">3)</span></code> or <code class="docutils literal notranslate"><span class="pre">2</span></code>.</p>
</dd>
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>The desired data-type for the array, e.g., <cite>numpy.int8</cite>.  Default is
<cite>numpy.float64</cite>.</p>
</dd>
<dt>order<span class="classifier">{‘C’, ‘F’}, optional, default: ‘C’</span></dt><dd><p>Whether to store multi-dimensional data in row-major
(C-style) or column-major (Fortran-style) order in
memory.</p>
</dd>
<dt>like<span class="classifier">array_like</span></dt><dd><p>Reference object to allow the creation of arrays which are not
NumPy arrays. If an array-like passed in as <code class="docutils literal notranslate"><span class="pre">like</span></code> supports
the <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> protocol, the result will be defined
by it. In this case, it ensures the creation of an array object
compatible with that passed in via this argument.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.20.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>Array of zeros with the given shape, dtype, and order.</p>
</dd>
</dl>
<p>zeros_like : Return an array of zeros with shape and type of input.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
full : Return a new array of given shape filled with value.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">array([ 0.,  0.,  0.,  0.,  0.])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([0, 0, 0, 0, 0])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">array([[ 0.],</span>
<span class="go">       [ 0.]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">array([[ 0.,  0.],</span>
<span class="go">       [ 0.,  0.]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;i4&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;i4&#39;</span><span class="p">)])</span> <span class="c1"># custom dtype</span>
<span class="go">array([(0, 0), (0, 0)],</span>
<span class="go">      dtype=[(&#39;x&#39;, &#39;&lt;i4&#39;), (&#39;y&#39;, &#39;&lt;i4&#39;)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="numpy.zeros_like">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">zeros_like</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'K'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subok</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.zeros_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of zeros with the same shape and type as a given array.</p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>The shape and data-type of <cite>a</cite> define these same attributes of
the returned array.</p>
</dd>
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>Overrides the data type of the result.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.6.0.</span></p>
</div>
</dd>
<dt>order<span class="classifier">{‘C’, ‘F’, ‘A’, or ‘K’}, optional</span></dt><dd><p>Overrides the memory layout of the result. ‘C’ means C-order,
‘F’ means F-order, ‘A’ means ‘F’ if <cite>a</cite> is Fortran contiguous,
‘C’ otherwise. ‘K’ means match the layout of <cite>a</cite> as closely
as possible.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.6.0.</span></p>
</div>
</dd>
<dt>subok<span class="classifier">bool, optional.</span></dt><dd><p>If True, then the newly created array will use the sub-class
type of <cite>a</cite>, otherwise it will be a base-class array. Defaults
to True.</p>
</dd>
<dt>shape<span class="classifier">int or sequence of ints, optional.</span></dt><dd><p>Overrides the shape of the result. If order=’K’ and the number of
dimensions is unchanged, will try to keep order, otherwise,
order=’C’ is implied.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.17.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>Array of zeros with the same shape and type as <cite>a</cite>.</p>
</dd>
</dl>
<p>empty_like : Return an empty array with shape and type of input.
ones_like : Return an array of ones with shape and type of input.
full_like : Return a new array with shape of input filled with value.
zeros : Return a new array setting values to zero.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([[0, 0, 0],</span>
<span class="go">       [0, 0, 0]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([0., 1., 2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">array([0.,  0.,  0.])</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="func-one">
<h2>Func one<a class="headerlink" href="#func-one" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="id0">
<code class="sig-prename descclassname"><span class="pre">numpy.</span></code><code class="sig-name descname"><span class="pre">sum</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">a</span></em>, <em class="sig-param"><span class="pre">axis=None</span></em>, <em class="sig-param"><span class="pre">dtype=None</span></em>, <em class="sig-param"><span class="pre">out=None</span></em>, <em class="sig-param"><span class="pre">keepdims=&lt;no</span> <span class="pre">value&gt;</span></em>, <em class="sig-param"><span class="pre">initial=&lt;no</span> <span class="pre">value&gt;</span></em>, <em class="sig-param"><span class="pre">where=&lt;no</span> <span class="pre">value&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id0" title="Permalink to this definition">¶</a></dt>
<dd><p>Sum of array elements over a given axis.</p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Elements to sum.</p>
</dd>
<dt>axis<span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Axis or axes along which a sum is performed.  The default,
axis=None, will sum all of the elements of the input array.  If
axis is negative it counts from the last to the first axis.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<p>If axis is a tuple of ints, a sum is performed on all of the axes
specified in the tuple instead of a single axis or all the axes as
before.</p>
</dd>
<dt>dtype<span class="classifier">dtype, optional</span></dt><dd><p>The type of the returned array and of the accumulator in which the
elements are summed.  The dtype of <cite>a</cite> is used by default unless <cite>a</cite>
has an integer dtype of less precision than the default platform
integer.  In that case, if <cite>a</cite> is signed then the platform integer
is used while if <cite>a</cite> is unsigned then an unsigned integer of the
same precision as the platform integer is used.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Alternative output array in which to place the result. It must have
the same shape as the expected output, but the type of the output
values will be cast if necessary.</p>
</dd>
<dt>keepdims<span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p>If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>sum</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
<dt>initial<span class="classifier">scalar, optional</span></dt><dd><p>Starting value for the sum. See <cite>~numpy.ufunc.reduce</cite> for details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.15.0.</span></p>
</div>
</dd>
<dt>where<span class="classifier">array_like of bool, optional</span></dt><dd><p>Elements to include in the sum. See <cite>~numpy.ufunc.reduce</cite> for details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.17.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>sum_along_axis<span class="classifier">ndarray</span></dt><dd><p>An array with the same shape as <cite>a</cite>, with the specified
axis removed.   If <cite>a</cite> is a 0-d array, or if <cite>axis</cite> is None, a scalar
is returned.  If an output array is specified, a reference to
<cite>out</cite> is returned.</p>
</dd>
</dl>
<p>ndarray.sum : Equivalent method.</p>
<p>add.reduce : Equivalent functionality of <cite>add</cite>.</p>
<p>cumsum : Cumulative sum of array elements.</p>
<p>trapz : Integration of array values using the composite trapezoidal rule.</p>
<p>mean, average</p>
<p>Arithmetic is modular when using integer types, and no error is
raised on overflow.</p>
<p>The sum of an empty array is the neutral element 0:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([])</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p>For floating point numbers the numerical precision of sum (and
<code class="docutils literal notranslate"><span class="pre">np.add.reduce</span></code>) is in general limited by directly adding each number
individually to the result causing rounding errors in every step.
However, often numpy will use a  numerically better approach (partial
pairwise summation) leading to improved precision in many use-cases.
This improved precision is always provided when no <code class="docutils literal notranslate"><span class="pre">axis</span></code> is given.
When <code class="docutils literal notranslate"><span class="pre">axis</span></code> is given, it will depend on which axis is summed.
Technically, to provide the best speed possible, the improved precision
is only used when the summation is along the fast axis in memory.
Note that the exact precision may vary depending on other parameters.
In contrast to NumPy, Python’s <code class="docutils literal notranslate"><span class="pre">math.fsum</span></code> function uses a slower but
more precise approach to summation.
Especially when summing a large number of lower precision floating point
numbers, such as <code class="docutils literal notranslate"><span class="pre">float32</span></code>, numerical errors can become significant.
In such cases it can be advisable to use <cite>dtype=”float64”</cite> to use a higher
precision for the output.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">])</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([0, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([1, 5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="n">where</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([1., 5.])</span>
</pre></div>
</div>
<p>If the accumulator is too small, overflow occurs:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
<span class="go">-128</span>
</pre></div>
</div>
<p>You can also start the sum with a value other than zero:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="mi">10</span><span class="p">],</span> <span class="n">initial</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">15</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="id73">
<h2>Func one<a class="headerlink" href="#id73" title="Permalink to this headline">¶</a></h2>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "fedem-p/h5_tiff_converter",
            ref: "main",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./api"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
            



<div class='prev-next-bottom'>
    
    <div id="prev">
        <a class="left-prev" href="../001_h5_to_single_tiff.html" title="previous page">
            <i class="prevnext-label fas fa-angle-left"></i>
            <div class="prevnext-info">
                <p class="prevnext-label">previous</p>
                <p class="prevnext-title">First Tutorial</p>
            </div>
        </a>
    </div>

</div>
        
        </div>
    </div>
    <footer class="footer">
    <div class="container">
      <p>
        
          By Federico Puppo<br/>
        
            &copy; Copyright 2021.<br/>
          <div class="extra_footer">
            Mantained by Federico Puppo
          </div>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="../_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  
  </body>
</html>